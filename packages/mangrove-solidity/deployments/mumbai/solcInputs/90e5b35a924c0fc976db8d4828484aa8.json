{
  "language": "Solidity",
  "sources": {
    "cache/solpp-generated-contracts/AbstractMangrove.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n// AbstractMangrove.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n\nimport {MgvLib as ML} from \"./MgvLib.sol\";\n\nimport {MgvOfferMaking} from \"./MgvOfferMaking.sol\";\nimport {MgvOfferTakingWithPermit} from \"./MgvOfferTakingWithPermit.sol\";\nimport {MgvGovernable} from \"./MgvGovernable.sol\";\n\n/* `AbstractMangrove` inherits the three contracts that implement generic Mangrove functionality (`MgvGovernable`,`MgvOfferTakingWithPermit` and `MgvOfferMaking`) but does not implement the abstract functions. */\nabstract contract AbstractMangrove is\n  MgvGovernable,\n  MgvOfferTakingWithPermit,\n  MgvOfferMaking\n{\n  constructor(\n    address governance,\n    uint gasprice,\n    uint gasmax,\n    string memory contractName\n  )\n    MgvOfferTakingWithPermit(contractName)\n    MgvGovernable(governance, gasprice, gasmax)\n  {}\n}\n"
    },
    "cache/solpp-generated-contracts/MgvLib.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier: Unlicense\n\n// MgvLib.sol\n\n// This is free and unencumbered software released into the public domain.\n\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.\n\n// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For more information, please refer to <https://unlicense.org/>\n\n/* `MgvLib` contains data structures returned by external calls to Mangrove and the interfaces it uses for its own external calls. */\n\n\n\n\n/* # Structs\nThe structs defined in `structs.js` have their counterpart as solidity structs that are easy to manipulate for outside contracts / callers of view functions. */\nlibrary MgvLib {\n  struct Offer {\n    uint prev;\n    uint next;\n    uint gives;\n    uint wants;\n    uint gasprice;\n  }\n\n  struct OfferDetail {\n    address maker;\n    uint gasreq;\n    uint overhead_gasbase;\n    uint offer_gasbase;\n  }\n  struct Global {\n    address monitor;\n    bool useOracle;\n    bool notify;\n    uint gasprice;\n    uint gasmax;\n    bool dead;\n  }\n\n  struct Local {\n    bool active;\n    uint fee;\n    uint density;\n    uint overhead_gasbase;\n    uint offer_gasbase;\n    bool lock;\n    uint best;\n    uint last;\n  }\n\n  /*\n   Some miscellaneous data types useful to `Mangrove` and external contracts */\n  //+clear+\n\n  /* `SingleOrder` holds data about an order-offer match in a struct. Used by `marketOrder` and `internalSnipes` (and some of their nested functions) to avoid stack too deep errors. */\n  struct SingleOrder {\n    address outbound_tkn;\n    address inbound_tkn;\n    uint offerId;\n    bytes32 offer;\n    /* `wants`/`gives` mutate over execution. Initially the `wants`/`gives` from the taker's pov, then actual `wants`/`gives` adjusted by offer's price and volume. */\n    uint wants;\n    uint gives;\n    /* `offerDetail` is only populated when necessary. */\n    bytes32 offerDetail;\n    bytes32 global;\n    bytes32 local;\n  }\n\n  /* <a id=\"MgvLib/OrderResult\"></a> `OrderResult` holds additional data for the maker and is given to them _after_ they fulfilled an offer. It gives them their own returned data from the previous call, and an `mgvData` specifying whether the Mangrove encountered an error. */\n\n  struct OrderResult {\n    /* `makerdata` holds a message that was either returned by the maker or passed as revert message at the end of the trade execution*/\n    bytes32 makerData;\n    /* `mgvData` is an [internal Mangrove status](#MgvOfferTaking/statusCodes) code. */\n    bytes32 mgvData;\n  }\n}\n\n/* # Events\nThe events emitted for use by bots are listed here: */\ncontract HasMgvEvents {\n  /* * Emitted at the creation of the new Mangrove contract on the pair (`inbound_tkn`, `outbound_tkn`)*/\n  event NewMgv();\n\n  /* Mangrove adds or removes wei from `maker`'s account */\n  /* * Credit event occurs when an offer is removed from the Mangrove or when the `fund` function is called*/\n  event Credit(address indexed maker, uint amount);\n  /* * Debit event occurs when an offer is posted or when the `withdraw` function is called */\n  event Debit(address indexed maker, uint amount);\n\n  /* * Mangrove reconfiguration */\n  event SetActive(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    bool value\n  );\n  event SetFee(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint value\n  );\n  event SetGasbase(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint overhead_gasbase,\n    uint offer_gasbase\n  );\n  event SetGovernance(address value);\n  event SetMonitor(address value);\n  event SetVault(address value);\n  event SetUseOracle(bool value);\n  event SetNotify(bool value);\n  event SetGasmax(uint value);\n  event SetDensity(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint value\n  );\n  event SetGasprice(uint value);\n\n  /* Market order execution */\n  event OrderComplete(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    address taker,\n    uint takerGot,\n    uint takerGave\n  );\n\n  /* * Offer execution */\n  event OfferSuccess(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint id,\n    // `maker` is not logged because it can be retrieved from the state using `(outbound_tkn,inbound_tkn,id)`.\n    address taker,\n    uint takerWants,\n    uint takerGives\n  );\n\n  /* Log information when a trade execution reverts or returns a non empty bytes32 word */\n  event OfferFail(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint id,\n    // `maker` is not logged because it can be retrieved from the state using `(outbound_tkn,inbound_tkn,id)`.\n    address taker,\n    uint takerWants,\n    uint takerGives,\n    // `mgvData` may only be `\"mgv/makerRevert\"`, `\"mgv/makerAbort\"`, `\"mgv/makerTransferFail\"` or `\"mgv/makerReceiveFail\"`\n    bytes32 mgvData\n  );\n\n  /* Log information when a posthook reverts */\n  event PosthookFail(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint offerId\n  );\n\n  /* * After `permit` and `approve` */\n  event Approval(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    address owner,\n    address spender,\n    uint value\n  );\n\n  /* * Mangrove closure */\n  event Kill();\n\n  /* * An offer was created or updated.\n  A few words about why we include a `prev` field, and why we don't include a\n  `next` field: in theory clients should need neither `prev` nor a `next` field.\n  They could just 1. Read the order book state at a given block `b`.  2. On\n  every event, update a local copy of the orderbook.  But in practice, we do not\n  want to force clients to keep a copy of the *entire* orderbook. There may be a\n  long tail of spam. Now if they only start with the first $N$ offers and\n  receive a new offer that goes to the end of the book, they cannot tell if\n  there are missing offers between the new offer and the end of the local copy\n  of the book.\n  \n  So we add a prev pointer so clients with only a prefix of the book can receive\n  out-of-prefix offers and know what to do with them. The `next` pointer is an\n  optimization useful in Solidity (we traverse fewer memory locations) but\n  useless in client code.\n  */\n  event OfferWrite(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    address maker,\n    uint wants,\n    uint gives,\n    uint gasprice,\n    uint gasreq,\n    uint id,\n    uint prev\n  );\n\n  /* * `offerId` was present and is now removed from the book. */\n  event OfferRetract(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint id\n  );\n}\n\n/* # IMaker interface */\ninterface IMaker {\n  /* Called upon offer execution. If the call returns normally with the first 32 bytes are 0, Mangrove will try to transfer funds; otherwise not. Returned data (truncated to leftmost 32 bytes) can be accessed during the call to `makerPosthook` in the `result.mgvData` field. To revert with a 32 bytes value, use something like:\n     ```\n     function tradeRevert(bytes32 data) internal pure {\n       bytes memory revData = new bytes(32);\n         assembly {\n           mstore(add(revData, 32), data)\n           revert(add(revData, 32), 32)\n         }\n     }\n     ```\n     */\n  function makerExecute(MgvLib.SingleOrder calldata order)\n    external\n    returns (bytes32);\n\n  /* Called after all offers of an order have been executed. Posthook of the last executed order is called first and full reentrancy into the Mangrove is enabled at this time. `order` recalls key arguments of the order that was processed and `result` recalls important information for updating the current offer. (see [above](#MgvLib/OrderResult))*/\n  function makerPosthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata result\n  ) external;\n}\n\n/* # ITaker interface */\ninterface ITaker {\n  /* Inverted mangrove only: call to taker after loans went through */\n  function takerTrade(\n    address outbound_tkn,\n    address inbound_tkn,\n    // total amount of outbound_tkn token that was flashloaned to the taker\n    uint totalGot,\n    // total amount of inbound_tkn token that should be made available\n    uint totalGives\n  ) external;\n}\n\n/* # Monitor interface\nIf enabled, the monitor receives notification after each offer execution and is read for each pair's `gasprice` and `density`. */\ninterface IMgvMonitor {\n  function notifySuccess(MgvLib.SingleOrder calldata sor, address taker)\n    external;\n\n  function notifyFail(MgvLib.SingleOrder calldata sor, address taker) external;\n\n  function read(address outbound_tkn, address inbound_tkn)\n    external\n    view\n    returns (uint gasprice, uint density);\n}\n\ninterface IERC20 {\n  function totalSupply() external view returns (uint);\n\n  function balanceOf(address account) external view returns (uint);\n\n  function transfer(address recipient, uint amount) external returns (bool);\n\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint);\n\n  function approve(address spender, uint amount) external returns (bool);\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint amount\n  ) external returns (bool);\n\n  function symbol() external view returns (string memory);\n\n  event Transfer(address indexed from, address indexed to, uint value);\n  event Approval(address indexed owner, address indexed spender, uint value);\n\n  /// for wETH contract\n  function deposit() external payable;\n\n  function withdraw(uint) external;\n\n  function decimals() external view returns (uint8);\n}\n"
    },
    "cache/solpp-generated-contracts/MgvOfferMaking.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvOfferMaking.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n\nimport {IMaker, HasMgvEvents} from \"./MgvLib.sol\";\nimport {MgvHasOffers} from \"./MgvHasOffers.sol\";\n\n/* `MgvOfferMaking` contains market-making-related functions. */\ncontract MgvOfferMaking is MgvHasOffers {\n  /* # Public Maker operations\n     ## New Offer */\n  //+clear+\n  /* In the Mangrove, makers and takers call separate functions. Market makers call `newOffer` to fill the book, and takers call functions such as `marketOrder` to consume it.  */\n\n  //+clear+\n\n  /* The following structs holds offer creation/update parameters in memory. This frees up stack space for local variables. */\n  struct OfferPack {\n    address outbound_tkn;\n    address inbound_tkn;\n    uint wants;\n    uint gives;\n    uint id;\n    uint gasreq;\n    uint gasprice;\n    uint pivotId;\n    bytes32 global;\n    bytes32 local;\n    // used on update only\n    bytes32 oldOffer;\n  }\n\n  /* The function `newOffer` is for market makers only; no match with the existing book is done. A maker specifies how much `inbound_tkn` it `wants` and how much `outbound_tkn` it `gives`.\n\n     It also specify with `gasreq` how much gas should be given when executing their offer.\n\n     `gasprice` indicates an upper bound on the gasprice at which the maker is ready to be penalised if their offer fails. Any value below the Mangrove's internal `gasprice` configuration value will be ignored.\n\n    `gasreq`, together with `gasprice`, will contribute to determining the penalty provision set aside by the Mangrove from the market maker's `balanceOf` balance.\n\n  Offers are always inserted at the correct place in the book. This requires walking through offers to find the correct insertion point. As in [Oasis](https://github.com/daifoundation/maker-otc/blob/f2060c5fe12fe3da71ac98e8f6acc06bca3698f5/src/matching_market.sol#L493), the maker should find the id of an offer close to its own and provide it as `pivotId`.\n\n  An offer cannot be inserted in a closed market, nor when a reentrancy lock for `outbound_tkn`,`inbound_tkn` is on.\n\n  No more than $2^{24}-1$ offers can ever be created for one `outbound_tkn`,`inbound_tkn` pair.\n\n  The actual contents of the function is in `writeOffer`, which is called by both `newOffer` and `updateOffer`.\n  */\n  function newOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint gasprice,\n    uint pivotId\n  ) external returns (uint) {\n    /* In preparation for calling `writeOffer`, we read the `outbound_tkn`,`inbound_tkn` pair configuration, check for reentrancy and market liveness, fill the `OfferPack` struct and increment the `outbound_tkn`,`inbound_tkn` pair's `last`. */\n    OfferPack memory ofp;\n    (ofp.global, ofp.local) = config(outbound_tkn, inbound_tkn);\n    unlockedMarketOnly(ofp.local);\n    activeMarketOnly(ofp.global, ofp.local);\n\n    ofp.id = 1 + uint(uint((ofp.local << 136)) >> 232);\n    require(uint24(ofp.id) == ofp.id, \"mgv/offerIdOverflow\");\n\n    ofp.local = (ofp.local & bytes32(0xffffffffffffffffffffffffffffffffff000000ffffffffffffffffffffffff) | bytes32((uint(ofp.id) << 232) >> 136));\n\n    ofp.outbound_tkn = outbound_tkn;\n    ofp.inbound_tkn = inbound_tkn;\n    ofp.wants = wants;\n    ofp.gives = gives;\n    ofp.gasreq = gasreq;\n    ofp.gasprice = gasprice;\n    ofp.pivotId = pivotId;\n\n    /* The second parameter to writeOffer indicates that we are creating a new offer, not updating an existing one. */\n    writeOffer(ofp, false);\n\n    /* Since we locally modified a field of the local configuration (`last`), we save the change to storage. Note that `writeOffer` may have further modified the local configuration by updating the current `best` offer. */\n    locals[ofp.outbound_tkn][ofp.inbound_tkn] = ofp.local;\n    return ofp.id;\n  }\n\n  /* ## Update Offer */\n  //+clear+\n  /* Very similar to `newOffer`, `updateOffer` prepares an `OfferPack` for `writeOffer`. Makers should use it for updating live offers, but also to save on gas by reusing old, already consumed offers.\n\n     A `pivotId` should still be given to minimise reads in the offer book. It is OK to give the offers' own id as a pivot.\n\n\n     Gas use is minimal when:\n     1. The offer does not move in the book\n     2. The offer does not change its `gasreq`\n     3. The (`outbound_tkn`,`inbound_tkn`)'s `*_gasbase` has not changed since the offer was last written\n     4. `gasprice` has not changed since the offer was last written\n     5. `gasprice` is greater than the Mangrove's gasprice estimation\n  */\n  function updateOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint gasprice,\n    uint pivotId,\n    uint offerId\n  ) external {\n    OfferPack memory ofp;\n    (ofp.global, ofp.local) = config(outbound_tkn, inbound_tkn);\n    unlockedMarketOnly(ofp.local);\n    activeMarketOnly(ofp.global, ofp.local);\n    ofp.outbound_tkn = outbound_tkn;\n    ofp.inbound_tkn = inbound_tkn;\n    ofp.wants = wants;\n    ofp.gives = gives;\n    ofp.id = offerId;\n    ofp.gasreq = gasreq;\n    ofp.gasprice = gasprice;\n    ofp.pivotId = pivotId;\n    ofp.oldOffer = offers[outbound_tkn][inbound_tkn][offerId];\n    // Save local config\n    bytes32 oldLocal = ofp.local;\n    /* The second argument indicates that we are updating an existing offer, not creating a new one. */\n    writeOffer(ofp, true);\n    /* We saved the current pair's configuration before calling `writeOffer`, since that function may update the current `best` offer. We now check for any change to the configuration and update it if needed. */\n    if (oldLocal != ofp.local) {\n      locals[ofp.outbound_tkn][ofp.inbound_tkn] = ofp.local;\n    }\n  }\n\n  /* ## Retract Offer */\n  //+clear+\n  /* `retractOffer` takes the offer `offerId` out of the book. However, `deprovision == true` also refunds the provision associated with the offer. */\n  function retractOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId,\n    bool deprovision\n  ) external {\n    (, bytes32 local) = config(outbound_tkn, inbound_tkn);\n    unlockedMarketOnly(local);\n    bytes32 offer = offers[outbound_tkn][inbound_tkn][offerId];\n    bytes32 offerDetail = offerDetails[outbound_tkn][inbound_tkn][offerId];\n    require(\n      msg.sender == address(uint((offerDetail << 0)) >> 96),\n      \"mgv/retractOffer/unauthorized\"\n    );\n\n    /* Here, we are about to un-live an offer, so we start by taking it out of the book by stitching together its previous and next offers. Note that unconditionally calling `stitchOffers` would break the book since it would connect offers that may have since moved. */\n    if (isLive(offer)) {\n      bytes32 oldLocal = local;\n      local = stitchOffers(\n        outbound_tkn,\n        inbound_tkn,\n        uint(uint((offer << 0)) >> 232),\n        uint(uint((offer << 24)) >> 232),\n        local\n      );\n      /* If calling `stitchOffers` has changed the current `best` offer, we update the storage. */\n      if (oldLocal != local) {\n        locals[outbound_tkn][inbound_tkn] = local;\n      }\n    }\n    /* Set `gives` to 0. Moreover, the last argument depends on whether the user wishes to get their provision back (if true, `gasprice` will be set to 0 as well). */\n    dirtyDeleteOffer(outbound_tkn, inbound_tkn, offerId, offer, deprovision);\n\n    /* If the user wants to get their provision back, we compute its provision from the offer's `gasprice`, `*_gasbase` and `gasreq`. */\n    if (deprovision) {\n      uint provision = 10**9 *\n        uint(uint((offer << 240)) >> 240) * //gasprice is 0 if offer was deprovisioned\n        (uint(uint((offerDetail << 160)) >> 232) +\n          uint(uint((offerDetail << 184)) >> 232) +\n          uint(uint((offerDetail << 208)) >> 232));\n      // credit `balanceOf` and log transfer\n      creditWei(msg.sender, provision);\n    }\n    emit OfferRetract(outbound_tkn, inbound_tkn, offerId);\n  }\n\n  /* ## Provisioning\n  Market makers must have enough provisions for possible penalties. These provisions are in ETH. Every time a new offer is created or an offer is updated, `balanceOf` is adjusted to provision the offer's maximum possible penalty (`gasprice * (gasreq + overhead_gasbase + offer_gasbase)`).\n\n  For instance, if the current `balanceOf` of a maker is 1 ether and they create an offer that requires a provision of 0.01 ethers, their `balanceOf` will be reduced to 0.99 ethers. No ethers will move; this is just an internal accounting movement to make sure the maker cannot `withdraw` the provisioned amounts.\n\n  */\n  //+clear+\n\n  /* Fund should be called with a nonzero value (hence the `payable` modifier). The provision will be given to `maker`, not `msg.sender`. */\n  function fund(address maker) public payable {\n    (bytes32 _global, ) = config(address(0), address(0));\n    liveMgvOnly(_global);\n    creditWei(maker, msg.value);\n  }\n\n  function fund() external payable {\n    fund(msg.sender);\n  }\n\n  /* A transfer with enough gas to the Mangrove will increase the caller's available `balanceOf` balance. _You should send enough gas to execute this function when sending money to the Mangrove._  */\n  receive() external payable {\n    fund(msg.sender);\n  }\n\n  /* Any provision not currently held to secure an offer's possible penalty is available for withdrawal. */\n  function withdraw(uint amount) external returns (bool noRevert) {\n    /* Since we only ever send money to the caller, we do not need to provide any particular amount of gas, the caller should manage this herself. */\n    debitWei(msg.sender, amount);\n    (noRevert, ) = msg.sender.call{value: amount}(\"\");\n  }\n\n  /* # Low-level Maker functions */\n\n  /* ## Write Offer */\n\n  function writeOffer(OfferPack memory ofp, bool update) internal {\n    /* `gasprice`'s floor is Mangrove's own gasprice estimate, `ofp.global.gasprice`. We first check that gasprice fits in 16 bits. Otherwise it could be that `uint16(gasprice) < global_gasprice < gasprice`, and the actual value we store is `uint16(gasprice)`. */\n    require(\n      uint16(ofp.gasprice) == ofp.gasprice,\n      \"mgv/writeOffer/gasprice/16bits\"\n    );\n\n    if (ofp.gasprice < uint(uint((ofp.global << 176)) >> 240)) {\n      ofp.gasprice = uint(uint((ofp.global << 176)) >> 240);\n    }\n\n    /* * Check `gasreq` below limit. Implies `gasreq` at most 24 bits wide, which ensures no overflow in computation of `provision` (see below). */\n    require(\n      ofp.gasreq <= uint(uint((ofp.global << 192)) >> 232),\n      \"mgv/writeOffer/gasreq/tooHigh\"\n    );\n    /* * Make sure `gives > 0` -- division by 0 would throw in several places otherwise, and `isLive` relies on it. */\n    require(ofp.gives > 0, \"mgv/writeOffer/gives/tooLow\");\n    /* * Make sure that the maker is posting a 'dense enough' offer: the ratio of `outbound_tkn` offered per gas consumed must be high enough. The actual gas cost paid by the taker is overapproximated by adding `offer_gasbase` to `gasreq`. */\n    require(\n      ofp.gives >=\n        (ofp.gasreq + uint(uint((ofp.local << 80)) >> 232)) *\n          uint(uint((ofp.local << 24)) >> 224),\n      \"mgv/writeOffer/density/tooLow\"\n    );\n\n    /* The following checks are for the maker's convenience only. */\n    require(uint96(ofp.gives) == ofp.gives, \"mgv/writeOffer/gives/96bits\");\n    require(uint96(ofp.wants) == ofp.wants, \"mgv/writeOffer/wants/96bits\");\n\n    /* The position of the new or updated offer is found using `findPosition`. If the offer is the best one, `prev == 0`, and if it's the last in the book, `next == 0`.\n\n       `findPosition` is only ever called here, but exists as a separate function to make the code easier to read.\n\n    **Warning**: `findPosition` will call `better`, which may read the offer's `offerDetails`. So it is important to find the offer position _before_ we update its `offerDetail` in storage. We waste 1 (hot) read in that case but we deem that the code would get too ugly if we passed the old `offerDetail` as argument to `findPosition` and to `better`, just to save 1 hot read in that specific case.  */\n    (uint prev, uint next) = findPosition(ofp);\n\n    /* Log the write offer event. */\n    emit OfferWrite(\n      ofp.outbound_tkn,\n      ofp.inbound_tkn,\n      msg.sender,\n      ofp.wants,\n      ofp.gives,\n      ofp.gasprice,\n      ofp.gasreq,\n      ofp.id,\n      prev\n    );\n\n    /* We now write the new `offerDetails` and remember the previous provision (0 by default, for new offers) to balance out maker's `balanceOf`. */\n    uint oldProvision;\n    {\n      bytes32 offerDetail = offerDetails[ofp.outbound_tkn][ofp.inbound_tkn][\n        ofp.id\n      ];\n      if (update) {\n        require(\n          msg.sender == address(uint((offerDetail << 0)) >> 96),\n          \"mgv/updateOffer/unauthorized\"\n        );\n        oldProvision =\n          10**9 *\n          uint(uint((ofp.oldOffer << 240)) >> 240) *\n          (uint(uint((offerDetail << 160)) >> 232) +\n            uint(uint((offerDetail << 184)) >> 232) +\n            uint(uint((offerDetail << 208)) >> 232));\n      }\n\n      /* If the offer is new, has a new `gasreq`, or if the Mangrove's `*_gasbase` configuration parameter has changed, we also update `offerDetails`. */\n      if (\n        !update ||\n        uint(uint((offerDetail << 160)) >> 232) != ofp.gasreq ||\n        uint(uint((offerDetail << 184)) >> 232) !=\n        uint(uint((ofp.local << 56)) >> 232) ||\n        uint(uint((offerDetail << 208)) >> 232) !=\n        uint(uint((ofp.local << 80)) >> 232)\n      ) {\n        uint overhead_gasbase = uint(uint((ofp.local << 56)) >> 232);\n        uint offer_gasbase = uint(uint((ofp.local << 80)) >> 232);\n        offerDetails[ofp.outbound_tkn][ofp.inbound_tkn][ofp.id] = ((((bytes32(0) | bytes32((uint(uint(msg.sender)) << 96) >> 0)) | bytes32((uint(ofp.gasreq) << 232) >> 160)) | bytes32((uint(overhead_gasbase) << 232) >> 184)) | bytes32((uint(offer_gasbase) << 232) >> 208));\n      }\n    }\n\n    /* With every change to an offer, a maker may deduct provisions from its `balanceOf` balance. It may also get provisions back if the updated offer requires fewer provisions than before. */\n    {\n      uint provision = (ofp.gasreq +\n        uint(uint((ofp.local << 80)) >> 232) +\n        uint(uint((ofp.local << 56)) >> 232)) *\n        ofp.gasprice *\n        10**9;\n      if (provision > oldProvision) {\n        debitWei(msg.sender, provision - oldProvision);\n      } else if (provision < oldProvision) {\n        creditWei(msg.sender, oldProvision - provision);\n      }\n    }\n    /* We now place the offer in the book at the position found by `findPosition`. */\n\n    /* First, we test if the offer has moved in the book or is not currently in the book. If `!isLive(ofp.oldOffer)`, we must update its prev/next. If it is live but its prev has changed, we must also update them. Note that checking both `prev = oldPrev` and `next == oldNext` would be redundant. If either is true, then the updated offer has not changed position and there is nothing to update.\n\n    As a note for future changes, there is a tricky edge case where `prev == oldPrev` yet the prev/next should be changed: a previously-used offer being brought back in the book, and ending with the same prev it had when it was in the book. In that case, the neighbor is currently pointing to _another_ offer, and thus must be updated. With the current code structure, this is taken care of as a side-effect of checking `!isLive`, but should be kept in mind. The same goes in the `next == oldNext` case. */\n    if (!isLive(ofp.oldOffer) || prev != uint(uint((ofp.oldOffer << 0)) >> 232)) {\n      /* * If the offer is not the best one, we update its predecessor; otherwise we update the `best` value. */\n      if (prev != 0) {\n        offers[ofp.outbound_tkn][ofp.inbound_tkn][prev] = (offers[ofp.outbound_tkn][ofp.inbound_tkn][prev] & bytes32(0xffffff000000ffffffffffffffffffffffffffffffffffffffffffffffffffff) | bytes32((uint(ofp.id) << 232) >> 24));\n      } else {\n        ofp.local = (ofp.local & bytes32(0xffffffffffffffffffffffffffff000000ffffffffffffffffffffffffffffff) | bytes32((uint(ofp.id) << 232) >> 112));\n      }\n\n      /* * If the offer is not the last one, we update its successor. */\n      if (next != 0) {\n        offers[ofp.outbound_tkn][ofp.inbound_tkn][next] = (offers[ofp.outbound_tkn][ofp.inbound_tkn][next] & bytes32(0x000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) | bytes32((uint(ofp.id) << 232) >> 0));\n      }\n\n      /* * Recall that in this branch, the offer has changed location, or is not currently in the book. If the offer is not new and already in the book, we must remove it from its previous location by stitching its previous prev/next. */\n      if (update && isLive(ofp.oldOffer)) {\n        ofp.local = stitchOffers(\n          ofp.outbound_tkn,\n          ofp.inbound_tkn,\n          uint(uint((ofp.oldOffer << 0)) >> 232),\n          uint(uint((ofp.oldOffer << 24)) >> 232),\n          ofp.local\n        );\n      }\n    }\n\n    /* With the `prev`/`next` in hand, we finally store the offer in the `offers` map. */\n    bytes32 ofr = (((((bytes32(0) | bytes32((uint(prev) << 232) >> 0)) | bytes32((uint(next) << 232) >> 24)) | bytes32((uint(ofp.wants) << 160) >> 48)) | bytes32((uint(ofp.gives) << 160) >> 144)) | bytes32((uint(ofp.gasprice) << 240) >> 240));\n    offers[ofp.outbound_tkn][ofp.inbound_tkn][ofp.id] = ofr;\n  }\n\n  /* ## Find Position */\n  /* `findPosition` takes a price in the form of a (`ofp.wants`,`ofp.gives`) pair, an offer id (`ofp.pivotId`) and walks the book from that offer (backward or forward) until the right position for the price is found. The position is returned as a `(prev,next)` pair, with `prev` or `next` at 0 to mark the beginning/end of the book (no offer ever has id 0).\n\n  If prices are equal, `findPosition` will put the newest offer last. */\n  function findPosition(OfferPack memory ofp)\n    internal\n    view\n    returns (uint, uint)\n  {\n    uint prevId;\n    uint nextId;\n    uint pivotId = ofp.pivotId;\n    /* Get `pivot`, optimizing for the case where pivot info is already known */\n    bytes32 pivot = pivotId == ofp.id\n      ? ofp.oldOffer\n      : offers[ofp.outbound_tkn][ofp.inbound_tkn][pivotId];\n\n    /* In case pivotId is not an active offer, it is unusable (since it is out of the book). We default to the current best offer. If the book is empty pivot will be 0. That is handled through a test in the `better` comparison function. */\n    if (!isLive(pivot)) {\n      pivotId = uint(uint((ofp.local << 112)) >> 232);\n      pivot = offers[ofp.outbound_tkn][ofp.inbound_tkn][pivotId];\n    }\n\n    /* * Pivot is better than `wants/gives`, we follow `next`. */\n    if (better(ofp, pivot, pivotId)) {\n      bytes32 pivotNext;\n      while (uint(uint((pivot << 24)) >> 232) != 0) {\n        uint pivotNextId = uint(uint((pivot << 24)) >> 232);\n        pivotNext = offers[ofp.outbound_tkn][ofp.inbound_tkn][pivotNextId];\n        if (better(ofp, pivotNext, pivotNextId)) {\n          pivotId = pivotNextId;\n          pivot = pivotNext;\n        } else {\n          break;\n        }\n      }\n      // gets here on empty book\n      (prevId, nextId) = (pivotId, uint(uint((pivot << 24)) >> 232));\n\n      /* * Pivot is strictly worse than `wants/gives`, we follow `prev`. */\n    } else {\n      bytes32 pivotPrev;\n      while (uint(uint((pivot << 0)) >> 232) != 0) {\n        uint pivotPrevId = uint(uint((pivot << 0)) >> 232);\n        pivotPrev = offers[ofp.outbound_tkn][ofp.inbound_tkn][pivotPrevId];\n        if (better(ofp, pivotPrev, pivotPrevId)) {\n          break;\n        } else {\n          pivotId = pivotPrevId;\n          pivot = pivotPrev;\n        }\n      }\n\n      (prevId, nextId) = (uint(uint((pivot << 0)) >> 232), pivotId);\n    }\n\n    return (\n      prevId == ofp.id ? uint(uint((ofp.oldOffer << 0)) >> 232) : prevId,\n      nextId == ofp.id ? uint(uint((ofp.oldOffer << 24)) >> 232) : nextId\n    );\n  }\n\n  /* ## Better */\n  /* The utility method `better` takes an offer represented by `ofp` and another represented by `offer1`. It returns true iff `offer1` is better or as good as `ofp`.\n    \"better\" is defined on the lexicographic order $\\textrm{price} \\times_{\\textrm{lex}} \\textrm{density}^{-1}$. This means that for the same price, offers that deliver more volume per gas are taken first.\n\n      In addition to `offer1`, we also provide its id, `offerId1` in order to save gas. If necessary (ie. if the prices `wants1/gives1` and `wants2/gives2` are the same), we read storage to get `gasreq1` at `offerDetails[...][offerId1]. */\n  function better(\n    OfferPack memory ofp,\n    bytes32 offer1,\n    uint offerId1\n  ) internal view returns (bool) {\n    if (offerId1 == 0) {\n      /* Happens on empty book. Returning `false` would work as well due to specifics of `findPosition` but true is more consistent. Here we just want to avoid reading `offerDetail[...][0]` for nothing. */\n      return true;\n    }\n    uint wants1 = uint(uint((offer1 << 48)) >> 160);\n    uint gives1 = uint(uint((offer1 << 144)) >> 160);\n    uint wants2 = ofp.wants;\n    uint gives2 = ofp.gives;\n    uint weight1 = wants1 * gives2;\n    uint weight2 = wants2 * gives1;\n    if (weight1 == weight2) {\n      uint gasreq1 = uint(uint((offerDetails[ofp.outbound_tkn][ofp.inbound_tkn][offerId1] << 160)) >> 232);\n      uint gasreq2 = ofp.gasreq;\n      return (gives1 * gasreq2 >= gives2 * gasreq1);\n    } else {\n      return weight1 < weight2;\n    }\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/MgvOfferTakingWithPermit.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvOfferTakingWithPermit.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n\n\nimport {HasMgvEvents} from \"./MgvLib.sol\";\n\nimport {MgvOfferTaking} from \"./MgvOfferTaking.sol\";\n\nabstract contract MgvOfferTakingWithPermit is MgvOfferTaking {\n  /* Takers may provide allowances on specific pairs, so other addresses can execute orders in their name. Allowance may be set using the usual `approve` function, or through an [EIP712](https://eips.ethereum.org/EIPS/eip-712) `permit`.\n\n  The mapping is `outbound_tkn => inbound_tkn => owner => spender => allowance` */\n  mapping(address => mapping(address => mapping(address => mapping(address => uint))))\n    public allowances;\n  /* Storing nonces avoids replay attacks. */\n  mapping(address => uint) public nonces;\n  /* Following [EIP712](https://eips.ethereum.org/EIPS/eip-712), structured data signing has `keccak256(\"Permit(address outbound_tkn,address inbound_tkn,address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")` in its prefix. */\n  bytes32 public constant PERMIT_TYPEHASH =\n    0xb7bf278e51ab1478b10530c0300f911d9ed3562fc93ab5e6593368fe23c077a2;\n  /* Initialized in the constructor, `DOMAIN_SEPARATOR` avoids cross-application permit reuse. */\n  bytes32 public immutable DOMAIN_SEPARATOR;\n\n  constructor(string memory contractName) {\n    /* Initialize [EIP712](https://eips.ethereum.org/EIPS/eip-712) `DOMAIN_SEPARATOR`. */\n    uint chainId;\n    assembly {\n      chainId := chainid()\n    }\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(contractName)),\n        keccak256(bytes(\"1\")),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  /* # Delegation public functions */\n\n  /* Adapted from [Uniswap v2 contract](https://github.com/Uniswap/uniswap-v2-core/blob/55ae25109b7918565867e5c39f1e84b7edd19b2a/contracts/UniswapV2ERC20.sol#L81) */\n  function permit(\n    address outbound_tkn,\n    address inbound_tkn,\n    address owner,\n    address spender,\n    uint value,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    require(deadline >= block.timestamp, \"mgv/permit/expired\");\n\n    uint nonce = nonces[owner]++;\n    bytes32 digest = keccak256(\n      abi.encodePacked(\n        \"\\x19\\x01\",\n        DOMAIN_SEPARATOR,\n        keccak256(\n          abi.encode(\n            PERMIT_TYPEHASH,\n            outbound_tkn,\n            inbound_tkn,\n            owner,\n            spender,\n            value,\n            nonce,\n            deadline\n          )\n        )\n      )\n    );\n    address recoveredAddress = ecrecover(digest, v, r, s);\n    require(\n      recoveredAddress != address(0) && recoveredAddress == owner,\n      \"mgv/permit/invalidSignature\"\n    );\n\n    allowances[outbound_tkn][inbound_tkn][owner][spender] = value;\n    emit Approval(outbound_tkn, inbound_tkn, owner, spender, value);\n  }\n\n  function approve(\n    address outbound_tkn,\n    address inbound_tkn,\n    address spender,\n    uint value\n  ) external returns (bool) {\n    allowances[outbound_tkn][inbound_tkn][msg.sender][spender] = value;\n    emit Approval(outbound_tkn, inbound_tkn, msg.sender, spender, value);\n    return true;\n  }\n\n  /* The delegate version of `marketOrder` is `marketOrderFor`, which takes a `taker` address as additional argument. Penalties incurred by failed offers will still be sent to `msg.sender`, but exchanged amounts will be transferred from and to the `taker`. If the `msg.sender`'s allowance for the given `outbound_tkn`,`inbound_tkn` and `taker` are strictly less than the total amount eventually spent by `taker`, the call will fail. */\n\n  /* *Note:* `marketOrderFor` and `snipesFor` may emit ERC20 `Transfer` events of value 0 from `taker`, but that's already the case with common ERC20 implementations. */\n  function marketOrderFor(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint takerWants,\n    uint takerGives,\n    bool fillWants,\n    address taker\n  ) external returns (uint takerGot, uint takerGave) {\n    (takerGot, takerGave) = generalMarketOrder(\n      outbound_tkn,\n      inbound_tkn,\n      takerWants,\n      takerGives,\n      fillWants,\n      taker\n    );\n    deductSenderAllowance(outbound_tkn, inbound_tkn, taker, takerGave);\n  }\n\n  /* The delegate version of `snipes` is `snipesFor`, which takes a `taker` address as additional argument. */\n  function snipesFor(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint[4][] calldata targets,\n    bool fillWants,\n    address taker\n  )\n    external\n    returns (\n      uint successes,\n      uint takerGot,\n      uint takerGave\n    )\n  {\n    (successes, takerGot, takerGave) = generalSnipes(\n      outbound_tkn,\n      inbound_tkn,\n      targets,\n      fillWants,\n      taker\n    );\n    deductSenderAllowance(outbound_tkn, inbound_tkn, taker, takerGave);\n  }\n\n  /* # Misc. low-level functions */\n\n  /* Used by `*For` functions, its both checks that `msg.sender` was allowed to use the taker's funds, and decreases the former's allowance. */\n  function deductSenderAllowance(\n    address outbound_tkn,\n    address inbound_tkn,\n    address owner,\n    uint amount\n  ) internal {\n    uint allowed = allowances[outbound_tkn][inbound_tkn][owner][msg.sender];\n    require(allowed >= amount, \"mgv/lowAllowance\");\n    allowances[outbound_tkn][inbound_tkn][owner][msg.sender] = allowed - amount;\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/MgvGovernable.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvGovernable.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n\nimport {HasMgvEvents} from \"./MgvLib.sol\";\nimport {MgvRoot} from \"./MgvRoot.sol\";\n\ncontract MgvGovernable is MgvRoot {\n  /* The `governance` address. Governance is the only address that can configure parameters. */\n  address public governance;\n\n  constructor(\n    address _governance,\n    uint _gasprice,\n    uint gasmax\n  ) MgvRoot() {\n    emit NewMgv();\n\n    /* Initially, governance is open to anyone. */\n\n    /* Initialize vault to governance address, and set initial gasprice and gasmax. */\n    setVault(_governance);\n    setGasprice(_gasprice);\n    setGasmax(gasmax);\n    /* Initialize governance to `_governance` after parameter setting. */\n    setGovernance(_governance);\n  }\n\n  /* ## `authOnly` check */\n\n  function authOnly() internal view {\n    require(\n      msg.sender == governance ||\n        msg.sender == address(this) ||\n        governance == address(0),\n      \"mgv/unauthorized\"\n    );\n  }\n\n  /* # Set configuration and Mangrove state */\n\n  /* ## Locals */\n  /* ### `active` */\n  function activate(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint fee,\n    uint density,\n    uint overhead_gasbase,\n    uint offer_gasbase\n  ) public {\n    authOnly();\n    locals[outbound_tkn][inbound_tkn] = (locals[outbound_tkn][inbound_tkn] & bytes32(0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) | bytes32((uint(1) << 248) >> 0));\n    emit SetActive(outbound_tkn, inbound_tkn, true);\n    setFee(outbound_tkn, inbound_tkn, fee);\n    setDensity(outbound_tkn, inbound_tkn, density);\n    setGasbase(outbound_tkn, inbound_tkn, overhead_gasbase, offer_gasbase);\n  }\n\n  function deactivate(address outbound_tkn, address inbound_tkn) public {\n    authOnly();\n    locals[outbound_tkn][inbound_tkn] = (locals[outbound_tkn][inbound_tkn] & bytes32(0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) | bytes32((uint(0) << 248) >> 0));\n    emit SetActive(outbound_tkn, inbound_tkn, false);\n  }\n\n  /* ### `fee` */\n  function setFee(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint fee\n  ) public {\n    authOnly();\n    /* `fee` is in basis points, i.e. in percents of a percent. */\n    require(fee <= 500, \"mgv/config/fee/<=500\"); // at most 5%\n    locals[outbound_tkn][inbound_tkn] = (locals[outbound_tkn][inbound_tkn] & bytes32(0xff0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) | bytes32((uint(fee) << 240) >> 8));\n    emit SetFee(outbound_tkn, inbound_tkn, fee);\n  }\n\n  /* ### `density` */\n  /* Useless if `global.useOracle != 0` */\n  function setDensity(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint density\n  ) public {\n    authOnly();\n\n    require(checkDensity(density), \"mgv/config/density/32bits\");\n    //+clear+\n    locals[outbound_tkn][inbound_tkn] = (locals[outbound_tkn][inbound_tkn] & bytes32(0xffffff00000000ffffffffffffffffffffffffffffffffffffffffffffffffff) | bytes32((uint(density) << 224) >> 24));\n    emit SetDensity(outbound_tkn, inbound_tkn, density);\n  }\n\n  /* ### `gasbase` */\n  function setGasbase(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint overhead_gasbase,\n    uint offer_gasbase\n  ) public {\n    authOnly();\n    /* Checking the size of `*_gasbase` is necessary to prevent a) data loss when `*_gasbase` is copied to an `OfferDetail` struct, and b) overflow when `*_gasbase` is used in calculations. */\n    require(\n      uint24(overhead_gasbase) == overhead_gasbase,\n      \"mgv/config/overhead_gasbase/24bits\"\n    );\n    require(\n      uint24(offer_gasbase) == offer_gasbase,\n      \"mgv/config/offer_gasbase/24bits\"\n    );\n    //+clear+\n    locals[outbound_tkn][inbound_tkn] = ((locals[outbound_tkn][inbound_tkn] & bytes32(0xffffffffffffffffffff000000ffffffffffffffffffffffffffffffffffffff) | bytes32((uint(offer_gasbase) << 232) >> 80)) & bytes32(0xffffffffffffff000000ffffffffffffffffffffffffffffffffffffffffffff) | bytes32((uint(overhead_gasbase) << 232) >> 56));\n    emit SetGasbase(outbound_tkn, inbound_tkn, overhead_gasbase, offer_gasbase);\n  }\n\n  /* ## Globals */\n  /* ### `kill` */\n  function kill() public {\n    authOnly();\n    global = (global & bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffffffffff00ffffffff) | bytes32((uint(1) << 248) >> 216));\n    emit Kill();\n  }\n\n  /* ### `gasprice` */\n  /* Useless if `global.useOracle is != 0` */\n  function setGasprice(uint gasprice) public {\n    authOnly();\n    require(checkGasprice(gasprice), \"mgv/config/gasprice/16bits\");\n\n    //+clear+\n\n    global = (global & bytes32(0xffffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffff) | bytes32((uint(gasprice) << 240) >> 176));\n    emit SetGasprice(gasprice);\n  }\n\n  /* ### `gasmax` */\n  function setGasmax(uint gasmax) public {\n    authOnly();\n    /* Since any new `gasreq` is bounded above by `config.gasmax`, this check implies that all offers' `gasreq` is 24 bits wide at most. */\n    require(uint24(gasmax) == gasmax, \"mgv/config/gasmax/24bits\");\n    //+clear+\n    global = (global & bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffff000000ffffffffff) | bytes32((uint(gasmax) << 232) >> 192));\n    emit SetGasmax(gasmax);\n  }\n\n  /* ### `governance` */\n  function setGovernance(address governanceAddress) public {\n    authOnly();\n    governance = governanceAddress;\n    emit SetGovernance(governanceAddress);\n  }\n\n  /* ### `vault` */\n  function setVault(address vaultAddress) public {\n    authOnly();\n    vault = vaultAddress;\n    emit SetVault(vaultAddress);\n  }\n\n  /* ### `monitor` */\n  function setMonitor(address monitor) public {\n    authOnly();\n    global = (global & bytes32(0x0000000000000000000000000000000000000000ffffffffffffffffffffffff) | bytes32((uint(monitor) << 96) >> 0));\n    emit SetMonitor(monitor);\n  }\n\n  /* ### `useOracle` */\n  function setUseOracle(bool useOracle) public {\n    authOnly();\n    uint _useOracle = useOracle ? 1 : 0;\n    global = (global & bytes32(0xffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffffff) | bytes32((uint(_useOracle) << 248) >> 160));\n    emit SetUseOracle(useOracle);\n  }\n\n  /* ### `notify` */\n  function setNotify(bool notify) public {\n    authOnly();\n    uint _notify = notify ? 1 : 0;\n    global = (global & bytes32(0xffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffff) | bytes32((uint(_notify) << 248) >> 168));\n    emit SetNotify(notify);\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/MgvHasOffers.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvHasOffers.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n\nimport {MgvLib as ML, HasMgvEvents, IMgvMonitor} from \"./MgvLib.sol\";\nimport {MgvRoot} from \"./MgvRoot.sol\";\n\n/* `MgvHasOffers` contains the state variables and functions common to both market-maker operations and market-taker operations. Mostly: storing offers, removing them, updating market makers' provisions. */\ncontract MgvHasOffers is MgvRoot {\n  /* # State variables */\n  /* Given a `outbound_tkn`,`inbound_tkn` pair, the mappings `offers` and `offerDetails` associate two 256 bits words to each offer id. Those words encode information detailed in [`structs.js`](#structs.js).\n\n     The mappings are `outbound_tkn => inbound_tkn => offerId => bytes32`.\n   */\n  mapping(address => mapping(address => mapping(uint => bytes32)))\n    public offers;\n  mapping(address => mapping(address => mapping(uint => bytes32)))\n    public offerDetails;\n\n  /* Makers provision their possible penalties in the `balanceOf` mapping.\n\n       Offers specify the amount of gas they require for successful execution ([`gasreq`](#structs.js/gasreq)). To minimize book spamming, market makers must provision a *penalty*, which depends on their `gasreq` and on the pair's [`*_gasbase`](#structs.js/gasbase). This provision is deducted from their `balanceOf`. If an offer fails, part of that provision is given to the taker, as retribution. The exact amount depends on the gas used by the offer before failing.\n\n       The Mangrove keeps track of their available balance in the `balanceOf` map, which is decremented every time a maker creates a new offer, and may be modified on offer updates/cancelations/takings.\n     */\n  mapping(address => uint) public balanceOf;\n\n  /* # Read functions */\n  /* Convenience function to get best offer of the given pair */\n  function best(address outbound_tkn, address inbound_tkn)\n    external\n    view\n    returns (uint)\n  {\n    bytes32 local = locals[outbound_tkn][inbound_tkn];\n    return uint(uint((local << 112)) >> 232);\n  }\n\n  /* Returns information about an offer in ABI-compatible structs. Do not use internally, would be a huge memory-copying waste. Use `offers[outbound_tkn][inbound_tkn]` and `offerDetails[outbound_tkn][inbound_tkn]` instead. */\n  function offerInfo(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId\n  ) external view returns (ML.Offer memory, ML.OfferDetail memory) {\n    bytes32 offer = offers[outbound_tkn][inbound_tkn][offerId];\n    ML.Offer memory offerStruct = ML.Offer({\n      prev: uint(uint((offer << 0)) >> 232),\n      next: uint(uint((offer << 24)) >> 232),\n      wants: uint(uint((offer << 48)) >> 160),\n      gives: uint(uint((offer << 144)) >> 160),\n      gasprice: uint(uint((offer << 240)) >> 240)\n    });\n\n    bytes32 offerDetail = offerDetails[outbound_tkn][inbound_tkn][offerId];\n\n    ML.OfferDetail memory offerDetailStruct = ML.OfferDetail({\n      maker: address(uint((offerDetail << 0)) >> 96),\n      gasreq: uint(uint((offerDetail << 160)) >> 232),\n      overhead_gasbase: uint(uint((offerDetail << 184)) >> 232),\n      offer_gasbase: uint(uint((offerDetail << 208)) >> 232)\n    });\n    return (offerStruct, offerDetailStruct);\n  }\n\n  /* # Provision debit/credit utility functions */\n  /* `balanceOf` is in wei of ETH. */\n\n  function debitWei(address maker, uint amount) internal {\n    uint makerBalance = balanceOf[maker];\n    require(makerBalance >= amount, \"mgv/insufficientProvision\");\n    balanceOf[maker] = makerBalance - amount;\n    emit Debit(maker, amount);\n  }\n\n  function creditWei(address maker, uint amount) internal {\n    balanceOf[maker] += amount;\n    emit Credit(maker, amount);\n  }\n\n  /* # Misc. low-level functions */\n  /* ## Offer deletion */\n\n  /* When an offer is deleted, it is marked as such by setting `gives` to 0. Note that provision accounting in the Mangrove aims to minimize writes. Each maker `fund`s the Mangrove to increase its balance. When an offer is created/updated, we compute how much should be reserved to pay for possible penalties. That amount can always be recomputed with `offer.gasprice * (offerDetail.gasreq + offerDetail.overhead_gasbase + offerDetail.offer_gasbase)`. The balance is updated to reflect the remaining available ethers.\n\n     Now, when an offer is deleted, the offer can stay provisioned, or be `deprovision`ed. In the latter case, we set `gasprice` to 0, which induces a provision of 0. All code calling `dirtyDeleteOffer` with `deprovision` set to `true` must be careful to correctly account for where that provision is going (back to the maker's `balanceOf`, or sent to a taker as compensation). */\n  function dirtyDeleteOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId,\n    bytes32 offer,\n    bool deprovision\n  ) internal {\n    offer = (offer & bytes32(0xffffffffffffffffffffffffffffffffffff000000000000000000000000ffff) | bytes32((uint(0) << 160) >> 144));\n    if (deprovision) {\n      offer = (offer & bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000) | bytes32((uint(0) << 240) >> 240));\n    }\n    offers[outbound_tkn][inbound_tkn][offerId] = offer;\n  }\n\n  /* ## Stitching the orderbook */\n\n  /* Connect the offers `betterId` and `worseId` through their `next`/`prev` pointers. For more on the book structure, see [`structs.js`](#structs.js). Used after executing an offer (or a segment of offers), after removing an offer, or moving an offer.\n\n  **Warning**: calling with `betterId = 0` will set `worseId` as the best. So with `betterId = 0` and `worseId = 0`, it sets the book to empty and loses track of existing offers.\n\n  **Warning**: may make memory copy of `local.best` stale. Returns new `local`. */\n  function stitchOffers(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint betterId,\n    uint worseId,\n    bytes32 local\n  ) internal returns (bytes32) {\n    if (betterId != 0) {\n      offers[outbound_tkn][inbound_tkn][betterId] = (offers[outbound_tkn][inbound_tkn][betterId] & bytes32(0xffffff000000ffffffffffffffffffffffffffffffffffffffffffffffffffff) | bytes32((uint(worseId) << 232) >> 24));\n    } else {\n      local = (local & bytes32(0xffffffffffffffffffffffffffff000000ffffffffffffffffffffffffffffff) | bytes32((uint(worseId) << 232) >> 112));\n    }\n\n    if (worseId != 0) {\n      offers[outbound_tkn][inbound_tkn][worseId] = (offers[outbound_tkn][inbound_tkn][worseId] & bytes32(0x000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) | bytes32((uint(betterId) << 232) >> 0));\n    }\n\n    return local;\n  }\n\n  /* ## Check offer is live */\n  /* Check whether an offer is 'live', that is: inserted in the order book. The Mangrove holds a `outbound_tkn => inbound_tkn => id => bytes32` mapping in storage. Offer ids that are not yet assigned or that point to since-deleted offer will point to an offer with `gives` field at 0. */\n  function isLive(bytes32 offer) public pure returns (bool) {\n    return uint(uint((offer << 144)) >> 160) > 0;\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/MgvRoot.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvRoot.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* `MgvRoot` and its descendants describe an orderbook-based exchange (\"the Mangrove\") where market makers *do not have to provision their offer*. See `structs.js` for a longer introduction. In a nutshell: each offer created by a maker specifies an address (`maker`) to call upon offer execution by a taker. In the normal mode of operation, the Mangrove transfers the amount to be paid by the taker to the maker, calls the maker, attempts to transfer the amount promised by the maker to the taker, and reverts if it cannot.\n\n   There is one Mangrove contract that manages all tradeable pairs. This reduces deployment costs for new pairs and lets market makers have all their provision for all pairs in the same place.\n\n   The interaction map between the different actors is as follows:\n   <img src=\"./contactMap.png\" width=\"190%\"></img>\n\n   The sequence diagram of a market order is as follows:\n   <img src=\"./sequenceChart.png\" width=\"190%\"></img>\n\n   There is a secondary mode of operation in which the _maker_ flashloans the sold amount to the taker.\n\n   The Mangrove contract is `abstract` and accomodates both modes. Two contracts, `Mangrove` and `InvertedMangrove` inherit from it, one per mode of operation.\n\n   The contract structure is as follows:\n   <img src=\"./modular_mangrove.svg\" width=\"180%\"> </img>\n */\n\n\n\nimport {MgvLib as ML, HasMgvEvents, IMgvMonitor} from \"./MgvLib.sol\";\n\n/* `MgvRoot` contains state variables used everywhere in the operation of the Mangrove and their related function. */\ncontract MgvRoot is HasMgvEvents {\n  /* # State variables */\n  //+clear+\n  /* The `vault` address. If a pair has fees >0, those fees are sent to the vault. */\n  address public vault;\n\n  /* Global mgv configuration, encoded in a 256 bits word. The information encoded is detailed in [`structs.js`](#structs.js). */\n  bytes32 internal global;\n  /* Configuration mapping for each token pair of the form `outbound_tkn => inbound_tkn => bytes32`. The structure of each `bytes32` value is detailed in [`structs.js`](#structs.js). */\n  mapping(address => mapping(address => bytes32)) internal locals;\n\n  /* Checking the size of `density` is necessary to prevent overflow when `density` is used in calculations. */\n  function checkDensity(uint density) internal pure returns (bool) {\n    return uint32(density) == density;\n  }\n\n  /* Checking the size of `gasprice` is necessary to prevent a) data loss when `gasprice` is copied to an `OfferDetail` struct, and b) overflow when `gasprice` is used in calculations. */\n  function checkGasprice(uint gasprice) internal pure returns (bool) {\n    return uint16(gasprice) == gasprice;\n  }\n\n  /* # Configuration Reads */\n  /* Reading the configuration for a pair involves reading the config global to all pairs and the local one. In addition, a global parameter (`gasprice`) and a local one (`density`) may be read from the oracle. */\n  function config(address outbound_tkn, address inbound_tkn)\n    public\n    view\n    returns (bytes32 _global, bytes32 _local)\n  {\n    _global = global;\n    _local = locals[outbound_tkn][inbound_tkn];\n    if (uint(uint((_global << 160)) >> 248) > 0) {\n      (uint gasprice, uint density) = IMgvMonitor(address(uint((_global << 0)) >> 96))\n        .read(outbound_tkn, inbound_tkn);\n      if (checkGasprice(gasprice)) {\n        _global = (_global & bytes32(0xffffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffff) | bytes32((uint(gasprice) << 240) >> 176));\n      }\n      if (checkDensity(density)) {\n        _local = (_local & bytes32(0xffffff00000000ffffffffffffffffffffffffffffffffffffffffffffffffff) | bytes32((uint(density) << 224) >> 24));\n      }\n    }\n  }\n\n  /* Convenience function to check whether given pair is locked */\n  function locked(address outbound_tkn, address inbound_tkn)\n    external\n    view\n    returns (bool)\n  {\n    bytes32 local = locals[outbound_tkn][inbound_tkn];\n    return uint(uint((local << 104)) >> 248) > 0;\n  }\n\n  /*\n  # Gatekeeping\n\n  Gatekeeping functions are safety checks called in various places.\n  */\n\n  /* `unlockedMarketOnly` protects modifying the market while an order is in progress. Since external contracts are called during orders, allowing reentrancy would, for instance, let a market maker replace offers currently on the book with worse ones. Note that the external contracts _will_ be called again after the order is complete, this time without any lock on the market.  */\n  function unlockedMarketOnly(bytes32 local) internal pure {\n    require(uint(uint((local << 104)) >> 248) == 0, \"mgv/reentrancyLocked\");\n  }\n\n  /* <a id=\"Mangrove/definition/liveMgvOnly\"></a>\n     In case of emergency, the Mangrove can be `kill`ed. It cannot be resurrected. When a Mangrove is dead, the following operations are disabled :\n       * Executing an offer\n       * Sending ETH to the Mangrove the normal way. Usual [shenanigans](https://medium.com/@alexsherbuck/two-ways-to-force-ether-into-a-contract-1543c1311c56) are possible.\n       * Creating a new offer\n   */\n  function liveMgvOnly(bytes32 _global) internal pure {\n    require(uint(uint((_global << 216)) >> 248) == 0, \"mgv/dead\");\n  }\n\n  /* When the Mangrove is deployed, all pairs are inactive by default (since `locals[outbound_tkn][inbound_tkn]` is 0 by default). Offers on inactive pairs cannot be taken or created. They can be updated and retracted. */\n  function activeMarketOnly(bytes32 _global, bytes32 _local) internal pure {\n    liveMgvOnly(_global);\n    require(uint(uint((_local << 0)) >> 248) > 0, \"mgv/inactive\");\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/MgvOfferTaking.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvOfferTaking.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n\nimport {IERC20, HasMgvEvents, IMaker, IMgvMonitor, MgvLib as ML} from \"./MgvLib.sol\";\nimport {MgvHasOffers} from \"./MgvHasOffers.sol\";\n\nabstract contract MgvOfferTaking is MgvHasOffers {\n  /* # MultiOrder struct */\n  /* The `MultiOrder` struct is used by market orders and snipes. Some of its fields are only used by market orders (`initialWants, initialGives`, `fillWants`), and others only by snipes (`successCount`). We need a common data structure for both since low-level calls are shared between market orders and snipes. The struct is helpful in decreasing stack use. */\n  struct MultiOrder {\n    uint initialWants;\n    uint initialGives;\n    uint totalGot;\n    uint totalGave;\n    uint totalPenalty;\n    address taker;\n    uint successCount;\n    uint failCount;\n    bool fillWants;\n  }\n\n  /* # Market Orders */\n\n  /* ## Market Order */\n  //+clear+\n\n  /* A market order specifies a (`outbound_tkn`,`inbound_tkn`) pair, a desired total amount of `outbound_tkn` (`takerWants`), and an available total amount of `inbound_tkn` (`takerGives`). It returns two `uint`s: the total amount of `outbound_tkn` received and the total amount of `inbound_tkn` spent.\n\n     The `takerGives/takerWants` ratio induces a maximum average price that the taker is ready to pay across all offers that will be executed during the market order. It is thus possible to execute an offer with a price worse than the initial (`takerGives`/`takerWants`) ratio given as argument to `marketOrder` if some cheaper offers were executed earlier in the market order.\n\n  The market order stops when the price has become too high, or when the end of the book has been reached, or:\n  * If `fillWants` is true, the market order stops when `takerWants` units of `outbound_tkn` have been obtained. With `fillWants` set to true, to buy a specific volume of `outbound_tkn` at any price, set `takerWants` to the amount desired and `takerGives` to $2^{160}-1$.\n  * If `fillWants` is false, the taker is filling `gives` instead: the market order stops when `takerGives` units of `inbound_tkn` have been sold. With `fillWants` set to false, to sell a specific volume of `inbound_tkn` at any price, set `takerGives` to the amount desired and `takerWants` to $0$. */\n  function marketOrder(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint takerWants,\n    uint takerGives,\n    bool fillWants\n  ) external returns (uint, uint) {\n    return\n      generalMarketOrder(\n        outbound_tkn,\n        inbound_tkn,\n        takerWants,\n        takerGives,\n        fillWants,\n        msg.sender\n      );\n  }\n\n  /* # General Market Order */\n  //+clear+\n  /* General market orders set up the market order with a given `taker` (`msg.sender` in the most common case). Returns `(totalGot, totalGave)`.\n  Note that the `taker` can be anyone. This is safe when `taker == msg.sender`, but `generalMarketOrder` must not be called with `taker != msg.sender` unless a security check is done after (see [`MgvOfferTakingWithPermit`](#mgvoffertakingwithpermit.sol)`. */\n  function generalMarketOrder(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint takerWants,\n    uint takerGives,\n    bool fillWants,\n    address taker\n  ) internal returns (uint, uint) {\n    /* Since amounts stored in offers are 96 bits wide, checking that `takerWants` and `takerGives` fit in 160 bits prevents overflow during the main market order loop. */\n    require(uint160(takerWants) == takerWants, \"mgv/mOrder/takerWants/160bits\");\n    require(uint160(takerGives) == takerGives, \"mgv/mOrder/takerGives/160bits\");\n\n    /* `SingleOrder` is defined in `MgvLib.sol` and holds information for ordering the execution of one offer. */\n    ML.SingleOrder memory sor;\n    sor.outbound_tkn = outbound_tkn;\n    sor.inbound_tkn = inbound_tkn;\n    (sor.global, sor.local) = config(outbound_tkn, inbound_tkn);\n    /* Throughout the execution of the market order, the `sor`'s offer id and other parameters will change. We start with the current best offer id (0 if the book is empty). */\n    sor.offerId = uint(uint((sor.local << 112)) >> 232);\n    sor.offer = offers[outbound_tkn][inbound_tkn][sor.offerId];\n    /* `sor.wants` and `sor.gives` may evolve, but they are initially however much remains in the market order. */\n    sor.wants = takerWants;\n    sor.gives = takerGives;\n\n    /* `MultiOrder` (defined above) maintains information related to the entire market order. During the order, initial `wants`/`gives` values minus the accumulated amounts traded so far give the amounts that remain to be traded. */\n    MultiOrder memory mor;\n    mor.initialWants = takerWants;\n    mor.initialGives = takerGives;\n    mor.taker = taker;\n    mor.fillWants = fillWants;\n\n    /* For the market order to even start, the market needs to be both active, and not currently protected from reentrancy. */\n    activeMarketOnly(sor.global, sor.local);\n    unlockedMarketOnly(sor.local);\n\n    /* ### Initialization */\n    /* The market order will operate as follows : it will go through offers from best to worse, starting from `offerId`, and: */\n    /* * will maintain remaining `takerWants` and `takerGives` values. The initial `takerGives/takerWants` ratio is the average price the taker will accept. Better prices may be found early in the book, and worse ones later.\n     * will not set `prev`/`next` pointers to their correct locations at each offer taken (this is an optimization enabled by forbidding reentrancy).\n     * after consuming a segment of offers, will update the current `best` offer to be the best remaining offer on the book. */\n\n    /* We start be enabling the reentrancy lock for this (`outbound_tkn`,`inbound_tkn`) pair. */\n    sor.local = (sor.local & bytes32(0xffffffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffff) | bytes32((uint(1) << 248) >> 104));\n    locals[outbound_tkn][inbound_tkn] = sor.local;\n\n    /* Call recursive `internalMarketOrder` function.*/\n    internalMarketOrder(mor, sor, true);\n\n    /* Over the course of the market order, a penalty reserved for `msg.sender` has accumulated in `mor.totalPenalty`. No actual transfers have occured yet -- all the ethers given by the makers as provision are owned by the Mangrove. `sendPenalty` finally gives the accumulated penalty to `msg.sender`. */\n    sendPenalty(mor.totalPenalty);\n\n    emit OrderComplete(\n      outbound_tkn,\n      inbound_tkn,\n      taker,\n      mor.totalGot,\n      mor.totalGave\n    );\n\n    //+clear+\n    return (mor.totalGot, mor.totalGave);\n  }\n\n  /* ## Internal market order */\n  //+clear+\n  /* `internalMarketOrder` works recursively. Going downward, each successive offer is executed until the market order stops (due to: volume exhausted, bad price, or empty book). Then the [reentrancy lock is lifted](#internalMarketOrder/liftReentrancy). Going upward, each offer's `maker` contract is called again with its remaining gas and given the chance to update its offers on the book.\n\n    The last argument is a boolean named `proceed`. If an offer was not executed, it means the price has become too high. In that case, we notify the next recursive call that the market order should end. In this initial call, no offer has been executed yet so `proceed` is true. */\n  function internalMarketOrder(\n    MultiOrder memory mor,\n    ML.SingleOrder memory sor,\n    bool proceed\n  ) internal {\n    /* #### Case 1 : End of order */\n    /* We execute the offer currently stored in `sor`. */\n    if (\n      proceed &&\n      (mor.fillWants ? sor.wants > 0 : sor.gives > 0) &&\n      sor.offerId > 0\n    ) {\n      uint gasused; // gas used by `makerExecute`\n      bytes32 makerData; // data returned by maker\n\n      /* <a id=\"MgvOfferTaking/statusCodes\"></a> `mgvData` is an internal Mangrove status code. It may appear in an [`OrderResult`](#MgvLib/OrderResult). Its possible values are:\n      * `\"mgv/notExecuted\"`: offer was not executed.\n      * `\"mgv/tradeSuccess\"`: offer execution succeeded. Will appear in `OrderResult`.\n      * `\"mgv/notEnoughGasForMakerTrade\"`: cannot give maker close enough to `gasreq`. Triggers a revert of the entire order.\n      * `\"mgv/makerRevert\"`: execution of `makerExecute` reverted. Will appear in `OrderResult`.\n      * `\"mgv/makerAbort\"`: execution of `makerExecute` returned normally, but returndata did not start with 32 bytes of 0s. Will appear in `OrderResult`.\n      * `\"mgv/makerTransferFail\"`: maker could not send outbound_tkn tokens. Will appear in `OrderResult`.\n      * `\"mgv/makerReceiveFail\"`: maker could not receive inbound_tkn tokens. Will appear in `OrderResult`.\n      * `\"mgv/takerTransferFail\"`: taker could not send inbound_tkn tokens. Triggers a revert of the entire order.\n\n      `mgvData` should not be exploitable by the maker! */\n      bytes32 mgvData;\n\n      /* Load additional information about the offer. We don't do it earlier to save one storage read in case `proceed` was false. */\n      sor.offerDetail = offerDetails[sor.outbound_tkn][sor.inbound_tkn][\n        sor.offerId\n      ];\n\n      /* `execute` will adjust `sor.wants`,`sor.gives`, and may attempt to execute the offer if its price is low enough. It is crucial that an error due to `taker` triggers a revert. That way, [`mgvData`](#MgvOfferTaking/statusCodes) not in `[\"mgv/notExecuted\",\"mgv/tradeSuccess\"]` means the failure is the maker's fault. */\n      /* Post-execution, `sor.wants`/`sor.gives` reflect how much was sent/taken by the offer. We will need it after the recursive call, so we save it in local variables. Same goes for `offerId`, `sor.offer` and `sor.offerDetail`. */\n\n      (gasused, makerData, mgvData) = execute(mor, sor);\n\n      /* Keep cached copy of current `sor` values. */\n      uint takerWants = sor.wants;\n      uint takerGives = sor.gives;\n      uint offerId = sor.offerId;\n      bytes32 offer = sor.offer;\n      bytes32 offerDetail = sor.offerDetail;\n\n      /* If an execution was attempted, we move `sor` to the next offer. Note that the current state is inconsistent, since we have not yet updated `sor.offerDetails`. */\n      if (mgvData != \"mgv/notExecuted\") {\n        sor.wants = mor.initialWants > mor.totalGot\n          ? mor.initialWants - mor.totalGot\n          : 0;\n        /* It is known statically that `mor.initialGives - mor.totalGave` does not underflow since\n           1. `mor.totalGave` was increased by `sor.gives` during `execute`,\n           2. `sor.gives` was at most `mor.initialGives - mor.totalGave` from earlier step,\n           3. `sor.gives` may have been clamped _down_ during `execute` (to \"`offer.wants`\" if the offer is entirely consumed, or to `makerWouldWant`, cf. code of `execute`).\n        */\n        sor.gives = mor.initialGives - mor.totalGave;\n        sor.offerId = uint(uint((sor.offer << 24)) >> 232);\n        sor.offer = offers[sor.outbound_tkn][sor.inbound_tkn][sor.offerId];\n      }\n\n      /* note that internalMarketOrder may be called twice with same offerId, but in that case `proceed` will be false! */\n      internalMarketOrder(\n        mor,\n        sor,\n        /* `proceed` value for next call. Currently, when an offer did not execute, it's because the offer's price was too high. In that case we interrupt the loop and let the taker leave with less than they asked for (but at a correct price). We could also revert instead of breaking; this could be a configurable flag for the taker to pick. */\n        mgvData != \"mgv/notExecuted\"\n      );\n\n      /* Restore `sor` values from to before recursive call */\n      sor.offerId = offerId;\n      sor.wants = takerWants;\n      sor.gives = takerGives;\n      sor.offer = offer;\n      sor.offerDetail = offerDetail;\n\n      /* After an offer execution, we may run callbacks and increase the total penalty. As that part is common to market orders and snipes, it lives in its own `postExecute` function. */\n      if (mgvData != \"mgv/notExecuted\") {\n        postExecute(mor, sor, gasused, makerData, mgvData);\n      }\n\n      /* #### Case 2 : End of market order */\n      /* If `proceed` is false, the taker has gotten its requested volume, or we have reached the end of the book, we conclude the market order. */\n    } else {\n      /* During the market order, all executed offers have been removed from the book. We end by stitching together the `best` offer pointer and the new best offer. */\n      sor.local = stitchOffers(\n        sor.outbound_tkn,\n        sor.inbound_tkn,\n        0,\n        sor.offerId,\n        sor.local\n      );\n      /* <a id=\"internalMarketOrder/liftReentrancy\"></a>Now that the market order is over, we can lift the lock on the book. In the same operation we\n\n      * lift the reentrancy lock, and\n      * update the storage\n\n      so we are free from out of order storage writes.\n      */\n      sor.local = (sor.local & bytes32(0xffffffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffff) | bytes32((uint(0) << 248) >> 104));\n      locals[sor.outbound_tkn][sor.inbound_tkn] = sor.local;\n\n      /* `payTakerMinusFees` sends the fee to the vault, proportional to the amount purchased, and gives the rest to the taker */\n      payTakerMinusFees(mor, sor);\n\n      /* In an inverted Mangrove, amounts have been lent by each offer's maker to the taker. We now call the taker. This is a noop in a normal Mangrove. */\n      executeEnd(mor, sor);\n    }\n  }\n\n  /* # Sniping */\n  /* ## Snipes */\n  //+clear+\n\n  /* `snipes` executes multiple offers. It takes a `uint[4][]` as penultimate argument, with each array element of the form `[offerId,takerWants,takerGives,offerGasreq]`. The return parameters are of the form `(successes,totalGot,totalGave)`. \n  Note that we do not distinguish further between mismatched arguments/offer fields on the one hand, and an execution failure on the other. Still, a failed offer has to pay a penalty, and ultimately transaction logs explicitly mention execution failures (see `MgvLib.sol`). */\n  function snipes(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint[4][] calldata targets,\n    bool fillWants\n  )\n    external\n    returns (\n      uint,\n      uint,\n      uint\n    )\n  {\n    return\n      generalSnipes(outbound_tkn, inbound_tkn, targets, fillWants, msg.sender);\n  }\n\n  /*\n     From an array of _n_ `[offerId, takerWants,takerGives,gasreq]` elements, execute each snipe in sequence. Returns `(successes, takerGot, takerGave)`. \n\n     Note that if this function is not internal, anyone can make anyone use Mangrove. */\n  function generalSnipes(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint[4][] calldata targets,\n    bool fillWants,\n    address taker\n  )\n    internal\n    returns (\n      uint,\n      uint,\n      uint\n    )\n  {\n    ML.SingleOrder memory sor;\n    sor.outbound_tkn = outbound_tkn;\n    sor.inbound_tkn = inbound_tkn;\n    (sor.global, sor.local) = config(outbound_tkn, inbound_tkn);\n\n    MultiOrder memory mor;\n    mor.taker = taker;\n    mor.fillWants = fillWants;\n\n    /* For the snipes to even start, the market needs to be both active and not currently protected from reentrancy. */\n    activeMarketOnly(sor.global, sor.local);\n    unlockedMarketOnly(sor.local);\n\n    /* ### Main loop */\n    //+clear+\n\n    /* We start be enabling the reentrancy lock for this (`outbound_tkn`,`inbound_tkn`) pair. */\n    sor.local = (sor.local & bytes32(0xffffffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffff) | bytes32((uint(1) << 248) >> 104));\n    locals[outbound_tkn][inbound_tkn] = sor.local;\n\n    /* Call recursive `internalSnipes` function. */\n    internalSnipes(mor, sor, targets, 0);\n\n    /* Over the course of the snipes order, a penalty reserved for `msg.sender` has accumulated in `mor.totalPenalty`. No actual transfers have occured yet -- all the ethers given by the makers as provision are owned by the Mangrove. `sendPenalty` finally gives the accumulated penalty to `msg.sender`. */\n    sendPenalty(mor.totalPenalty);\n    //+clear+\n\n    emit OrderComplete(\n      outbound_tkn,\n      inbound_tkn,\n      taker,\n      mor.totalGot,\n      mor.totalGave\n    );\n\n    return (mor.successCount, mor.totalGot, mor.totalGave);\n  }\n\n  /* ## Internal snipes */\n  //+clear+\n  /* `internalSnipes` works recursively. Going downward, each successive offer is executed until each snipe in the array has been tried. Then the reentrancy lock [is lifted](#internalSnipes/liftReentrancy). Going upward, each offer's `maker` contract is called again with its remaining gas and given the chance to update its offers on the book.\n\n    The last argument is the array index for the current offer. It is initially 0. */\n  function internalSnipes(\n    MultiOrder memory mor,\n    ML.SingleOrder memory sor,\n    uint[4][] calldata targets,\n    uint i\n  ) internal {\n    /* #### Case 1 : continuation of snipes */\n    if (i < targets.length) {\n      sor.offerId = targets[i][0];\n      sor.offer = offers[sor.outbound_tkn][sor.inbound_tkn][sor.offerId];\n      sor.offerDetail = offerDetails[sor.outbound_tkn][sor.inbound_tkn][\n        sor.offerId\n      ];\n\n      /* If we removed the `isLive` conditional, a single expired or nonexistent offer in `targets` would revert the entire transaction (by the division by `offer.gives` below since `offer.gives` would be 0). We also check that `gasreq` is not worse than specified. A taker who does not care about `gasreq` can specify any amount larger than $2^{24}-1$. A mismatched price will be detected by `execute`. */\n      if (\n        !isLive(sor.offer) ||\n        uint(uint((sor.offerDetail << 160)) >> 232) > targets[i][3]\n      ) {\n        /* We move on to the next offer in the array. */\n        internalSnipes(mor, sor, targets, i + 1);\n      } else {\n        uint gasused;\n        bytes32 makerData;\n        bytes32 mgvData;\n\n        require(\n          uint96(targets[i][1]) == targets[i][1],\n          \"mgv/snipes/takerWants/96bits\"\n        );\n        require(\n          uint96(targets[i][2]) == targets[i][2],\n          \"mgv/snipes/takerGives/96bits\"\n        );\n        sor.wants = targets[i][1];\n        sor.gives = targets[i][2];\n\n        /* `execute` will adjust `sor.wants`,`sor.gives`, and may attempt to execute the offer if its price is low enough. It is crucial that an error due to `taker` triggers a revert. That way [`mgvData`](#MgvOfferTaking/statusCodes) not in `[\"mgv/tradeSuccess\",\"mgv/notExecuted\"]` means the failure is the maker's fault. */\n        /* Post-execution, `sor.wants`/`sor.gives` reflect how much was sent/taken by the offer. We will need it after the recursive call, so we save it in local variables. Same goes for `offerId`, `sor.offer` and `sor.offerDetail`. */\n        (gasused, makerData, mgvData) = execute(mor, sor);\n\n        /* In the market order, we were able to avoid stitching back offers after every `execute` since we knew a continuous segment starting at best would be consumed. Here, we cannot do this optimisation since offers in the `targets` array may be anywhere in the book. So we stitch together offers immediately after each `execute`. */\n        if (mgvData != \"mgv/notExecuted\") {\n          sor.local = stitchOffers(\n            sor.outbound_tkn,\n            sor.inbound_tkn,\n            uint(uint((sor.offer << 0)) >> 232),\n            uint(uint((sor.offer << 24)) >> 232),\n            sor.local\n          );\n        }\n\n        {\n          /* Keep cached copy of current `sor` values. */\n          uint offerId = sor.offerId;\n          uint takerWants = sor.wants;\n          uint takerGives = sor.gives;\n          bytes32 offer = sor.offer;\n          bytes32 offerDetail = sor.offerDetail;\n\n          /* We move on to the next offer in the array. */\n          internalSnipes(mor, sor, targets, i + 1);\n\n          /* Restore `sor` values from to before recursive call */\n          sor.offerId = offerId;\n          sor.wants = takerWants;\n          sor.gives = takerGives;\n          sor.offer = offer;\n          sor.offerDetail = offerDetail;\n        }\n\n        /* After an offer execution, we may run callbacks and increase the total penalty. As that part is common to market orders and snipes, it lives in its own `postExecute` function. */\n        if (mgvData != \"mgv/notExecuted\") {\n          postExecute(mor, sor, gasused, makerData, mgvData);\n        }\n      }\n      /* #### Case 2 : End of snipes */\n    } else {\n      /* <a id=\"internalSnipes/liftReentrancy\"></a> Now that the snipes is over, we can lift the lock on the book. In the same operation we\n      * lift the reentrancy lock, and\n      * update the storage\n\n      so we are free from out of order storage writes.\n      */\n      sor.local = (sor.local & bytes32(0xffffffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffff) | bytes32((uint(0) << 248) >> 104));\n      locals[sor.outbound_tkn][sor.inbound_tkn] = sor.local;\n      /* `payTakerMinusFees` sends the fee to the vault, proportional to the amount purchased, and gives the rest to the taker */\n      payTakerMinusFees(mor, sor);\n      /* In an inverted Mangrove, amounts have been lent by each offer's maker to the taker. We now call the taker. This is a noop in a normal Mangrove. */\n      executeEnd(mor, sor);\n    }\n  }\n\n  /* # General execution */\n  /* During a market order or a snipes, offers get executed. The following code takes care of executing a single offer with parameters given by a `SingleOrder` within a larger context given by a `MultiOrder`. */\n\n  /* ## Execute */\n  /* This function will compare `sor.wants` `sor.gives` with `sor.offer.wants` and `sor.offer.gives`. If the price of the offer is low enough, an execution will be attempted (with volume limited by the offer's advertised volume).\n\n     Summary of the meaning of the return values:\n    * `gasused` is the gas consumed by the execution\n    * `makerData` is the data returned after executing the offer\n    * `mgvData` is an [internal Mangrove status code](#MgvOfferTaking/statusCodes).\n  */\n  function execute(MultiOrder memory mor, ML.SingleOrder memory sor)\n    internal\n    returns (\n      uint gasused,\n      bytes32 makerData,\n      bytes32 mgvData\n    )\n  {\n    /* #### `Price comparison` */\n    //+clear+\n    /* The current offer has a price `p = offerWants ÷ offerGives` and the taker is ready to accept a price up to `p' = takerGives ÷ takerWants`. Comparing `offerWants * takerWants` and `offerGives * takerGives` tels us whether `p < p'`.\n     */\n    {\n      uint offerWants = uint(uint((sor.offer << 48)) >> 160);\n      uint offerGives = uint(uint((sor.offer << 144)) >> 160);\n      uint takerWants = sor.wants;\n      uint takerGives = sor.gives;\n      /* <a id=\"MgvOfferTaking/checkPrice\"></a>If the price is too high, we return early.\n\n         Otherwise we now know we'll execute the offer. */\n      if (offerWants * takerWants > offerGives * takerGives) {\n        return (0, bytes32(0), \"mgv/notExecuted\");\n      }\n\n      /* ### Specification of value transfers:\n\n      Let $o_w$ be `offerWants`, $o_g$ be `offerGives`, $t_w$ be `takerWants`, $t_g$ be `takerGives`, and `f ∈ {w,g}` be $w$ if `fillWants` is true, $g$ otherwise.\n\n      Let $\\textrm{got}$ be the amount that the taker will receive, and $\\textrm{gave}$ be the amount that the taker will pay.\n\n      #### Case $f = w$\n\n      If $f = w$, let $\\textrm{got} = \\min(o_g,t_w)$, and let $\\textrm{gave} = \\left\\lceil\\dfrac{o_w \\textrm{got}}{o_g}\\right\\rceil$. This is well-defined since, for live offers, $o_g > 0$.\n\n      In plain english, we only give to the taker up to what they wanted (or what the offer has to give), and follow the offer price to determine what the taker will give.\n\n      Since $\\textrm{gave}$ is rounded up, the price might be overevaluated. Still, we cannot spend more than what the taker specified as `takerGives`. At this point [we know](#MgvOfferTaking/checkPrice) that $o_w t_w \\leq o_g t_g$, so since $t_g$ is an integer we have\n      \n      $t_g \\geq \\left\\lceil\\dfrac{o_w t_w}{o_g}\\right\\rceil \\geq \\left\\lceil\\dfrac{o_w \\textrm{got}}{o_g}\\right\\rceil = \\textrm{gave}$.\n\n\n      #### Case $f = g$\n\n      If $f = g$, let $\\textrm{gave} = \\min(o_w,t_g)$, and $\\textrm{got} = o_g$ if $o_w = 0$, $\\textrm{got} = \\left\\lfloor\\dfrac{o_g \\textrm{gave}}{o_w}\\right\\rfloor$ otherwise.\n\n      In plain english, we spend up to what the taker agreed to pay (or what the offer wants), and follow the offer price to determine what the taker will get. This may exceed $t_w$.\n\n      #### Price adjustment\n\n      Prices are rounded up to ensure maker is not drained on small amounts. It's economically unlikely, but `density` protects the taker from being drained anyway so it is better to default towards protecting the maker here.\n      */\n\n      /*\n      ### Implementation\n\n      First we check the cases $(f=w \\wedge o_g < t_w)\\vee(f_g \\wedge o_w < t_g)$, in which case the above spec simplifies to $\\textrm{got} = o_g, \\textrm{gave} = o_w$.\n\n      Otherwise the offer may be partially consumed.\n      \n      In the case $f=w$ we don't touch $\\textrm{got}$ (which was initialized to $t_w$) and compute $\\textrm{gave} = \\left\\lceil\\dfrac{o_w t_w}{o_g}\\right\\rceil$. As shown above we have $\\textrm{gave} \\leq t_g$.\n\n      In the case $f=g$ we don't touch $\\textrm{gave}$ (which was initialized to $t_g$) and compute $\\textrm{got} = o_g$ if $o_w = 0$, and $\\textrm{got} = \\left\\lfloor\\dfrac{o_g t_g}{o_w}\\right\\rfloor$ otherwise.\n      */\n      if (\n        (mor.fillWants && offerGives < takerWants) ||\n        (!mor.fillWants && offerWants < takerGives)\n      ) {\n        sor.wants = offerGives;\n        sor.gives = offerWants;\n      } else {\n        if (mor.fillWants) {\n          uint product = offerWants * takerWants;\n          sor.gives =\n            product /\n            offerGives +\n            (product % offerGives == 0 ? 0 : 1);\n        } else {\n          if (offerWants == 0) {\n            sor.wants = offerGives;\n          } else {\n            sor.wants = (offerGives * takerGives) / offerWants;\n          }\n        }\n      }\n    }\n    /* The flashloan is executed by call to `flashloan`. If the call reverts, it means the maker failed to send back `sor.wants` `outbound_tkn` to the taker. Notes :\n     * `msg.sender` is the Mangrove itself in those calls -- all operations related to the actual caller should be done outside of this call.\n     * any spurious exception due to an error in Mangrove code will be falsely blamed on the Maker, and its provision for the offer will be unfairly taken away.\n     */\n    (bool success, bytes memory retdata) = address(this).call(\n      abi.encodeWithSelector(this.flashloan.selector, sor, mor.taker)\n    );\n\n    /* `success` is true: trade is complete */\n    if (success) {\n      mor.successCount += 1;\n      /* In case of success, `retdata` encodes the gas used by the offer. */\n      gasused = abi.decode(retdata, (uint));\n      /* `mgvData` indicates trade success */\n      mgvData = bytes32(\"mgv/tradeSuccess\");\n      emit OfferSuccess(\n        sor.outbound_tkn,\n        sor.inbound_tkn,\n        sor.offerId,\n        mor.taker,\n        sor.wants,\n        sor.gives\n      );\n\n      /* If configured to do so, the Mangrove notifies an external contract that a successful trade has taken place. */\n      if (uint(uint((sor.global << 168)) >> 248) > 0) {\n        IMgvMonitor(address(uint((sor.global << 0)) >> 96)).notifySuccess(\n          sor,\n          mor.taker\n        );\n      }\n\n      /* We update the totals in the multiorder based on the adjusted `sor.wants`/`sor.gives`. */\n      /* overflow: sor.{wants,gives} are on 96bits, sor.total{Got,Gave} are on 256 bits. */\n      mor.totalGot += sor.wants;\n      mor.totalGave += sor.gives;\n    } else {\n      /* In case of failure, `retdata` encodes a short [status code](#MgvOfferTaking/statusCodes), the gas used by the offer, and an arbitrary 256 bits word sent by the maker.  */\n      (mgvData, gasused, makerData) = innerDecode(retdata);\n      /* Note that in the `if`s, the literals are bytes32 (stack values), while as revert arguments, they are strings (memory pointers). */\n      if (\n        mgvData == \"mgv/makerRevert\" ||\n        mgvData == \"mgv/makerAbort\" ||\n        mgvData == \"mgv/makerTransferFail\" ||\n        mgvData == \"mgv/makerReceiveFail\"\n      ) {\n        mor.failCount += 1;\n\n        emit OfferFail(\n          sor.outbound_tkn,\n          sor.inbound_tkn,\n          sor.offerId,\n          mor.taker,\n          sor.wants,\n          sor.gives,\n          mgvData\n        );\n\n        /* If configured to do so, the Mangrove notifies an external contract that a failed trade has taken place. */\n        if (uint(uint((sor.global << 168)) >> 248) > 0) {\n          IMgvMonitor(address(uint((sor.global << 0)) >> 96)).notifyFail(\n            sor,\n            mor.taker\n          );\n        }\n        /* It is crucial that any error code which indicates an error caused by the taker triggers a revert, because functions that call `execute` consider that `mgvData` not in `[\"mgv/notExecuted\",\"mgv/tradeSuccess\"]` should be blamed on the maker. */\n      } else if (mgvData == \"mgv/notEnoughGasForMakerTrade\") {\n        revert(\"mgv/notEnoughGasForMakerTrade\");\n      } else if (mgvData == \"mgv/takerTransferFail\") {\n        revert(\"mgv/takerTransferFail\");\n      } else {\n        /* This code must be unreachable. **Danger**: if a well-crafted offer/maker pair can force a revert of `flashloan`, the Mangrove will be stuck. */\n        revert(\"mgv/swapError\");\n      }\n    }\n\n    /* Delete the offer. The last argument indicates whether the offer should be stripped of its provision (yes if execution failed, no otherwise). We delete offers whether the amount remaining on offer is > density or not for the sake of uniformity (code is much simpler). We also expect prices to move often enough that the maker will want to update their price anyway. To simulate leaving the remaining volume in the offer, the maker can program their `makerPosthook` to `updateOffer` and put the remaining volume back in. */\n    dirtyDeleteOffer(\n      sor.outbound_tkn,\n      sor.inbound_tkn,\n      sor.offerId,\n      sor.offer,\n      mgvData != \"mgv/tradeSuccess\"\n    );\n  }\n\n  /* ## flashloan (abstract) */\n  /* Externally called by `execute`, flashloan lends money (from the taker to the maker, or from the maker to the taker, depending on the implementation) then calls `makerExecute` to run the maker liquidity fetching code. If `makerExecute` is unsuccessful, `flashloan` reverts (but the larger orderbook traversal will continue). \n\n  All `flashloan` implementations must `require(msg.sender) == address(this))`. */\n  function flashloan(ML.SingleOrder calldata sor, address taker)\n    external\n    virtual\n    returns (uint gasused);\n\n  /* ## Maker Execute */\n  /* Called by `flashloan`, `makerExecute` runs the maker code and checks that it can safely send the desired assets to the taker. */\n\n  function makerExecute(ML.SingleOrder calldata sor)\n    internal\n    returns (uint gasused)\n  {\n    bytes memory cd = abi.encodeWithSelector(IMaker.makerExecute.selector, sor);\n\n    uint gasreq = uint(uint((sor.offerDetail << 160)) >> 232);\n    address maker = address(uint((sor.offerDetail << 0)) >> 96);\n    uint oldGas = gasleft();\n    /* We let the maker pay for the overhead of checking remaining gas and making the call, as well as handling the return data (constant gas since only the first 32 bytes of return data are read). So the `require` below is just an approximation: if the overhead of (`require` + cost of `CALL`) is $h$, the maker will receive at worst $\\textrm{gasreq} - \\frac{63h}{64}$ gas. */\n    /* Note : as a possible future feature, we could stop an order when there's not enough gas left to continue processing offers. This could be done safely by checking, as soon as we start processing an offer, whether `63/64(gasleft-overhead_gasbase-offer_gasbase) > gasreq`. If no, we could stop and know by induction that there is enough gas left to apply fees, stitch offers, etc for the offers already executed. */\n    if (!(oldGas - oldGas / 64 >= gasreq)) {\n      innerRevert([bytes32(\"mgv/notEnoughGasForMakerTrade\"), \"\", \"\"]);\n    }\n\n    (bool callSuccess, bytes32 makerData) = controlledCall(maker, gasreq, cd);\n\n    gasused = oldGas - gasleft();\n\n    if (!callSuccess) {\n      innerRevert([bytes32(\"mgv/makerRevert\"), bytes32(gasused), makerData]);\n    }\n\n    /* Successful execution must have a returndata that begins with `bytes32(\"\")`.\n     */\n    if (makerData != \"\") {\n      innerRevert([bytes32(\"mgv/makerAbort\"), bytes32(gasused), makerData]);\n    }\n\n    bool transferSuccess = transferTokenFrom(\n      sor.outbound_tkn,\n      maker,\n      address(this),\n      sor.wants\n    );\n\n    if (!transferSuccess) {\n      innerRevert(\n        [bytes32(\"mgv/makerTransferFail\"), bytes32(gasused), makerData]\n      );\n    }\n  }\n\n  /* ## executeEnd (abstract) */\n  /* Called by `internalSnipes` and `internalMarketOrder`, `executeEnd` may run implementation-specific code after all makers have been called once. In [`InvertedMangrove`](#InvertedMangrove), the function calls the taker once so they can act on their flashloan. In [`Mangrove`], it does nothing. */\n  function executeEnd(MultiOrder memory mor, ML.SingleOrder memory sor)\n    internal\n    virtual;\n\n  /* ## Post execute */\n  /* At this point, we know `mgvData != \"mgv/notExecuted\"`. After executing an offer (whether in a market order or in snipes), we\n     1. Call the maker's posthook and sum the total gas used.\n     2. If offer failed: sum total penalty due to taker and give remainder to maker.\n   */\n  function postExecute(\n    MultiOrder memory mor,\n    ML.SingleOrder memory sor,\n    uint gasused,\n    bytes32 makerData,\n    bytes32 mgvData\n  ) internal {\n    if (mgvData == \"mgv/tradeSuccess\") {\n      beforePosthook(sor);\n    }\n\n    uint gasreq = uint(uint((sor.offerDetail << 160)) >> 232);\n\n    /* We are about to call back the maker, giving it its unused gas (`gasreq - gasused`). Since the gas used so far may exceed `gasreq`, we prevent underflow in the subtraction below by bounding `gasused` above with `gasreq`. We could have decided not to call back the maker at all when there is no gas left, but we do it for uniformity. */\n    if (gasused > gasreq) {\n      gasused = gasreq;\n    }\n\n    gasused =\n      gasused +\n      makerPosthook(sor, gasreq - gasused, makerData, mgvData);\n\n    if (mgvData != \"mgv/tradeSuccess\") {\n      mor.totalPenalty += applyPenalty(sor, gasused, mor.failCount);\n    }\n  }\n\n  /* ## beforePosthook (abstract) */\n  /* Called by `makerPosthook`, this function can run implementation-specific code before calling the maker has been called a second time. In [`InvertedMangrove`](#InvertedMangrove), all makers are called once so the taker gets all of its money in one shot. Then makers are traversed again and the money is sent back to each taker using `beforePosthook`. In [`Mangrove`](#Mangrove), `beforePosthook` does nothing. */\n\n  function beforePosthook(ML.SingleOrder memory sor) internal virtual;\n\n  /* ## Maker Posthook */\n  function makerPosthook(\n    ML.SingleOrder memory sor,\n    uint gasLeft,\n    bytes32 makerData,\n    bytes32 mgvData\n  ) internal returns (uint gasused) {\n    /* At this point, mgvData can only be `\"mgv/tradeSuccess\"`, `\"mgv/makerAbort\"`, `\"mgv/makerRevert\"`, `\"mgv/makerTransferFail\"` or `\"mgv/makerReceiveFail\"` */\n    bytes memory cd = abi.encodeWithSelector(\n      IMaker.makerPosthook.selector,\n      sor,\n      ML.OrderResult({makerData: makerData, mgvData: mgvData})\n    );\n\n    address maker = address(uint((sor.offerDetail << 0)) >> 96);\n\n    uint oldGas = gasleft();\n    /* We let the maker pay for the overhead of checking remaining gas and making the call. So the `require` below is just an approximation: if the overhead of (`require` + cost of `CALL`) is $h$, the maker will receive at worst $\\textrm{gasreq} - \\frac{63h}{64}$ gas. */\n    if (!(oldGas - oldGas / 64 >= gasLeft)) {\n      revert(\"mgv/notEnoughGasForMakerPosthook\");\n    }\n\n    (bool callSuccess, ) = controlledCall(maker, gasLeft, cd);\n\n    gasused = oldGas - gasleft();\n\n    if (!callSuccess) {\n      emit PosthookFail(sor.outbound_tkn, sor.inbound_tkn, sor.offerId);\n    }\n  }\n\n  /* ## `controlledCall` */\n  /* Calls an external function with controlled gas expense. A direct call of the form `(,bytes memory retdata) = maker.call{gas}(selector,...args)` enables a griefing attack: the maker uses half its gas to write in its memory, then reverts with that memory segment as argument. After a low-level call, solidity automaticaly copies `returndatasize` bytes of `returndata` into memory. So the total gas consumed to execute a failing offer could exceed `gasreq + overhead_gasbase/n + offer_gasbase` where `n` is the number of failing offers. This yul call only retrieves the first 32 bytes of the maker's `returndata`. */\n  function controlledCall(\n    address callee,\n    uint gasreq,\n    bytes memory cd\n  ) internal returns (bool success, bytes32 data) {\n    bytes32[1] memory retdata;\n\n    assembly {\n      success := call(gasreq, callee, 0, add(cd, 32), mload(cd), retdata, 32)\n    }\n\n    data = retdata[0];\n  }\n\n  /* # Penalties */\n  /* Offers are just promises. They can fail. Penalty provisioning discourages from failing too much: we ask makers to provision more ETH than the expected gas cost of executing their offer and penalize them accoridng to wasted gas.\n\n     Under normal circumstances, we should expect to see bots with a profit expectation dry-running offers locally and executing `snipe` on failing offers, collecting the penalty. The result should be a mostly clean book for actual takers (i.e. a book with only successful offers).\n\n     **Incentive issue**: if the gas price increases enough after an offer has been created, there may not be an immediately profitable way to remove the fake offers. In that case, we count on 3 factors to keep the book clean:\n     1. Gas price eventually comes down.\n     2. Other market makers want to keep the Mangrove attractive and maintain their offer flow.\n     3. Mangrove governance (who may collect a fee) wants to keep the Mangrove attractive and maximize exchange volume. */\n\n  //+clear+\n  /* After an offer failed, part of its provision is given back to the maker and the rest is stored to be sent to the taker after the entire order completes. In `applyPenalty`, we _only_ credit the maker with its excess provision. So it looks like the maker is gaining something. In fact they're just getting back a fraction of what they provisioned earlier. */\n  /*\n     Penalty application summary:\n\n   * If the transaction was a success, we entirely refund the maker and send nothing to the taker.\n   * Otherwise, the maker loses the cost of `gasused + overhead_gasbase/n + offer_gasbase` gas, where `n` is the number of failed offers. The gas price is estimated by `gasprice`.\n   * To create the offer, the maker had to provision for `gasreq + overhead_gasbase/n + offer_gasbase` gas at a price of `offer.gasprice`.\n   * We do not consider the tx.gasprice.\n   * `offerDetail.gasbase` and `offer.gasprice` are the values of the Mangrove parameters `config.*_gasbase` and `config.gasprice` when the offer was created. Without caching those values, the provision set aside could end up insufficient to reimburse the maker (or to retribute the taker).\n   */\n  function applyPenalty(\n    ML.SingleOrder memory sor,\n    uint gasused,\n    uint failCount\n  ) internal returns (uint) {\n    uint gasreq = uint(uint((sor.offerDetail << 160)) >> 232);\n\n    uint provision = 10**9 *\n      uint(uint((sor.offer << 240)) >> 240) *\n      (gasreq +\n        uint(uint((sor.offerDetail << 184)) >> 232) +\n        uint(uint((sor.offerDetail << 208)) >> 232));\n\n    /* We set `gasused = min(gasused,gasreq)` since `gasreq < gasused` is possible e.g. with `gasreq = 0` (all calls consume nonzero gas). */\n    if (gasused > gasreq) {\n      gasused = gasreq;\n    }\n\n    /* As an invariant, `applyPenalty` is only called when `mgvData` is not in `[\"mgv/notExecuted\",\"mgv/tradeSuccess\"]`, and thus when `failCount > 0`. */\n    uint penalty = 10**9 *\n      uint(uint((sor.global << 176)) >> 240) *\n      (gasused +\n        uint(uint((sor.local << 56)) >> 232) /\n        failCount +\n        uint(uint((sor.local << 80)) >> 232));\n\n    if (penalty > provision) {\n      penalty = provision;\n    }\n\n    /* Here we write to storage the new maker balance. This occurs _after_ possible reentrant calls. How do we know we're not crediting twice the same amounts? Because the `offer`'s provision was set to 0 in storage (through `dirtyDeleteOffer`) before the reentrant calls. In this function, we are working with cached copies of the offer as it was before it was consumed. */\n    creditWei(address(uint((sor.offerDetail << 0)) >> 96), provision - penalty);\n\n    return penalty;\n  }\n\n  function sendPenalty(uint amount) internal {\n    if (amount > 0) {\n      (bool noRevert, ) = msg.sender.call{value: amount}(\"\");\n      require(noRevert, \"mgv/sendPenaltyReverted\");\n    }\n  }\n\n  /* Post-trade, `payTakerMinusFees` sends what's due to the taker and the rest (the fees) to the vault. Routing through the Mangrove like that also deals with blacklisting issues (separates the maker-blacklisted and the taker-blacklisted cases). */\n  function payTakerMinusFees(MultiOrder memory mor, ML.SingleOrder memory sor)\n    internal\n  {\n    /* Should be statically provable that the 2 transfers below cannot return false under well-behaved ERC20s and a non-blacklisted, non-0 target. */\n\n    uint concreteFee = (mor.totalGot * uint(uint((sor.local << 8)) >> 240)) / 10_000;\n    if (concreteFee > 0) {\n      mor.totalGot -= concreteFee;\n      require(\n        transferToken(sor.outbound_tkn, vault, concreteFee),\n        \"mgv/feeTransferFail\"\n      );\n    }\n    if (mor.totalGot > 0) {\n      require(\n        transferToken(sor.outbound_tkn, mor.taker, mor.totalGot),\n        \"mgv/MgvFailToPayTaker\"\n      );\n    }\n  }\n\n  /* # Misc. functions */\n\n  /* Regular solidity reverts prepend the string argument with a [function signature](https://docs.soliditylang.org/en/v0.7.6/control-structures.html#revert). Since we wish to transfer data through a revert, the `innerRevert` function does a low-level revert with only the required data. `innerCode` decodes this data. */\n  function innerDecode(bytes memory data)\n    internal\n    pure\n    returns (\n      bytes32 mgvData,\n      uint gasused,\n      bytes32 makerData\n    )\n  {\n    /* The `data` pointer is of the form `[mgvData,gasused,makerData]` where each array element is contiguous and has size 256 bits. */\n    assembly {\n      mgvData := mload(add(data, 32))\n      gasused := mload(add(data, 64))\n      makerData := mload(add(data, 96))\n    }\n  }\n\n  /* <a id=\"MgvOfferTaking/innerRevert\"></a>`innerRevert` reverts a raw triple of values to be interpreted by `innerDecode`.    */\n  function innerRevert(bytes32[3] memory data) internal pure {\n    assembly {\n      revert(data, 96)\n    }\n  }\n\n  /* `transferTokenFrom` is adapted from [existing code](https://soliditydeveloper.com/safe-erc20) and in particular avoids the\n  \"no return value\" bug. It never throws and returns true iff the transfer was successful according to `tokenAddress`.\n\n    Note that any spurious exception due to an error in Mangrove code will be falsely blamed on `from`.\n  */\n  function transferTokenFrom(\n    address tokenAddress,\n    address from,\n    address to,\n    uint value\n  ) internal returns (bool) {\n    bytes memory cd = abi.encodeWithSelector(\n      IERC20.transferFrom.selector,\n      from,\n      to,\n      value\n    );\n    (bool noRevert, bytes memory data) = tokenAddress.call(cd);\n    return (noRevert && (data.length == 0 || abi.decode(data, (bool))));\n  }\n\n  function transferToken(\n    address tokenAddress,\n    address to,\n    uint value\n  ) internal returns (bool) {\n    bytes memory cd = abi.encodeWithSelector(\n      IERC20.transfer.selector,\n      to,\n      value\n    );\n    (bool noRevert, bytes memory data) = tokenAddress.call(cd);\n    return (noRevert && (data.length == 0 || abi.decode(data, (bool))));\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Vault.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\n\nimport \"../AbstractMangrove.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\n\n// In these tests, the testing contract is the market maker.\ncontract Vault_Test {\n  receive() external payable {}\n\n  AbstractMangrove mgv;\n  TestMaker mkr;\n  address base;\n  address quote;\n\n  function a_beforeAll() public {\n    TestToken baseT = TokenSetup.setup(\"A\", \"$A\");\n    TestToken quoteT = TokenSetup.setup(\"B\", \"$B\");\n    base = address(baseT);\n    quote = address(quoteT);\n    mgv = MgvSetup.setup(baseT, quoteT);\n    mkr = MakerSetup.setup(mgv, base, quote);\n\n    address(mkr).transfer(10 ether);\n\n    mkr.provisionMgv(5 ether);\n    bool noRevert;\n    (noRevert, ) = address(mgv).call{value: 10 ether}(\"\");\n\n    baseT.mint(address(mkr), 2 ether);\n    quoteT.mint(address(this), 2 ether);\n\n    baseT.approve(address(mgv), 1 ether);\n    quoteT.approve(address(mgv), 1 ether);\n\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"Test Contract\");\n    Display.register(base, \"$A\");\n    Display.register(quote, \"$B\");\n    Display.register(address(mgv), \"mgv\");\n    Display.register(address(mkr), \"maker[$A,$B]\");\n  }\n\n  function initial_vault_value_test() public {\n    TestEvents.eq(\n      mgv.vault(),\n      address(this),\n      \"initial vault value should be mgv creator\"\n    );\n  }\n\n  function gov_can_set_vault_test() public {\n    mgv.setVault(address(0));\n    TestEvents.eq(mgv.vault(), address(0), \"gov should be able to set vault\");\n  }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Toolbox/TestUtils.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier: Unlicense\n\n// Encode structs\n\n\nimport \"../Agents/TestTaker.sol\";\nimport \"../Agents/MakerDeployer.sol\";\nimport \"../Agents/TestMoriartyMaker.sol\";\nimport \"../Agents/TestToken.sol\";\n\nimport {Display, Test as TestEvents} from \"@giry/hardhat-test-solidity/test.sol\";\nimport \"../../InvertedMangrove.sol\";\nimport \"../../Mangrove.sol\";\nimport {MgvPack as MP} from \"../../MgvPack.sol\";\n\nlibrary TestUtils {\n  /* Various utilities */\n\n  function uint2str(uint _i)\n    internal\n    pure\n    returns (string memory _uintAsString)\n  {\n    if (_i == 0) {\n      return \"0\";\n    }\n    uint j = _i;\n    uint len;\n    while (j != 0) {\n      len++;\n      j /= 10;\n    }\n    bytes memory bstr = new bytes(len);\n    uint k = len - 1;\n    while (_i != 0) {\n      bstr[k--] = bytes1(uint8(48 + (_i % 10)));\n      _i /= 10;\n    }\n    return string(bstr);\n  }\n\n  function append(string memory a, string memory b)\n    internal\n    pure\n    returns (string memory)\n  {\n    return string(abi.encodePacked(a, b));\n  }\n\n  function append(\n    string memory a,\n    string memory b,\n    string memory c\n  ) internal pure returns (string memory) {\n    return string(abi.encodePacked(a, b, c));\n  }\n\n  function append(\n    string memory a,\n    string memory b,\n    string memory c,\n    string memory d\n  ) internal pure returns (string memory) {\n    return string(abi.encodePacked(a, b, c, d));\n  }\n\n  function toEthUnits(uint w, string memory units)\n    internal\n    pure\n    returns (string memory eth)\n  {\n    string memory suffix = append(\" \", units);\n\n    if (w == 0) {\n      return (append(\"0\", suffix));\n    }\n    uint i = 0;\n    while (w % 10 == 0) {\n      w = w / 10;\n      i += 1;\n    }\n    if (i >= 18) {\n      w = w * (10**(i - 18));\n      return append(uint2str(w), suffix);\n    } else {\n      uint zeroBefore = 18 - i;\n      string memory zeros = \"\";\n      while (zeroBefore > 1) {\n        zeros = append(zeros, \"0\");\n        zeroBefore--;\n      }\n      return (append(\"0.\", zeros, uint2str(w), suffix));\n    }\n  }\n\n  /* Log offer book */\n\n  event OBState(\n    address base,\n    address quote,\n    uint[] offerIds,\n    uint[] wants,\n    uint[] gives,\n    address[] makerAddr,\n    uint[] gasreqs\n  );\n\n  /** Two different OB logging methods.\n   *\n   *  `logOfferBook` will be well-interlaced with tests so you can easily see what's going on.\n   *\n   *  `printOfferBook` will survive reverts so you can log inside a reverting call.\n   */\n\n  /* Log OB with events and hardhat-test-solidity */\n  function logOfferBook(\n    AbstractMangrove mgv,\n    address base,\n    address quote,\n    uint size\n  ) internal {\n    uint offerId = mgv.best(base, quote);\n\n    uint[] memory wants = new uint[](size);\n    uint[] memory gives = new uint[](size);\n    address[] memory makerAddr = new address[](size);\n    uint[] memory offerIds = new uint[](size);\n    uint[] memory gasreqs = new uint[](size);\n    uint c = 0;\n    while ((offerId != 0) && (c < size)) {\n      (ML.Offer memory offer, ML.OfferDetail memory od) = mgv.offerInfo(\n        base,\n        quote,\n        offerId\n      );\n      wants[c] = offer.wants;\n      gives[c] = offer.gives;\n      makerAddr[c] = od.maker;\n      offerIds[c] = offerId;\n      gasreqs[c] = od.gasreq;\n      offerId = offer.next;\n      c++;\n    }\n    emit OBState(base, quote, offerIds, wants, gives, makerAddr, gasreqs);\n  }\n\n  /* Log OB with hardhat's console.log */\n  function printOfferBook(\n    AbstractMangrove mgv,\n    address base,\n    address quote\n  ) internal view {\n    uint offerId = mgv.best(base, quote);\n    TestToken req_tk = TestToken(quote);\n    TestToken ofr_tk = TestToken(base);\n\n    console.log(\"-----Best offer: %d-----\", offerId);\n    while (offerId != 0) {\n      (ML.Offer memory ofr, ) = mgv.offerInfo(base, quote, offerId);\n      console.log(\n        \"[offer %d] %s/%s\",\n        offerId,\n        TestUtils.toEthUnits(ofr.wants, req_tk.symbol()),\n        TestUtils.toEthUnits(ofr.gives, ofr_tk.symbol())\n      );\n      // console.log(\n      //   \"(%d gas, %d to finish, %d penalty)\",\n      //   gasreq,\n      //   minFinishGas,\n      //   gasprice\n      // );\n      // console.log(name(makerAddr));\n      offerId = ofr.next;\n    }\n    console.log(\"-----------------------\");\n  }\n\n  /* Additional testing functions */\n\n  function revertEq(string memory actual_reason, string memory expected_reason)\n    internal\n    returns (bool)\n  {\n    return TestEvents.eq(actual_reason, expected_reason, \"wrong revert reason\");\n  }\n\n  event TestNot0x(bool success, address addr);\n\n  function not0x(address actual) internal returns (bool) {\n    bool success = actual != address(0);\n    emit TestNot0x(success, actual);\n    return success;\n  }\n\n  event GasCost(string callname, uint value);\n\n  function execWithCost(\n    string memory callname,\n    address addr,\n    bytes memory data\n  ) internal returns (bytes memory) {\n    uint g0 = gasleft();\n    (bool noRevert, bytes memory retdata) = addr.delegatecall(data);\n    require(noRevert, \"execWithCost should not revert\");\n    emit GasCost(callname, g0 - gasleft());\n    return retdata;\n  }\n\n  struct Balances {\n    uint mgvBalanceWei;\n    uint mgvBalanceFees;\n    uint takerBalanceA;\n    uint takerBalanceB;\n    uint takerBalanceWei;\n    uint[] makersBalanceA;\n    uint[] makersBalanceB;\n    uint[] makersBalanceWei;\n  }\n  enum Info {\n    makerWants,\n    makerGives,\n    nextId,\n    gasreqreceive_on,\n    gasprice,\n    gasreq\n  }\n\n  function getReason(bytes memory returnData)\n    internal\n    pure\n    returns (string memory reason)\n  {\n    /* returnData for a revert(reason) is the result of\n       abi.encodeWithSignature(\"Error(string)\",reason)\n       but abi.decode assumes the first 4 bytes are padded to 32\n       so we repad them. See:\n       https://github.com/ethereum/solidity/issues/6012\n     */\n    bytes memory pointer = abi.encodePacked(bytes28(0), returnData);\n    uint len = returnData.length - 4;\n    assembly {\n      pointer := add(32, pointer)\n      mstore(pointer, len)\n    }\n    reason = abi.decode(pointer, (string));\n  }\n\n  function isEmptyOB(\n    AbstractMangrove mgv,\n    address base,\n    address quote\n  ) internal view returns (bool) {\n    return mgv.best(base, quote) == 0;\n  }\n\n  function adminOf(AbstractMangrove mgv) internal view returns (address) {\n    return mgv.governance();\n  }\n\n  function getFee(\n    AbstractMangrove mgv,\n    address base,\n    address quote,\n    uint price\n  ) internal view returns (uint) {\n    (, bytes32 local) = mgv.config(base, quote);\n    return ((price * MP.local_unpack_fee(local)) / 10000);\n  }\n\n  function getProvision(\n    AbstractMangrove mgv,\n    address base,\n    address quote,\n    uint gasreq\n  ) internal view returns (uint) {\n    (bytes32 glo_cfg, bytes32 loc_cfg) = mgv.config(base, quote);\n    return ((gasreq +\n      MP.local_unpack_overhead_gasbase(loc_cfg) +\n      MP.local_unpack_offer_gasbase(loc_cfg)) *\n      uint(MP.global_unpack_gasprice(glo_cfg)) *\n      10**9);\n  }\n\n  function getProvision(\n    AbstractMangrove mgv,\n    address base,\n    address quote,\n    uint gasreq,\n    uint gasprice\n  ) internal view returns (uint) {\n    (bytes32 glo_cfg, bytes32 loc_cfg) = mgv.config(base, quote);\n    uint _gp;\n    if (MP.global_unpack_gasprice(glo_cfg) > gasprice) {\n      _gp = uint(MP.global_unpack_gasprice(glo_cfg));\n    } else {\n      _gp = gasprice;\n    }\n    return ((gasreq +\n      MP.local_unpack_overhead_gasbase(loc_cfg) +\n      MP.local_unpack_offer_gasbase(loc_cfg)) *\n      _gp *\n      10**9);\n  }\n\n  function getOfferInfo(\n    AbstractMangrove mgv,\n    address base,\n    address quote,\n    Info infKey,\n    uint offerId\n  ) internal view returns (uint) {\n    (ML.Offer memory offer, ML.OfferDetail memory offerDetail) = mgv.offerInfo(\n      base,\n      quote,\n      offerId\n    );\n    if (!mgv.isLive(mgv.offers(base, quote, offerId))) {\n      return 0;\n    }\n    if (infKey == Info.makerWants) {\n      return offer.wants;\n    }\n    if (infKey == Info.makerGives) {\n      return offer.gives;\n    }\n    if (infKey == Info.nextId) {\n      return offer.next;\n    }\n    if (infKey == Info.gasreq) {\n      return offerDetail.gasreq;\n    } else {\n      return offer.gasprice;\n    }\n  }\n\n  function hasOffer(\n    AbstractMangrove mgv,\n    address base,\n    address quote,\n    uint offerId\n  ) internal view returns (bool) {\n    return (getOfferInfo(mgv, base, quote, Info.makerGives, offerId) > 0);\n  }\n\n  function makerOf(\n    AbstractMangrove mgv,\n    address base,\n    address quote,\n    uint offerId\n  ) internal view returns (address) {\n    (, ML.OfferDetail memory od) = mgv.offerInfo(base, quote, offerId);\n    return od.maker;\n  }\n}\n\n// Pretest libraries are for deploying large contracts independently.\n// Otherwise bytecode can be too large. See EIP 170 for more on size limit:\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-170.md\n\nlibrary TokenSetup {\n  function setup(string memory name, string memory ticker)\n    public\n    returns (TestToken)\n  {\n    return new TestToken(address(this), name, ticker);\n  }\n}\n\nlibrary MgvSetup {\n  function deploy(address governance) public returns (AbstractMangrove mgv) {\n    mgv = new Mangrove({\n      governance: governance,\n      gasprice: 40,\n      gasmax: 1_000_000\n    });\n  }\n\n  function invertedDeploy(address governance)\n    public\n    returns (AbstractMangrove mgv)\n  {\n    mgv = new InvertedMangrove({\n      governance: governance,\n      gasprice: 40,\n      gasmax: 1_000_000\n    });\n  }\n\n  function setup(TestToken base, TestToken quote)\n    public\n    returns (AbstractMangrove)\n  {\n    return setup(base, quote, false);\n  }\n\n  function setup(\n    TestToken base,\n    TestToken quote,\n    bool inverted\n  ) public returns (AbstractMangrove mgv) {\n    TestUtils.not0x(address(base));\n    TestUtils.not0x(address(quote));\n    if (inverted) {\n      mgv = invertedDeploy(address(this));\n    } else {\n      mgv = deploy(address(this));\n    }\n    mgv.activate(address(base), address(quote), 0, 100, 80_000, 20_000);\n    mgv.activate(address(quote), address(base), 0, 100, 80_000, 20_000);\n  }\n}\n\nlibrary MakerSetup {\n  function setup(\n    AbstractMangrove mgv,\n    address base,\n    address quote,\n    uint failer // 1 shouldFail, 2 shouldRevert\n  ) external returns (TestMaker) {\n    TestMaker tm = new TestMaker(mgv, IERC20(base), IERC20(quote));\n    tm.shouldFail(failer == 1);\n    tm.shouldRevert(failer == 2);\n    return (tm);\n  }\n\n  function setup(\n    AbstractMangrove mgv,\n    address base,\n    address quote\n  ) external returns (TestMaker) {\n    return new TestMaker(mgv, IERC20(base), IERC20(quote));\n  }\n}\n\nlibrary MakerDeployerSetup {\n  function setup(\n    AbstractMangrove mgv,\n    address base,\n    address quote\n  ) external returns (MakerDeployer) {\n    TestUtils.not0x(address(mgv));\n    return (new MakerDeployer(mgv, base, quote));\n  }\n}\n\nlibrary TakerSetup {\n  function setup(\n    AbstractMangrove mgv,\n    address base,\n    address quote\n  ) external returns (TestTaker) {\n    TestUtils.not0x(address(mgv));\n    return new TestTaker(mgv, IERC20(base), IERC20(quote));\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Agents/TestToken.sol": {
      "content": "pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\nimport \"./TestTokenWithDecimals.sol\";\n\ncontract TestToken is TestTokenWithDecimals {\n  constructor(\n    address admin,\n    string memory name,\n    string memory symbol\n  ) TestTokenWithDecimals(admin, name, symbol, 18) {}\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Agents/TestTaker.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\nimport \"../../AbstractMangrove.sol\";\nimport \"./OfferManager.sol\";\n\ncontract TestTaker is ITaker {\n  AbstractMangrove _mgv;\n  address _base;\n  address _quote;\n\n  constructor(\n    AbstractMangrove mgv,\n    IERC20 base,\n    IERC20 quote\n  ) {\n    _mgv = mgv;\n    _base = address(base);\n    _quote = address(quote);\n  }\n\n  receive() external payable {}\n\n  function approveMgv(IERC20 token, uint amount) external {\n    token.approve(address(_mgv), amount);\n  }\n\n  function approveSpender(address spender, uint amount) external {\n    _mgv.approve(_base, _quote, spender, amount);\n  }\n\n  function take(uint offerId, uint takerWants) external returns (bool success) {\n    //uint taken = TestEvents.min(makerGives, takerWants);\n    (success, , ) = this.takeWithInfo(offerId, takerWants);\n  }\n\n  function takeWithInfo(uint offerId, uint takerWants)\n    external\n    returns (\n      bool,\n      uint,\n      uint\n    )\n  {\n    //uint taken = TestEvents.min(makerGives, takerWants);\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [offerId, takerWants, type(uint96).max, type(uint48).max];\n    (uint successes, uint got, uint gave) = _mgv.snipes(\n      _base,\n      _quote,\n      targets,\n      true\n    );\n    return (successes == 1, got, gave);\n    //return taken;\n  }\n\n  function snipe(\n    AbstractMangrove __mgv,\n    address __base,\n    address __quote,\n    uint offerId,\n    uint takerWants,\n    uint takerGives,\n    uint gasreq\n  ) external returns (bool) {\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [offerId, takerWants, takerGives, gasreq];\n    (uint successes, , ) = __mgv.snipes(__base, __quote, targets, true);\n    return successes == 1;\n  }\n\n  function takerTrade(\n    address,\n    address,\n    uint,\n    uint\n  ) external pure override {}\n\n  function marketOrder(uint wants, uint gives) external returns (uint, uint) {\n    return _mgv.marketOrder(_base, _quote, wants, gives, true);\n  }\n\n  function marketOrder(\n    AbstractMangrove __mgv,\n    address __base,\n    address __quote,\n    uint takerWants,\n    uint takerGives\n  ) external returns (uint, uint) {\n    return __mgv.marketOrder(__base, __quote, takerWants, takerGives, true);\n  }\n\n  function marketOrderWithFail(uint wants, uint gives)\n    external\n    returns (uint, uint)\n  {\n    return _mgv.marketOrder(_base, _quote, wants, gives, true);\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Agents/MakerDeployer.sol": {
      "content": "pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\nimport \"../../Mangrove.sol\";\nimport \"./TestMaker.sol\";\nimport \"./TestToken.sol\";\nimport \"hardhat/console.sol\";\n\n//import \"./TestMaker.sol\";\n//import \"./TestToken.sol\";\n\ncontract MakerDeployer {\n  address payable[] makers;\n  bool deployed;\n  AbstractMangrove mgv;\n  address base;\n  address quote;\n\n  constructor(\n    AbstractMangrove _mgv,\n    address _base,\n    address _quote\n  ) {\n    mgv = _mgv;\n    base = _base;\n    quote = _quote;\n  }\n\n  receive() external payable {\n    uint k = makers.length;\n    uint perMaker = msg.value / k;\n    require(perMaker > 0, \"0 ether to transfer\");\n    for (uint i = 0; i < k; i++) {\n      address payable maker = makers[i];\n      bool ok = maker.send(perMaker);\n      require(ok);\n    }\n  }\n\n  function length() external view returns (uint) {\n    return makers.length;\n  }\n\n  function getMaker(uint i) external view returns (TestMaker) {\n    return TestMaker(makers[i]);\n  }\n\n  function deploy(uint k) external {\n    if (!deployed) {\n      makers = new address payable[](k);\n      for (uint i = 0; i < k; i++) {\n        makers[i] = address(new TestMaker(mgv, TestToken(base), TestToken(quote)));\n        TestMaker(makers[i]).approveMgv(TestToken(base), 10 ether);\n        TestMaker(makers[i]).shouldFail(i == 0); //maker-0 is failer\n      }\n    }\n    deployed = true;\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Agents/TestMoriartyMaker.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\nimport \"./Passthrough.sol\";\nimport \"../../AbstractMangrove.sol\";\nimport \"../../MgvLib.sol\";\nimport {MgvPack as MP} from \"../../MgvPack.sol\";\n\ncontract TestMoriartyMaker is IMaker, Passthrough {\n  AbstractMangrove mgv;\n  address base;\n  address quote;\n  bool succeed;\n  uint dummy;\n\n  constructor(\n    AbstractMangrove _mgv,\n    address _base,\n    address _quote\n  ) {\n    mgv = _mgv;\n    base = _base;\n    quote = _quote;\n    succeed = true;\n  }\n\n  function makerExecute(ML.SingleOrder calldata order)\n    public\n    override\n    returns (bytes32 ret)\n  {\n    bool _succeed = succeed;\n    if (order.offerId == dummy) {\n      succeed = false;\n    }\n    if (_succeed) {\n      ret = \"\";\n    } else {\n      assert(false);\n    }\n  }\n\n  function makerPosthook(\n    ML.SingleOrder calldata order,\n    ML.OrderResult calldata result\n  ) external override {}\n\n  function newOffer(\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint pivotId\n  ) public {\n    mgv.newOffer(base, quote, wants, gives, gasreq, 0, pivotId);\n    mgv.newOffer(base, quote, wants, gives, gasreq, 0, pivotId);\n    mgv.newOffer(base, quote, wants, gives, gasreq, 0, pivotId);\n    mgv.newOffer(base, quote, wants, gives, gasreq, 0, pivotId);\n    (, bytes32 cfg) = mgv.config(base, quote);\n    uint density = MP.local_unpack_density(cfg);\n    uint offer_gasbase = MP.local_unpack_offer_gasbase(cfg);\n    dummy = mgv.newOffer({\n      outbound_tkn: base,\n      inbound_tkn: quote,\n      wants: 1,\n      gives: density * (offer_gasbase + 100000),\n      gasreq: 100000,\n      gasprice: 0,\n      pivotId: 0\n    }); //dummy offer\n  }\n\n  function provisionMgv(uint amount) public {\n    (bool success, ) = address(mgv).call{value: amount}(\"\");\n    require(success);\n  }\n\n  function approveMgv(IERC20 token, uint amount) public {\n    token.approve(address(mgv), amount);\n  }\n\n  receive() external payable {}\n}\n"
    },
    "@giry/hardhat-test-solidity/test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\n// Should be kept in sync with ./lib.js\n\nlibrary Test {\n  /* \n   * Expect events from contracts\n   */\n  event ExpectFrom(address from);\n\n  // Usage: from a test contract `t`, call `expectFrom(a)`. \n  // Any subsequent non-special event emitted by `t` will mean \n  // \"I expect `a` to emit the exact same event\". \n  // The order of expectations must be respected.\n  function expectFrom(address from) internal {\n    emit ExpectFrom(from);\n  }\n\n\n  /* \n   * Boolean test\n   */\n  event TestTrue(bool success, string message);\n\n  // Succeed iff success is true\n  function check(bool success, string memory message) internal {\n    emit TestTrue(success, message);\n  }\n\n\n  /* \n   * Always fail, always succeed\n   */\n  function fail(string memory message) internal {\n    emit TestTrue(false, message);\n  }\n\n  function succeed() internal {\n    emit TestTrue(true, \"Success\");\n  }\n\n  /* \n   * Equality testing\n   * ! overloaded as `eq` for everything except for bytes use `eq0`.\n   */\n\n  // Bytes\n  event TestEqBytes(bool success, bytes actual, bytes expected, string message);\n\n  function eq0(\n    bytes memory actual,\n    bytes memory expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = keccak256((actual)) == keccak256((expected));\n    emit TestEqBytes(success, actual, expected, message);\n    return success;\n  }\n\n   // Byte32\n  event TestEqBytes32(\n    bool success,\n    bytes32 actual,\n    bytes32 expected,\n    string message\n  );\n\n  function eq(\n    bytes32 actual,\n    bytes32 expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = (actual == expected);\n    emit TestEqBytes32(success, actual, expected, message);\n    return success;\n  }\n\n  // Bool\n  event TestEqBool(bool success, bool actual, bool expected, string message);\n  function eq(\n    bool actual,\n    bool expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = (actual == expected);\n    emit TestEqBool(success, actual, expected, message);\n    return success;\n  }\n\n  // uints\n  event TestEqUint(bool success, uint actual, uint expected, string message);\n\n  function eq(\n    uint actual,\n    uint expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual == expected;\n    emit TestEqUint(success, actual, expected, message);\n    return success;\n  }\n\n  // strings\n  event TestEqString(\n    bool success,\n    string actual,\n    string expected,\n    string message\n  );\n\n  function eq(\n    string memory actual,\n    string memory expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = keccak256(bytes((actual))) == keccak256(bytes((expected)));\n    emit TestEqString(success, actual, expected, message);\n    return success;\n  }\n\n  // addresses\n  event TestEqAddress(\n    bool success,\n    address actual,\n    address expected,\n    string message\n  );\n\n\n  function eq(\n    address actual,\n    address expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual == expected;\n    emit TestEqAddress(success, actual, expected, message);\n    return success;\n  }\n\n  /* \n   * Inequality testing\n   */\n  event TestLess(bool success, uint actual, uint expected, string message);\n  function less(\n    uint actual,\n    uint expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual < expected;\n    emit TestLess(success, actual, expected, message);\n    return success;\n  }\n\n  function more(\n    uint actual,\n    uint expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual > expected;\n    emit TestLess(success, actual, expected, message);\n    return success;\n  }\n}\n\n// /* Either cast your arguments to address when you call balanceOf logging functions\n//    or add `is address` to your ERC20s\n//    or use the overloads with `address` types */\ninterface ERC20BalanceOf {\n  function balanceOf(address account) view external returns (uint);\n}\n\n\nlibrary Display {\n  /* ****************************************************************\n   * Register/read address->name mappings to make logs easier to read.\n   *****************************************************************/\n  /* \n   * Names are stored in the contract using the library.\n   */\n\n  // Disgusting hack so a library can manipulate storage refs.\n  bytes32 constant NAMES_POS = keccak256(\"Display.NAMES_POS\");\n  // Store mapping in library caller's storage.\n  // That's quite fragile.\n  struct Registers {\n    mapping(address => string) map;\n  }\n\n  // Also send mapping to javascript test interpreter.  The interpreter COULD\n  // just make an EVM call to map every name but that would probably be very\n  // slow.  So we cache locally.\n  event Register(address addr, string name);\n\n  function registers() internal view returns (Registers storage) {\n    this; // silence warning about pure mutability\n    Registers storage regs;\n    bytes32 _slot = NAMES_POS;\n    assembly {\n      regs.slot := _slot\n    }\n    return regs;\n  }\n\n  /*\n   * Give a name to an address for logging purposes\n   * @example\n   * ```solidity\n   * address addr = address(new Contract());\n   * register(addr,\"My Contract instance\");\n   * ```\n   */\n\n  function register(address addr, string memory name) internal {\n    registers().map[addr] = name;\n    emit Register(addr, name);\n  }\n\n  /*\n   * Read the name of a registered address. Default: \"<not found>\". \n   */\n  function nameOf(address addr) internal view returns (string memory) {\n    string memory s = registers().map[addr];\n    if (keccak256(bytes(s)) != keccak256(bytes(\"\"))) {\n      return s;\n    } else {\n      return \"<not found>\";\n    }\n  }\n\n  /* 1 arg logging (string/uint) */\n\n  event LogString(string a);\n\n  function log(string memory a) internal {\n    emit LogString(a);\n  }\n\n  event LogUint(uint a);\n\n  function log(uint a) internal {\n    emit LogUint(a);\n  }\n\n  /* 2 arg logging (string/uint) */\n\n  event LogStringString(string a, string b);\n\n  function log(string memory a, string memory b) internal {\n    emit LogStringString(a, b);\n  }\n\n  event LogStringUint(string a, uint b);\n\n  function log(string memory a, uint b) internal {\n    emit LogStringUint(a, b);\n  }\n\n  event LogUintUint(uint a, uint b);\n\n  function log(uint a, uint b) internal {\n    emit LogUintUint(a, b);\n  }\n\n  event LogUintString(uint a, string b);\n\n  function log(uint a, string memory b) internal {\n    emit LogUintString(a, b);\n  }\n\n  /* 3 arg logging (string/uint) */\n\n  event LogStringStringString(string a, string b, string c);\n\n  function log(\n    string memory a,\n    string memory b,\n    string memory c\n  ) internal {\n    emit LogStringStringString(a, b, c);\n  }\n\n  event LogStringStringUint(string a, string b, uint c);\n\n  function log(\n    string memory a,\n    string memory b,\n    uint c\n  ) internal {\n    emit LogStringStringUint(a, b, c);\n  }\n\n  event LogStringUintUint(string a, uint b, uint c);\n\n  function log(\n    string memory a,\n    uint b,\n    uint c\n  ) internal {\n    emit LogStringUintUint(a, b, c);\n  }\n\n  event LogStringUintString(string a, uint b, string c);\n\n  function log(\n    string memory a,\n    uint b,\n    string memory c\n  ) internal {\n    emit LogStringUintString(a, b, c);\n  }\n\n  event LogUintUintUint(uint a, uint b, uint c);\n\n  function log(\n    uint a,\n    uint b,\n    uint c\n  ) internal {\n    emit LogUintUintUint(a, b, c);\n  }\n\n  event LogUintStringUint(uint a, string b, uint c);\n\n  function log(\n    uint a,\n    string memory b,\n    uint c\n  ) internal {\n    emit LogUintStringUint(a, b, c);\n  }\n\n  event LogUintStringString(uint a, string b, string c);\n\n  function log(\n    uint a,\n    string memory b,\n    string memory c\n  ) internal {\n    emit LogUintStringString(a, b, c);\n  }\n\n  /* End of register/read section */\n  event ERC20Balances(address[] tokens, address[] accounts, uint[] balances);\n\n  function logBalances(\n    address[1] memory _tokens, \n    address _a0\n  ) internal {\n    address[] memory tokens = new address[](1);\n    tokens[0] = _tokens[0];\n    address[] memory accounts = new address[](1);\n    accounts[0] = _a0;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[1] memory _tokens,\n    address _a0,\n    address _a1\n  ) internal {\n    address[] memory tokens = new address[](1);\n    tokens[0] = _tokens[0];\n    address[] memory accounts = new address[](2);\n    accounts[0] = _a0;\n    accounts[1] = _a1;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[1] memory _tokens,\n    address _a0,\n    address _a1,\n    address _a2\n  ) internal {\n    address[] memory tokens = new address[](1);\n    tokens[0] = _tokens[0];\n    address[] memory accounts = new address[](3);\n    accounts[0] = _a0;\n    accounts[1] = _a1;\n    accounts[2] = _a2;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[2] memory _tokens,\n    address _a0\n  ) internal {\n    address[] memory tokens = new address[](2);\n    tokens[0] = _tokens[0];\n    tokens[1] = _tokens[1];\n    address[] memory accounts = new address[](1);\n    accounts[0] = _a0;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[2] memory _tokens,\n    address _a0,\n    address _a1\n  ) internal {\n    address[] memory tokens = new address[](2);\n    tokens[0] = _tokens[0];\n    tokens[1] = _tokens[1];\n    address[] memory accounts = new address[](2);\n    accounts[0] = _a0;\n    accounts[1] = _a1;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[2] memory _tokens,\n    address _a0,\n    address _a1,\n    address _a2\n  ) internal {\n    address[] memory tokens = new address[](2);\n    tokens[0] = _tokens[0];\n    tokens[1] = _tokens[1];\n    address[] memory accounts = new address[](3);\n    accounts[0] = _a0;\n    accounts[1] = _a1;\n    accounts[2] = _a2;\n    logBalances(tokens, accounts);\n  }\n\n  /* takes [t1,...,tM], [a1,...,aN]\n       logs also [...b(t1,aj) ... b(tM,aj) ...] */\n\n  function logBalances(address[] memory tokens, address[] memory accounts)\n    internal\n  {\n    uint[] memory balances = new uint[](tokens.length * accounts.length);\n    for (uint i = 0; i < tokens.length; i++) {\n      for (uint j = 0; j < accounts.length; j++) {\n        uint bal = ERC20BalanceOf(tokens[i]).balanceOf(accounts[j]);\n        balances[i * accounts.length + j] = bal;\n        //console.log(tokens[i].symbol(),nameOf(accounts[j]),bal);\n      }\n    }\n    emit ERC20Balances(tokens, accounts, balances);\n  }\n\n}"
    },
    "cache/solpp-generated-contracts/InvertedMangrove.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n// InvertedMangrove.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n\nimport {ITaker, MgvLib as ML} from \"./MgvLib.sol\";\n\nimport {AbstractMangrove} from \"./AbstractMangrove.sol\";\nimport {MgvPack as MP} from \"./MgvPack.sol\";\n\n/* <a id=\"InvertedMangrove\"></a> The `InvertedMangrove` contract implements the \"inverted\" version of Mangrove, where each maker loans money to the taker. The taker is then called, and finally each maker is sent its payment and called again (with the orderbook unlocked). */\ncontract InvertedMangrove is AbstractMangrove {\n  constructor(\n    address governance,\n    uint gasprice,\n    uint gasmax\n  ) AbstractMangrove(governance, gasprice, gasmax, \"InvertedMangrove\") {}\n\n  // execute taker trade\n  function executeEnd(MultiOrder memory mor, ML.SingleOrder memory sor)\n    internal\n    override\n  {\n    ITaker(mor.taker).takerTrade(\n      sor.outbound_tkn,\n      sor.inbound_tkn,\n      mor.totalGot,\n      mor.totalGave\n    );\n    bool success = transferTokenFrom(\n      sor.inbound_tkn,\n      mor.taker,\n      address(this),\n      mor.totalGave\n    );\n    require(success, \"mgv/takerFailToPayTotal\");\n  }\n\n  /* We use `transferFrom` with takers (instead of checking `balanceOf` before/after the call) for the following reason we want the taker to be awaken after all loans have been made, so either\n     1. The taker gets a list of all makers and loops through them to pay back, or\n     2. we call a new taker method \"payback\" after returning from each maker call, or\n     3. we call transferFrom after returning from each maker call\n\nSo :\n   1. Would mean accumulating a list of all makers, which would make the market order code too complex\n   2. Is OK, but has an extra CALL cost on top of the token transfer, one for each maker. This is unavoidable anyway when calling makerExecute (since the maker must be able to execute arbitrary code at that moment), but we can skip it here.\n   3. Is the cheapest, but it has the drawbacks of `transferFrom`: money must end up owned by the taker, and taker needs to `approve` Mangrove\n   */\n  function beforePosthook(ML.SingleOrder memory sor) internal override {\n    /* If `transferToken` returns false here, we're in a special (and bad) situation. The taker is returning part of their total loan to a maker, but the maker can't receive the tokens. Only case we can see: maker is blacklisted. In that case, we send the tokens to the vault, so things have a chance of getting sorted out later (Mangrove is a token black hole). */\n    if (\n      !transferToken(\n        sor.inbound_tkn,\n        MP.offerDetail_unpack_maker(sor.offerDetail),\n        sor.gives\n      )\n    ) {\n      /* If that transfer fails there's nothing we can do -- reverting would punish the taker for the maker's blacklisting. */\n      transferToken(sor.inbound_tkn, vault, sor.gives);\n    }\n  }\n\n  /* # Flashloans */\n  //+clear+\n  /* ## Inverted Flashloan */\n  /*\n     `invertedFlashloan` is for the 'arbitrage' mode of operation. It:\n     0. Calls the maker's `execute` function. If successful (tokens have been sent to taker):\n     2. Runs `taker`'s `execute` function.\n     4. Returns the results ofthe operations, with optional makerData to help the maker debug.\n\n     There are two ways to do the flashloan:\n     1. balanceOf before/after\n     2. run transferFrom ourselves.\n\n     ### balanceOf pros:\n       * maker may `transferFrom` another address they control; saves gas compared to Mangrove's `transferFrom`\n       * maker does not need to `approve` Mangrove\n\n     ### balanceOf cons\n       * if the ERC20 transfer method has a callback to receiver, the method does not work (the receiver can set its balance to 0 during the callback)\n       * if the taker is malicious, they can analyze the maker code. If the maker goes on any Mangrove2, they may execute code provided by the taker. This would reduce the taker balance and make the maker fail. So the taker could steal the maker's balance.\n\n    We choose `transferFrom`.\n    */\n\n  function flashloan(ML.SingleOrder calldata sor, address)\n    external\n    override\n    returns (uint gasused)\n  {\n    /* `invertedFlashloan` must be used with a call (hence the `external` modifier) so its effect can be reverted. But a call from the outside would be fatal. */\n    require(msg.sender == address(this), \"mgv/invertedFlashloan/protected\");\n    gasused = makerExecute(sor);\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Mangrove.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n// Mangrove.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n\nimport {MgvLib as ML} from \"./MgvLib.sol\";\n\nimport {AbstractMangrove} from \"./AbstractMangrove.sol\";\n\n/* <a id=\"Mangrove\"></a> The `Mangrove` contract implements the \"normal\" version of Mangrove, where the taker flashloans the desired amount to each maker. Each time, makers are called after the loan. When the order is complete, each maker is called once again (with the orderbook unlocked). */\ncontract Mangrove is AbstractMangrove {\n  constructor(\n    address governance,\n    uint gasprice,\n    uint gasmax\n  ) AbstractMangrove(governance, gasprice, gasmax, \"Mangrove\") {}\n\n  function executeEnd(MultiOrder memory mor, ML.SingleOrder memory sor)\n    internal\n    override\n  {}\n\n  function beforePosthook(ML.SingleOrder memory sor) internal override {}\n\n  /* ## Flashloan */\n  /*\n     `flashloan` is for the 'normal' mode of operation. It:\n     1. Flashloans `takerGives` `inbound_tkn` from the taker to the maker and returns false if the loan fails.\n     2. Runs `offerDetail.maker`'s `execute` function.\n     3. Returns the result of the operations, with optional makerData to help the maker debug.\n   */\n  function flashloan(ML.SingleOrder calldata sor, address taker)\n    external\n    override\n    returns (uint gasused)\n  {\n    /* `flashloan` must be used with a call (hence the `external` modifier) so its effect can be reverted. But a call from the outside would be fatal. */\n    require(msg.sender == address(this), \"mgv/flashloan/protected\");\n    /* The transfer taker -> maker is in 2 steps. First, taker->mgv. Then\n       mgv->maker. With a direct taker->maker transfer, if one of taker/maker\n       is blacklisted, we can't tell which one. We need to know which one:\n       if we incorrectly blame the taker, a blacklisted maker can block a pair forever; if we incorrectly blame the maker, a blacklisted taker can unfairly make makers fail all the time. Of course we assume the Mangrove is not blacklisted. Also note that this setup doesn't not work well with tokens that take fees or recompute balances at transfer time. */\n    if (transferTokenFrom(sor.inbound_tkn, taker, address(this), sor.gives)) {\n      if (\n        transferToken(\n          sor.inbound_tkn,\n          address(uint((sor.offerDetail << 0)) >> 96),\n          sor.gives\n        )\n      ) {\n        gasused = makerExecute(sor);\n      } else {\n        innerRevert([bytes32(\"mgv/makerReceiveFail\"), bytes32(0), \"\"]);\n      }\n    } else {\n      innerRevert([bytes32(\"mgv/takerTransferFail\"), \"\", \"\"]);\n    }\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/MgvPack.sol": {
      "content": "pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier: Unlicense\n\n// MgvPack.sol\n\n// This is free and unencumbered software released into the public domain.\n\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.\n\n// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For more information, please refer to <https://unlicense.org/>\n\n\n\nlibrary MgvPack {\n\n  // fields are of the form [name,bits,type]\n\n\n  \n\n  \n\n  function offer_pack(uint __prev, uint __next, uint __wants, uint __gives, uint __gasprice) internal pure returns (bytes32) {\n    return (((((bytes32(0) | bytes32((uint(__prev) << 232) >> 0)) | bytes32((uint(__next) << 232) >> 24)) | bytes32((uint(__wants) << 160) >> 48)) | bytes32((uint(__gives) << 160) >> 144)) | bytes32((uint(__gasprice) << 240) >> 240));\n  }\n\n  function offer_unpack(bytes32 __packed) internal pure returns (uint __prev, uint __next, uint __wants, uint __gives, uint __gasprice) {\n    __prev = uint(uint((__packed << 0)) >> 232);\n    __next = uint(uint((__packed << 24)) >> 232);\n    __wants = uint(uint((__packed << 48)) >> 160);\n    __gives = uint(uint((__packed << 144)) >> 160);\n    __gasprice = uint(uint((__packed << 240)) >> 240);\n  }\n\n  function offer_unpack_prev(bytes32 __packed) internal pure returns(uint) {\n    return uint(uint((__packed << 0)) >> 232);\n  }\n  function offer_unpack_next(bytes32 __packed) internal pure returns(uint) {\n    return uint(uint((__packed << 24)) >> 232);\n  }\n  function offer_unpack_wants(bytes32 __packed) internal pure returns(uint) {\n    return uint(uint((__packed << 48)) >> 160);\n  }\n  function offer_unpack_gives(bytes32 __packed) internal pure returns(uint) {\n    return uint(uint((__packed << 144)) >> 160);\n  }\n  function offer_unpack_gasprice(bytes32 __packed) internal pure returns(uint) {\n    return uint(uint((__packed << 240)) >> 240);\n  }\n\n\n  \n\n  \n\n  function offerDetail_pack(address __maker, uint __gasreq, uint __overhead_gasbase, uint __offer_gasbase) internal pure returns (bytes32) {\n    return ((((bytes32(0) | bytes32((uint(__maker) << 96) >> 0)) | bytes32((uint(__gasreq) << 232) >> 160)) | bytes32((uint(__overhead_gasbase) << 232) >> 184)) | bytes32((uint(__offer_gasbase) << 232) >> 208));\n  }\n\n  function offerDetail_unpack(bytes32 __packed) internal pure returns (address __maker, uint __gasreq, uint __overhead_gasbase, uint __offer_gasbase) {\n    __maker = address(uint((__packed << 0)) >> 96);\n    __gasreq = uint(uint((__packed << 160)) >> 232);\n    __overhead_gasbase = uint(uint((__packed << 184)) >> 232);\n    __offer_gasbase = uint(uint((__packed << 208)) >> 232);\n  }\n\n  function offerDetail_unpack_maker(bytes32 __packed) internal pure returns(address) {\n    return address(uint((__packed << 0)) >> 96);\n  }\n  function offerDetail_unpack_gasreq(bytes32 __packed) internal pure returns(uint) {\n    return uint(uint((__packed << 160)) >> 232);\n  }\n  function offerDetail_unpack_overhead_gasbase(bytes32 __packed) internal pure returns(uint) {\n    return uint(uint((__packed << 184)) >> 232);\n  }\n  function offerDetail_unpack_offer_gasbase(bytes32 __packed) internal pure returns(uint) {\n    return uint(uint((__packed << 208)) >> 232);\n  }\n\n\n  \n\n  \n\n  function global_pack(address __monitor, uint __useOracle, uint __notify, uint __gasprice, uint __gasmax, uint __dead) internal pure returns (bytes32) {\n    return ((((((bytes32(0) | bytes32((uint(__monitor) << 96) >> 0)) | bytes32((uint(__useOracle) << 248) >> 160)) | bytes32((uint(__notify) << 248) >> 168)) | bytes32((uint(__gasprice) << 240) >> 176)) | bytes32((uint(__gasmax) << 232) >> 192)) | bytes32((uint(__dead) << 248) >> 216));\n  }\n\n  function global_unpack(bytes32 __packed) internal pure returns (address __monitor, uint __useOracle, uint __notify, uint __gasprice, uint __gasmax, uint __dead) {\n    __monitor = address(uint((__packed << 0)) >> 96);\n    __useOracle = uint(uint((__packed << 160)) >> 248);\n    __notify = uint(uint((__packed << 168)) >> 248);\n    __gasprice = uint(uint((__packed << 176)) >> 240);\n    __gasmax = uint(uint((__packed << 192)) >> 232);\n    __dead = uint(uint((__packed << 216)) >> 248);\n  }\n\n  function global_unpack_monitor(bytes32 __packed) internal pure returns(address) {\n    return address(uint((__packed << 0)) >> 96);\n  }\n  function global_unpack_useOracle(bytes32 __packed) internal pure returns(uint) {\n    return uint(uint((__packed << 160)) >> 248);\n  }\n  function global_unpack_notify(bytes32 __packed) internal pure returns(uint) {\n    return uint(uint((__packed << 168)) >> 248);\n  }\n  function global_unpack_gasprice(bytes32 __packed) internal pure returns(uint) {\n    return uint(uint((__packed << 176)) >> 240);\n  }\n  function global_unpack_gasmax(bytes32 __packed) internal pure returns(uint) {\n    return uint(uint((__packed << 192)) >> 232);\n  }\n  function global_unpack_dead(bytes32 __packed) internal pure returns(uint) {\n    return uint(uint((__packed << 216)) >> 248);\n  }\n\n\n  \n\n  \n\n  function local_pack(uint __active, uint __fee, uint __density, uint __overhead_gasbase, uint __offer_gasbase, uint __lock, uint __best, uint __last) internal pure returns (bytes32) {\n    return ((((((((bytes32(0) | bytes32((uint(__active) << 248) >> 0)) | bytes32((uint(__fee) << 240) >> 8)) | bytes32((uint(__density) << 224) >> 24)) | bytes32((uint(__overhead_gasbase) << 232) >> 56)) | bytes32((uint(__offer_gasbase) << 232) >> 80)) | bytes32((uint(__lock) << 248) >> 104)) | bytes32((uint(__best) << 232) >> 112)) | bytes32((uint(__last) << 232) >> 136));\n  }\n\n  function local_unpack(bytes32 __packed) internal pure returns (uint __active, uint __fee, uint __density, uint __overhead_gasbase, uint __offer_gasbase, uint __lock, uint __best, uint __last) {\n    __active = uint(uint((__packed << 0)) >> 248);\n    __fee = uint(uint((__packed << 8)) >> 240);\n    __density = uint(uint((__packed << 24)) >> 224);\n    __overhead_gasbase = uint(uint((__packed << 56)) >> 232);\n    __offer_gasbase = uint(uint((__packed << 80)) >> 232);\n    __lock = uint(uint((__packed << 104)) >> 248);\n    __best = uint(uint((__packed << 112)) >> 232);\n    __last = uint(uint((__packed << 136)) >> 232);\n  }\n\n  function local_unpack_active(bytes32 __packed) internal pure returns(uint) {\n    return uint(uint((__packed << 0)) >> 248);\n  }\n  function local_unpack_fee(bytes32 __packed) internal pure returns(uint) {\n    return uint(uint((__packed << 8)) >> 240);\n  }\n  function local_unpack_density(bytes32 __packed) internal pure returns(uint) {\n    return uint(uint((__packed << 24)) >> 224);\n  }\n  function local_unpack_overhead_gasbase(bytes32 __packed) internal pure returns(uint) {\n    return uint(uint((__packed << 56)) >> 232);\n  }\n  function local_unpack_offer_gasbase(bytes32 __packed) internal pure returns(uint) {\n    return uint(uint((__packed << 80)) >> 232);\n  }\n  function local_unpack_lock(bytes32 __packed) internal pure returns(uint) {\n    return uint(uint((__packed << 104)) >> 248);\n  }\n  function local_unpack_best(bytes32 __packed) internal pure returns(uint) {\n    return uint(uint((__packed << 112)) >> 232);\n  }\n  function local_unpack_last(bytes32 __packed) internal pure returns(uint) {\n    return uint(uint((__packed << 136)) >> 232);\n  }\n\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Agents/OfferManager.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\nimport \"../../AbstractMangrove.sol\";\n//import \"../../MgvLib.sol\";\nimport {IERC20, IMaker, ITaker, MgvLib as ML, HasMgvEvents, IMgvMonitor} from \"../../MgvLib.sol\";\nimport {MgvPack as MP} from \"../../MgvPack.sol\";\nimport \"hardhat/console.sol\";\n\ncontract OfferManager is IMaker, ITaker {\n  // erc_addr -> owner_addr -> balance\n  AbstractMangrove mgv;\n  AbstractMangrove invMgv;\n  address caller_id;\n  // mgv_addr -> base_addr -> quote_addr -> offerId -> owner\n  mapping(address => mapping(address => mapping(address => mapping(uint => address)))) owners;\n  uint constant gas_to_execute = 100_000;\n\n  constructor(AbstractMangrove _mgv, AbstractMangrove _inverted) {\n    mgv = _mgv;\n    invMgv = _inverted;\n  }\n\n  //posthook data:\n  //outbound_tkn: orp.outbound_tkn,\n  // inbound_tkn: orp.inbound_tkn,\n  // takerWants: takerWants,\n  // takerGives: takerGives,\n  // offerId: offerId,\n  // offerDeleted: toDelete\n\n  function takerTrade(\n    //NB this is not called if mgv is not a flashTaker mgv\n    address base,\n    address quote,\n    uint netReceived,\n    uint shouldGive\n  ) external override {\n    if (msg.sender == address(invMgv)) {\n      ITaker(caller_id).takerTrade(base, quote, netReceived, shouldGive); // taker will find funds\n      IERC20(quote).transferFrom(caller_id, address(this), shouldGive); // ready to be withdawn by Mangrove\n    }\n  }\n\n  function makerPosthook(\n    ML.SingleOrder calldata _order,\n    ML.OrderResult calldata\n  ) external override {\n    if (msg.sender == address(invMgv)) {\n      //should have received funds by now\n      address owner = owners[msg.sender][_order.outbound_tkn][\n        _order.inbound_tkn\n      ][_order.offerId];\n      require(owner != address(0), \"Unkown owner\");\n      IERC20(_order.inbound_tkn).transfer(owner, _order.gives);\n    }\n  }\n\n  // Maker side execute for residual offer\n  event Execute(\n    address mgv,\n    address base,\n    address quote,\n    uint offerId,\n    uint takerWants,\n    uint takerGives\n  );\n\n  function makerExecute(ML.SingleOrder calldata _order)\n    external\n    override\n    returns (bytes32 ret)\n  {\n    emit Execute(\n      msg.sender,\n      _order.outbound_tkn,\n      _order.inbound_tkn,\n      _order.offerId,\n      _order.wants,\n      _order.gives\n    );\n    bool inverted;\n    address MGV;\n    if (msg.sender == address(mgv)) {\n      MGV = address(mgv);\n    }\n    if (msg.sender == address(invMgv)) {\n      MGV = address(invMgv);\n      inverted = true;\n    }\n    require(MGV != address(0), \"Unauth call\");\n    // if residual of offerId is < dust, offer will be removed and dust lost\n    // also freeWeil[this] will increase, offerManager may chose to give it back to owner\n    address owner = owners[address(MGV)][_order.outbound_tkn][\n      _order.inbound_tkn\n    ][_order.offerId];\n    console.log(owner);\n    if (owner == address(0)) {\n      ret = \"mgvOffer/unknownOwner\";\n    }\n    if (!inverted) {\n      try IERC20(_order.inbound_tkn).transfer(owner, _order.gives) {\n        console.log(\"Success\");\n        ret = \"\";\n      } catch Error(string memory message) {\n        console.log(message);\n        ret = \"mgvOffer/transferToOwnerFail\";\n      }\n    } else {\n      ret = \"\";\n    }\n  }\n\n  //marketOrder (base,quote) + NewOffer(quote,base)\n  function order(\n    AbstractMangrove MGV,\n    address base,\n    address quote,\n    uint wants,\n    uint gives,\n    bool invertedResidual\n  ) external payable {\n    bool flashTaker = (address(MGV) == address(invMgv));\n    caller_id = msg.sender; // this should come with a reentrancy lock\n    if (!flashTaker) {\n      // else caller_id will be called when takerTrade is called by Mangrove\n      IERC20(quote).transferFrom(msg.sender, address(this), gives); // OfferManager must be approved by sender\n    }\n    IERC20(quote).approve(address(MGV), 100 ether); // to pay maker\n    IERC20(base).approve(address(MGV), 100 ether); // takerfee\n\n    (uint netReceived, ) = MGV.marketOrder(base, quote, wants, gives, true); // OfferManager might collect provisions of failing offers\n\n    try IERC20(base).transfer(msg.sender, netReceived) {\n      uint residual_w = wants - netReceived;\n      uint residual_g = (gives * residual_w) / wants;\n\n      AbstractMangrove _MGV;\n      if (invertedResidual) {\n        _MGV = invMgv;\n      } else {\n        _MGV = mgv;\n      }\n      (bytes32 config, ) = _MGV.config(base, quote);\n      require(\n        msg.value >=\n          gas_to_execute * uint(MP.global_unpack_gasprice(config)) * 10**9,\n        \"Insufficent funds to delegate order\"\n      ); //not checking overflow issues\n      (bool success, ) = address(_MGV).call{value: msg.value}(\"\");\n      require(success, \"provision mgv failed\");\n      uint residual_ofr = _MGV.newOffer(\n        quote,\n        base,\n        residual_w,\n        residual_g,\n        gas_to_execute,\n        0,\n        0\n      );\n      owners[address(_MGV)][quote][base][residual_ofr] = msg.sender;\n    } catch {\n      require(false, \"Failed to send market order money to owner\");\n    }\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Agents/TestMaker.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\nimport \"./Passthrough.sol\";\nimport \"../../AbstractMangrove.sol\";\nimport \"../../MgvPack.sol\";\nimport \"hardhat/console.sol\";\nimport {IERC20, IMaker} from \"../../MgvLib.sol\";\nimport {Test as TestEvents} from \"@giry/hardhat-test-solidity/test.sol\";\n\ncontract TestMaker is IMaker, Passthrough {\n  AbstractMangrove _mgv;\n  address _base;\n  address _quote;\n  bool _shouldFail; // will set mgv allowance to 0\n  bool _shouldAbort; // will not return bytes32(\"\")\n  bool _shouldRevert; // will revert\n  bytes32 _expectedStatus;\n\n  constructor(\n    AbstractMangrove mgv,\n    IERC20 base,\n    IERC20 quote\n  ) {\n    _mgv = mgv;\n    _base = address(base);\n    _quote = address(quote);\n  }\n\n  receive() external payable {}\n\n  event Execute(\n    address mgv,\n    address base,\n    address quote,\n    uint offerId,\n    uint takerWants,\n    uint takerGives\n  );\n\n  function logExecute(\n    address mgv,\n    address base,\n    address quote,\n    uint offerId,\n    uint takerWants,\n    uint takerGives\n  ) external {\n    emit Execute(mgv, base, quote, offerId, takerWants, takerGives);\n  }\n\n  function shouldRevert(bool should) external {\n    _shouldRevert = should;\n  }\n\n  function shouldFail(bool should) external {\n    _shouldFail = should;\n  }\n\n  function shouldAbort(bool should) external {\n    _shouldAbort = should;\n  }\n\n  function approveMgv(IERC20 token, uint amount) public {\n    token.approve(address(_mgv), amount);\n  }\n\n  function expect(bytes32 mgvData) external {\n    _expectedStatus = mgvData;\n  }\n\n  function transferToken(\n    IERC20 token,\n    address to,\n    uint amount\n  ) external {\n    token.transfer(to, amount);\n  }\n\n  function makerExecute(ML.SingleOrder calldata order)\n    public\n    virtual\n    override\n    returns (bytes32)\n  {\n    if (_shouldRevert) {\n      bytes32[1] memory revert_msg = [bytes32(\"testMaker/revert\")];\n      assembly {\n        revert(revert_msg, 32)\n      }\n    }\n    emit Execute(\n      msg.sender,\n      order.outbound_tkn,\n      order.inbound_tkn,\n      order.offerId,\n      order.wants,\n      order.gives\n    );\n    if (_shouldFail) {\n      IERC20(order.outbound_tkn).approve(address(_mgv), 0);\n      // bytes32[1] memory refuse_msg = [bytes32(\"testMaker/transferFail\")];\n      // assembly {\n      //   return(refuse_msg, 32)\n      // }\n      //revert(\"testMaker/fail\");\n    }\n    if (_shouldAbort) {\n      return \"abort\";\n    } else {\n      return \"\";\n    }\n  }\n\n  bool _shouldFailHook;\n\n  function setShouldFailHook(bool should) external {\n    _shouldFailHook = should;\n  }\n\n  function makerPosthook(\n    ML.SingleOrder calldata order,\n    ML.OrderResult calldata result\n  ) external virtual override {\n    order; //shh\n    if (_shouldFailHook) {\n      bytes32[1] memory refuse_msg = [bytes32(\"posthookFail\")];\n      assembly {\n        revert(refuse_msg, 32)\n      }\n    }\n\n    if (_expectedStatus != bytes32(\"\")) {\n      TestEvents.eq(\n        result.mgvData,\n        _expectedStatus,\n        \"Incorrect status message\"\n      );\n    }\n  }\n\n  function newOffer(\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint pivotId\n  ) public returns (uint) {\n    return (_mgv.newOffer(_base, _quote, wants, gives, gasreq, 0, pivotId));\n  }\n\n  function newOffer(\n    address base,\n    address quote,\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint pivotId\n  ) public returns (uint) {\n    return (_mgv.newOffer(base, quote, wants, gives, gasreq, 0, pivotId));\n  }\n\n  function newOffer(\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint gasprice,\n    uint pivotId\n  ) public returns (uint) {\n    return (\n      _mgv.newOffer(_base, _quote, wants, gives, gasreq, gasprice, pivotId)\n    );\n  }\n\n  function updateOffer(\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint pivotId,\n    uint offerId\n  ) public {\n    _mgv.updateOffer(_base, _quote, wants, gives, gasreq, 0, pivotId, offerId);\n  }\n\n  function retractOffer(uint offerId) public {\n    _mgv.retractOffer(_base, _quote, offerId, false);\n  }\n\n  function retractOfferWithDeprovision(uint offerId) public {\n    _mgv.retractOffer(_base, _quote, offerId, true);\n  }\n\n  function provisionMgv(uint amount) public {\n    _mgv.fund{value: amount}(address(this));\n  }\n\n  function withdrawMgv(uint amount) public returns (bool) {\n    return _mgv.withdraw(amount);\n  }\n\n  function freeWei() public view returns (uint) {\n    return _mgv.balanceOf(address(this));\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Agents/Passthrough.sol": {
      "content": "pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\n/* \n  Experimental contract to simulate an EOA which can call arbitrary functions.\n  How to use :\n  \n  p = new Passthrough();\n  p.calls(<address>,Contract.function.selector,arg1,...argN);\n*/\n\ncontract Passthrough {\n  function calls(\n    address addr,\n    bytes4 signature,\n    uint arg1\n  ) public returns (bool, bytes memory) {\n    return addr.call(abi.encodeWithSelector(signature, arg1));\n  }\n\n  function calls(\n    address addr,\n    bytes4 signature,\n    uint arg1,\n    uint arg2\n  ) public returns (bool, bytes memory) {\n    return addr.call(abi.encodeWithSelector(signature, arg1, arg2));\n  }\n\n  function calls(\n    address addr,\n    bytes4 signature,\n    uint arg1,\n    uint arg2,\n    uint arg3\n  ) public returns (bool, bytes memory) {\n    return addr.call(abi.encodeWithSelector(signature, arg1, arg2, arg3));\n  }\n\n  function calls(\n    address addr,\n    bytes4 signature,\n    uint arg1,\n    uint arg2,\n    uint arg3,\n    uint arg4\n  ) public returns (bool, bytes memory) {\n    return addr.call(abi.encodeWithSelector(signature, arg1, arg2, arg3, arg4));\n  }\n\n  function calls(\n    address addr,\n    bytes4 signature,\n    address arg1\n  ) public returns (bool, bytes memory) {\n    return addr.call(abi.encodeWithSelector(signature, arg1));\n  }\n\n  function calls(\n    address addr,\n    bytes4 signature,\n    string memory arg1\n  ) public returns (bool, bytes memory) {\n    return addr.call(abi.encodeWithSelector(signature, arg1));\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Agents/TestTokenWithDecimals.sol": {
      "content": "pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\nimport \"../ERC20BLWithDecimals.sol\";\n\ncontract TestTokenWithDecimals is ERC20BLWithDecimals {\n  mapping(address => bool) admins;\n\n  constructor(\n    address admin,\n    string memory name,\n    string memory symbol,\n    uint8 decimals\n  ) ERC20BLWithDecimals(name, symbol, decimals) {\n    admins[admin] = true;\n  }\n\n  function requireAdmin() internal view {\n    require(admins[msg.sender], \"TestToken/adminOnly\");\n  }\n\n  function addAdmin(address admin) external {\n    requireAdmin();\n    admins[admin] = true;\n  }\n\n  function mint(address to, uint amount) external {\n    requireAdmin();\n    _mint(to, amount);\n  }\n\n  function burn(address account, uint amount) external {\n    requireAdmin();\n    _burn(account, amount);\n  }\n\n  function blacklists(address account) external {\n    requireAdmin();\n    _blacklists(account);\n  }\n\n  function whitelists(address account) external {\n    requireAdmin();\n    _whitelists(account);\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/ERC20BLWithDecimals.sol": {
      "content": "pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\nimport \"./ERC20BL.sol\";\n\ncontract ERC20BLWithDecimals is ERC20BL {\n  constructor(\n    string memory __name,\n    string memory __symbol,\n    uint8 __decimals\n  ) ERC20BL(__name, __symbol) {\n    _decimals = __decimals;\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/ERC20BL.sol": {
      "content": "pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier: MIT\n\n\n\nimport \"./SafeMath.sol\";\nimport {IERC20} from \"../MgvLib.sol\";\n\n// From OpenZeppelin & Giry\n//The MIT License (MIT)\n\n//Copyright (c) 2016-2020 zOS Global Limited\n\n//Permission is hereby granted, free of charge, to any person obtaining\n//a copy of this software and associated documentation files (the\n//\"Software\"), to deal in the Software without restriction, including\n//without limitation the rights to use, copy, modify, merge, publish,\n//distribute, sublicense, and/or sell copies of the Software, and to\n//permit persons to whom the Software is furnished to do so, subject to\n//the following conditions:\n\n//The above copyright notice and this permission notice shall be included\n//in all copies or substantial portions of the Software.\n\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n//MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n//IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n//CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n//TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n//SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address payable) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes memory) {\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n    return msg.data;\n  }\n}\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20BL is Context, IERC20 {\n  using SafeMath for uint;\n\n  mapping(address => bool) private _blacklisted;\n  mapping(address => uint) private _balances;\n\n  mapping(address => mapping(address => uint)) private _allowances;\n\n  uint private _totalSupply;\n\n  string internal _name;\n  string internal _symbol;\n  uint8 internal _decimals;\n\n  modifier notBlackListed(address addr) {\n    require(\n      !_blacklisted[addr] && !_blacklisted[_msgSender()],\n      \"ERC20BL/Blacklisted\"\n    );\n    _;\n  }\n\n  function _blacklists(address addr) public {\n    _blacklisted[addr] = true;\n  }\n\n  function _whitelists(address addr) public {\n    _blacklisted[addr] = false;\n  }\n\n  /**\n   * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n   * a default value of 18.\n   *\n   * To select a different value for {decimals}, use {_setupDecimals}.\n   *\n   * All three of these values are immutable: they can only be set once during\n   * construction.\n   */\n  constructor(string memory __name, string memory __symbol) {\n    _name = __name;\n    _symbol = __symbol;\n    _decimals = 18;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public view override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n   * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n   *\n   * Tokens usually opt for a value of 18, imitating the relationship between\n   * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n   * called.\n   *\n   * NOTE: This information is only used for _display_ purposes: it in\n   * no way affects any of the arithmetic of the contract, including\n   * {IERC20-balanceOf} and {IERC20-transfer}.\n   */\n  function decimals() public view override returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n   */\n  function totalSupply() public view override returns (uint) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n   */\n  function balanceOf(address account) public view override returns (uint) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address recipient, uint amount)\n    public\n    virtual\n    override\n    notBlackListed(recipient)\n    returns (bool)\n  {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n   */\n  function allowance(address owner, address spender)\n    public\n    view\n    virtual\n    override\n    returns (uint)\n  {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint amount)\n    public\n    virtual\n    override\n    notBlackListed(spender)\n    returns (bool)\n  {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {ERC20}.\n   *\n   * Requirements:\n   *\n   * - `sender` and `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   * - the caller must have allowance for ``sender``'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint amount\n  )\n    public\n    virtual\n    override\n    notBlackListed(sender)\n    notBlackListed(recipient)\n    returns (bool)\n  {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      _msgSender(),\n      _allowances[sender][_msgSender()].sub(\n        amount,\n        \"ERC20: transfer amount exceeds allowance\"\n      )\n    );\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint addedValue)\n    public\n    virtual\n    notBlackListed(spender)\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender].add(addedValue)\n    );\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(address spender, uint subtractedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender].sub(\n        subtractedValue,\n        \"ERC20: decreased allowance below zero\"\n      )\n    );\n    return true;\n  }\n\n  /**\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\n   *\n   * This is internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `sender` cannot be the zero address.\n   * - `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   */\n  function _transfer(\n    address sender,\n    address recipient,\n    uint amount\n  ) internal virtual {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    _balances[sender] = _balances[sender].sub(\n      amount,\n      \"ERC20: transfer amount exceeds balance\"\n    );\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   */\n  function _mint(address account, uint amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  function _burn(address account, uint amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    _balances[account] = _balances[account].sub(\n      amount,\n      \"ERC20: burn amount exceeds balance\"\n    );\n    _totalSupply = _totalSupply.sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n   *\n   * This internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(\n    address owner,\n    address spender,\n    uint amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Sets {decimals} to a value other than the default one of 18.\n   *\n   * WARNING: This function should only be called from the constructor. Most\n   * applications that interact with token contracts will not expect\n   * {decimals} to ever change, and may work incorrectly if it does.\n   */\n  function _setupDecimals(uint8 decimals_) internal {\n    _decimals = decimals_;\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * will be to transferred to `to`.\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint amount\n  ) internal virtual {}\n\n  function deposit() external payable override {}\n\n  function withdraw(uint) external override {}\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/SafeMath.sol": {
      "content": "pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier: MIT\n\n\n\n// From OpenZeppelin\n//The MIT License (MIT)\n\n//Copyright (c) 2016-2020 zOS Global Limited\n\n//Permission is hereby granted, free of charge, to any person obtaining\n//a copy of this software and associated documentation files (the\n//\"Software\"), to deal in the Software without restriction, including\n//without limitation the rights to use, copy, modify, merge, publish,\n//distribute, sublicense, and/or sell copies of the Software, and to\n//permit persons to whom the Software is furnished to do so, subject to\n//the following conditions:\n\n//The above copyright notice and this permission notice shall be included\n//in all copies or substantial portions of the Software.\n\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n//MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n//IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n//CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n//TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n//SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `+` operator.\n   *\n   * Requirements:\n   *\n   * - Addition cannot overflow.\n   */\n  function add(uint a, uint b) internal pure returns (uint) {\n    uint c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   *\n   * - Subtraction cannot overflow.\n   */\n  function sub(uint a, uint b) internal pure returns (uint) {\n    return sub(a, b, \"SafeMath: subtraction overflow\");\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   *\n   * - Subtraction cannot overflow.\n   */\n  function sub(\n    uint a,\n    uint b,\n    string memory errorMessage\n  ) internal pure returns (uint) {\n    require(b <= a, errorMessage);\n    uint c = a - b;\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `*` operator.\n   *\n   * Requirements:\n   *\n   * - Multiplication cannot overflow.\n   */\n  function mul(uint a, uint b) internal pure returns (uint) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers. Reverts on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function div(uint a, uint b) internal pure returns (uint) {\n    return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function div(\n    uint a,\n    uint b,\n    string memory errorMessage\n  ) internal pure returns (uint) {\n    require(b > 0, errorMessage);\n    uint c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts when dividing by zero.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function mod(uint a, uint b) internal pure returns (uint) {\n    return mod(a, b, \"SafeMath: modulo by zero\");\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts with custom message when dividing by zero.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function mod(\n    uint a,\n    uint b,\n    string memory errorMessage\n  ) internal pure returns (uint) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/TakerOperations.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\n\nimport \"../AbstractMangrove.sol\";\nimport \"../MgvLib.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\nimport \"./Agents/TestMaker.sol\";\nimport \"./Agents/MakerDeployer.sol\";\nimport \"./Agents/TestTaker.sol\";\n\n/* The following constructs an ERC20 with a transferFrom callback method,\n   and a TestTaker which throws away any funds received upon getting\n   a callback.\n*/\ncontract TakerOperations_Test is HasMgvEvents {\n  TestToken baseT;\n  TestToken quoteT;\n  address base;\n  address quote;\n  AbstractMangrove mgv;\n  TestMaker mkr;\n  TestMaker refusemkr;\n  TestMaker failmkr;\n\n  bool refuseReceive = false;\n\n  receive() external payable {\n    if (refuseReceive) {\n      revert(\"no\");\n    }\n  }\n\n  function a_beforeAll() public {\n    baseT = TokenSetup.setup(\"A\", \"$A\");\n    quoteT = TokenSetup.setup(\"B\", \"$B\");\n    base = address(baseT);\n    quote = address(quoteT);\n    mgv = MgvSetup.setup(baseT, quoteT);\n\n    mkr = MakerSetup.setup(mgv, base, quote);\n    refusemkr = MakerSetup.setup(mgv, base, quote, 1);\n    failmkr = MakerSetup.setup(mgv, base, quote, 2);\n\n    address(mkr).transfer(10 ether);\n    address(refusemkr).transfer(10 ether);\n    address(failmkr).transfer(10 ether);\n\n    mkr.provisionMgv(10 ether);\n    mkr.approveMgv(baseT, 10 ether);\n\n    refusemkr.provisionMgv(1 ether);\n    refusemkr.approveMgv(baseT, 10 ether);\n    failmkr.provisionMgv(1 ether);\n    failmkr.approveMgv(baseT, 10 ether);\n\n    baseT.mint(address(mkr), 5 ether);\n    baseT.mint(address(failmkr), 5 ether);\n    baseT.mint(address(refusemkr), 5 ether);\n\n    quoteT.mint(address(this), 5 ether);\n    quoteT.mint(address(this), 5 ether);\n\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"taker\");\n    Display.register(base, \"$A\");\n    Display.register(quote, \"$B\");\n    Display.register(address(mgv), \"mgv\");\n\n    Display.register(address(mkr), \"maker\");\n    Display.register(address(failmkr), \"reverting maker\");\n    Display.register(address(refusemkr), \"refusing maker\");\n  }\n\n  function snipe_reverts_if_taker_is_blacklisted_for_quote_test() public {\n    uint weiBalanceBefore = mgv.balanceOf(address(this));\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 1 ether);\n    quoteT.blacklists(address(this));\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 100_000];\n    try mgv.snipes(base, quote, targets, true) {\n      TestEvents.fail(\"Snipe should fail\");\n    } catch Error(string memory errorMsg) {\n      TestEvents.eq(\n        errorMsg,\n        \"mgv/takerTransferFail\",\n        \"Unexpected revert reason\"\n      );\n      TestEvents.eq(\n        weiBalanceBefore,\n        mgv.balanceOf(address(this)),\n        \"Taker should not take bounty\"\n      );\n    }\n  }\n\n  function snipe_reverts_if_taker_is_blacklisted_for_base_test() public {\n    uint weiBalanceBefore = mgv.balanceOf(address(this));\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 1 ether);\n    baseT.blacklists(address(this));\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 100_000];\n    try mgv.snipes(base, quote, targets, true) {\n      TestEvents.fail(\"Snipe should fail\");\n    } catch Error(string memory errorMsg) {\n      TestEvents.eq(\n        errorMsg,\n        \"mgv/MgvFailToPayTaker\",\n        \"Unexpected revert reason\"\n      );\n      TestEvents.eq(\n        weiBalanceBefore,\n        mgv.balanceOf(address(this)),\n        \"Taker should not take bounty\"\n      );\n    }\n  }\n\n  function snipe_fails_if_price_has_changed_test() public {\n    uint weiBalanceBefore = mgv.balanceOf(address(this));\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 1 ether);\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 0.5 ether, 100_000];\n    try mgv.snipes(base, quote, targets, false) returns (\n      uint successes,\n      uint got,\n      uint gave\n    ) {\n      TestEvents.check(successes == 0, \"Snipe should fail\");\n      TestEvents.eq(\n        weiBalanceBefore,\n        mgv.balanceOf(address(this)),\n        \"Taker should not take bounty\"\n      );\n      TestEvents.check(\n        (got == gave && gave == 0),\n        \"Taker should not give or take anything\"\n      );\n    } catch {\n      TestEvents.fail(\"Transaction should not revert\");\n    }\n  }\n\n  function taker_cannot_drain_maker_test() public {\n    mgv.setDensity(base, quote, 0);\n    quoteT.approve(address(mgv), 1 ether);\n    uint ofr = mkr.newOffer(9, 10, 100_000, 0);\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1, 15 ether, 100_000];\n    uint oldBal = quoteT.balanceOf(address(this));\n    mgv.snipes(base, quote, targets, true);\n    uint newBal = quoteT.balanceOf(address(this));\n    TestEvents.more(oldBal, newBal, \"oldBal should be strictly higher\");\n  }\n\n  function snipe_fillWants_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 1 ether);\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 0.5 ether, 1 ether, 100_000];\n    try mgv.snipes(base, quote, targets, true) returns (\n      uint successes,\n      uint got,\n      uint gave\n    ) {\n      TestEvents.check(successes == 1, \"Snipe should not fail\");\n      TestEvents.eq(got, 0.5 ether, \"Taker did not get enough\");\n      TestEvents.eq(gave, 0.5 ether, \"Taker did not give enough\");\n    } catch {\n      TestEvents.fail(\"Transaction should not revert\");\n    }\n  }\n\n  event Transfer(address indexed from, address indexed to, uint value);\n\n  function snipe_fillWants_zero_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    TestEvents.check(\n      TestUtils.hasOffer(mgv, base, quote, ofr),\n      \"Offer should be in the book\"\n    );\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 1 ether);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 0, 0, 100_000];\n    try mgv.snipes(base, quote, targets, true) returns (\n      uint successes,\n      uint got,\n      uint gave\n    ) {\n      TestEvents.check(successes == 1, \"Snipe should not fail\");\n      TestEvents.eq(got, 0 ether, \"Taker had too much\");\n      TestEvents.eq(gave, 0 ether, \"Taker gave too much\");\n      TestEvents.check(\n        !TestUtils.hasOffer(mgv, base, quote, ofr),\n        \"Offer should not be in the book\"\n      );\n      TestEvents.expectFrom(address(quote));\n      emit Transfer(address(this), address(mgv), 0);\n      emit Transfer(address(mgv), address(mkr), 0);\n    } catch {\n      TestEvents.fail(\"Transaction should not revert\");\n    }\n  }\n\n  function snipe_free_offer_fillWants_respects_spec_test() public {\n    uint ofr = mkr.newOffer(0, 1 ether, 100_000, 0);\n    TestEvents.check(\n      TestUtils.hasOffer(mgv, base, quote, ofr),\n      \"Offer should be in the book\"\n    );\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 1 ether);\n\n    /* Setting fillWants = true means we should not receive more than `wants`.\n       Here we are asking for 0.1 eth to an offer that gives 1eth for nothing.\n       We should still only receive 0.1 eth */\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 0.1 ether, 0, 100_000];\n    try mgv.snipes(base, quote, targets, true) returns (\n      uint successes,\n      uint got,\n      uint gave\n    ) {\n      TestEvents.check(successes == 1, \"Snipe should not fail\");\n      TestEvents.eq(got, 0.1 ether, \"Wrong got value\");\n      TestEvents.eq(gave, 0 ether, \"Wrong gave value\");\n      TestEvents.check(\n        !TestUtils.hasOffer(mgv, base, quote, ofr),\n        \"Offer should not be in the book\"\n      );\n    } catch {\n      TestEvents.fail(\"Transaction should not revert\");\n    }\n  }\n\n  function snipe_free_offer_fillGives_respects_spec_test() public {\n    uint ofr = mkr.newOffer(0, 1 ether, 100_000, 0);\n    TestEvents.check(\n      TestUtils.hasOffer(mgv, base, quote, ofr),\n      \"Offer should be in the book\"\n    );\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 1 ether);\n\n    /* Setting fillWants = false means we should spend as little as possible to receive\n       as much as possible.\n       Here despite asking for .1eth the offer gives 1eth for 0 so we should receive 1eth. */\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 0.1 ether, 0, 100_000];\n    try mgv.snipes(base, quote, targets, false) returns (\n      uint successes,\n      uint got,\n      uint gave\n    ) {\n      TestEvents.check(successes == 1, \"Snipe should not fail\");\n      TestEvents.eq(got, 1 ether, \"Wrong got value\");\n      TestEvents.eq(gave, 0 ether, \"Wrong gave value\");\n      TestEvents.check(\n        !TestUtils.hasOffer(mgv, base, quote, ofr),\n        \"Offer should not be in the book\"\n      );\n    } catch {\n      TestEvents.fail(\"Transaction should not revert\");\n    }\n  }\n\n  function snipe_fillGives_zero_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    TestEvents.check(\n      TestUtils.hasOffer(mgv, base, quote, ofr),\n      \"Offer should be in the book\"\n    );\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 1 ether);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 0, 0, 100_000];\n    try mgv.snipes(base, quote, targets, false) returns (\n      uint successes,\n      uint got,\n      uint gave\n    ) {\n      TestEvents.check(successes == 1, \"Snipe should not fail\");\n      TestEvents.eq(got, 0 ether, \"Taker had too much\");\n      TestEvents.eq(gave, 0 ether, \"Taker gave too much\");\n      TestEvents.check(\n        !TestUtils.hasOffer(mgv, base, quote, ofr),\n        \"Offer should not be in the book\"\n      );\n    } catch {\n      TestEvents.fail(\"Transaction should not revert\");\n    }\n  }\n\n  function snipe_fillGives_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 1 ether);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 0.5 ether, 1 ether, 100_000];\n    try mgv.snipes(base, quote, targets, false) returns (\n      uint successes,\n      uint got,\n      uint gave\n    ) {\n      TestEvents.check(successes == 1, \"Snipe should not fail\");\n      TestEvents.eq(got, 1 ether, \"Taker did not get enough\");\n      TestEvents.eq(gave, 1 ether, \"Taker did not get enough\");\n    } catch {\n      TestEvents.fail(\"Transaction should not revert\");\n    }\n  }\n\n  function mo_fillWants_test() public {\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 2 ether);\n    try mgv.marketOrder(base, quote, 1.1 ether, 2 ether, true) returns (\n      uint got,\n      uint gave\n    ) {\n      TestEvents.eq(got, 1.1 ether, \"Taker did not get enough\");\n      TestEvents.eq(gave, 1.1 ether, \"Taker did not get enough\");\n    } catch {\n      TestEvents.fail(\"Transaction should not revert\");\n    }\n  }\n\n  function mo_fillGives_test() public {\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 2 ether);\n    try mgv.marketOrder(base, quote, 1.1 ether, 2 ether, false) returns (\n      uint got,\n      uint gave\n    ) {\n      TestEvents.eq(got, 2 ether, \"Taker did not get enough\");\n      TestEvents.eq(gave, 2 ether, \"Taker did not get enough\");\n    } catch {\n      TestEvents.fail(\"Transaction should not revert\");\n    }\n  }\n\n  function mo_fillGivesAll_no_approved_fails_test() public {\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 2 ether);\n    try mgv.marketOrder(base, quote, 0 ether, 3 ether, false) {} catch Error(\n      string memory errorMsg\n    ) {\n      TestEvents.eq(\n        errorMsg,\n        \"mgv/takerTransferFail\",\n        \"Invalid revert message\"\n      );\n    }\n  }\n\n  function mo_fillGivesAll_succeeds_test() public {\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\"); // trade should be OK on the maker side\n    quoteT.approve(address(mgv), 3 ether);\n    try mgv.marketOrder(base, quote, 0 ether, 3 ether, false) returns (\n      uint got,\n      uint gave\n    ) {\n      TestEvents.eq(got, 3 ether, \"Taker did not get enough\");\n      TestEvents.eq(gave, 3 ether, \"Taker did not get enough\");\n    } catch {\n      TestEvents.fail(\"Transaction should not revert\");\n    }\n  }\n\n  function taker_reimbursed_if_maker_doesnt_pay_test() public {\n    uint mkr_provision = TestUtils.getProvision(mgv, base, quote, 100_000);\n    quoteT.approve(address(mgv), 1 ether);\n    uint ofr = refusemkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/makerTransferFail\"); // status visible in the posthook\n    uint beforeQuote = quoteT.balanceOf(address(this));\n    uint beforeWei = address(this).balance;\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 100_000];\n    (uint successes, uint takerGot, uint takerGave) = mgv.snipes(\n      base,\n      quote,\n      targets,\n      true\n    );\n    uint penalty = address(this).balance - beforeWei;\n    TestEvents.check(penalty > 0, \"Taker should have been compensated\");\n    TestEvents.check(successes == 0, \"Snipe should fail\");\n    TestEvents.check(\n      takerGot == takerGave && takerGave == 0,\n      \"Incorrect transaction information\"\n    );\n    TestEvents.check(\n      beforeQuote == quoteT.balanceOf(address(this)),\n      \"taker balance should not be lower if maker doesn't pay back\"\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OfferFail(\n      base,\n      quote,\n      ofr,\n      address(this),\n      1 ether,\n      1 ether,\n      \"mgv/makerTransferFail\"\n    );\n    emit Credit(address(refusemkr), mkr_provision - penalty);\n  }\n\n  function taker_reverts_on_penalty_triggers_revert_test() public {\n    uint ofr = refusemkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    refuseReceive = true;\n    quoteT.approve(address(mgv), 1 ether);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 100_000];\n    try mgv.snipes(base, quote, targets, true) {\n      TestEvents.fail(\n        \"Snipe should fail because taker has reverted on penalty send.\"\n      );\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/sendPenaltyReverted\", \"wrong revert reason\");\n    }\n  }\n\n  function taker_reimbursed_if_maker_is_blacklisted_for_base_test() public {\n    uint mkr_provision = TestUtils.getProvision(mgv, base, quote, 100_000);\n    quoteT.approve(address(mgv), 1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/makerTransferFail\"); // status visible in the posthook\n\n    baseT.blacklists(address(mkr));\n    uint beforeQuote = quoteT.balanceOf(address(this));\n    uint beforeWei = address(this).balance;\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 100_000];\n    (uint successes, uint takerGot, uint takerGave) = mgv.snipes(\n      base,\n      quote,\n      targets,\n      true\n    );\n    uint penalty = address(this).balance - beforeWei;\n    TestEvents.check(penalty > 0, \"Taker should have been compensated\");\n    TestEvents.check(successes == 0, \"Snipe should fail\");\n    TestEvents.check(\n      takerGot == takerGave && takerGave == 0,\n      \"Incorrect transaction information\"\n    );\n    TestEvents.check(\n      beforeQuote == quoteT.balanceOf(address(this)),\n      \"taker balance should not be lower if maker doesn't pay back\"\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OfferFail(\n      base,\n      quote,\n      ofr,\n      address(this),\n      1 ether,\n      1 ether,\n      \"mgv/makerTransferFail\"\n    );\n    emit Credit(address(mkr), mkr_provision - penalty);\n  }\n\n  function taker_reimbursed_if_maker_is_blacklisted_for_quote_test() public {\n    uint mkr_provision = TestUtils.getProvision(mgv, base, quote, 100_000);\n    quoteT.approve(address(mgv), 1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.expect(\"mgv/makerReceiveFail\"); // status visible in the posthook\n\n    quoteT.blacklists(address(mkr));\n    uint beforeQuote = quoteT.balanceOf(address(this));\n    uint beforeWei = address(this).balance;\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 100_000];\n    (uint successes, uint takerGot, uint takerGave) = mgv.snipes(\n      base,\n      quote,\n      targets,\n      true\n    );\n    uint penalty = address(this).balance - beforeWei;\n    TestEvents.check(penalty > 0, \"Taker should have been compensated\");\n    TestEvents.check(successes == 0, \"Snipe should fail\");\n    TestEvents.check(\n      takerGot == takerGave && takerGave == 0,\n      \"Incorrect transaction information\"\n    );\n    TestEvents.check(\n      beforeQuote == quoteT.balanceOf(address(this)),\n      \"taker balance should not be lower if maker doesn't pay back\"\n    );\n    TestEvents.expectFrom(address(mgv));\n\n    emit OfferFail(\n      base,\n      quote,\n      ofr,\n      address(this),\n      1 ether,\n      1 ether,\n      \"mgv/makerReceiveFail\"\n    );\n    emit Credit(address(mkr), mkr_provision - penalty);\n  }\n\n  function taker_collects_failing_offer_test() public {\n    quoteT.approve(address(mgv), 1 ether);\n    uint ofr = failmkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    uint beforeWei = address(this).balance;\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 0, 0, 100_000];\n    (uint successes, uint takerGot, uint takerGave) = mgv.snipes(\n      base,\n      quote,\n      targets,\n      true\n    );\n    TestEvents.check(successes == 0, \"Snipe should fail\");\n    TestEvents.check(\n      takerGot == takerGave && takerGave == 0,\n      \"Transaction data should be 0\"\n    );\n    TestEvents.check(\n      address(this).balance > beforeWei,\n      \"Taker was not compensated\"\n    );\n  }\n\n  function taker_reimbursed_if_maker_reverts_test() public {\n    uint mkr_provision = TestUtils.getProvision(mgv, base, quote, 50_000);\n    quoteT.approve(address(mgv), 1 ether);\n    uint ofr = failmkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    uint beforeQuote = quoteT.balanceOf(address(this));\n    uint beforeWei = address(this).balance;\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 100_000];\n    (uint successes, uint takerGot, uint takerGave) = mgv.snipes(\n      base,\n      quote,\n      targets,\n      true\n    );\n    uint penalty = address(this).balance - beforeWei;\n    TestEvents.check(penalty > 0, \"Taker should have been compensated\");\n    TestEvents.check(successes == 0, \"Snipe should fail\");\n    TestEvents.check(\n      takerGot == takerGave && takerGave == 0,\n      \"Incorrect transaction information\"\n    );\n    TestEvents.check(\n      beforeQuote == quoteT.balanceOf(address(this)),\n      \"taker balance should not be lower if maker doesn't pay back\"\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OfferFail(\n      base,\n      quote,\n      ofr,\n      address(this),\n      1 ether,\n      1 ether,\n      \"mgv/makerRevert\"\n    );\n    emit Credit(address(failmkr), mkr_provision - penalty);\n  }\n\n  function taker_hasnt_approved_base_succeeds_order_with_fee_test() public {\n    mgv.setFee(base, quote, 3);\n    uint balTaker = baseT.balanceOf(address(this));\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    quoteT.approve(address(mgv), 1 ether);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 50_000];\n    try mgv.snipes(base, quote, targets, true) {\n      TestEvents.eq(\n        baseT.balanceOf(address(this)) - balTaker,\n        1 ether,\n        \"Incorrect delivered amount\"\n      );\n    } catch {\n      TestEvents.fail(\"Snipe should succeed\");\n    }\n  }\n\n  function taker_hasnt_approved_base_succeeds_order_wo_fee_test() public {\n    uint balTaker = baseT.balanceOf(address(this));\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    quoteT.approve(address(mgv), 1 ether);\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 50_000];\n    try mgv.snipes(base, quote, targets, true) {\n      TestEvents.eq(\n        baseT.balanceOf(address(this)) - balTaker,\n        1 ether,\n        \"Incorrect delivered amount\"\n      );\n    } catch {\n      TestEvents.fail(\"Snipe should succeed\");\n    }\n  }\n\n  function taker_hasnt_approved_quote_fails_order_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    baseT.approve(address(mgv), 1 ether);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 50_000];\n    try mgv.snipes(base, quote, targets, true) {\n      TestEvents.fail(\"Order should fail when base is not mgv approved\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/takerTransferFail\", \"wrong revert reason\");\n    }\n  }\n\n  function simple_snipe_test() public {\n    uint ofr = mkr.newOffer(1.1 ether, 1 ether, 50_000, 0);\n    baseT.approve(address(mgv), 10 ether);\n    quoteT.approve(address(mgv), 10 ether);\n    uint balTaker = baseT.balanceOf(address(this));\n    uint balMaker = quoteT.balanceOf(address(mkr));\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1.1 ether, 50_000];\n    try mgv.snipes(base, quote, targets, true) returns (\n      uint successes,\n      uint takerGot,\n      uint takerGave\n    ) {\n      TestEvents.check(successes == 1, \"Snipe should succeed\");\n      TestEvents.eq(\n        baseT.balanceOf(address(this)) - balTaker,\n        1 ether,\n        \"Incorrect delivered amount (taker)\"\n      );\n      TestEvents.eq(\n        quoteT.balanceOf(address(mkr)) - balMaker,\n        1.1 ether,\n        \"Incorrect delivered amount (maker)\"\n      );\n      TestEvents.eq(takerGot, 1 ether, \"Incorrect transaction information\");\n      TestEvents.eq(takerGave, 1.1 ether, \"Incorrect transaction information\");\n      TestEvents.expectFrom(address(mgv));\n      emit OfferSuccess(base, quote, ofr, address(this), 1 ether, 1.1 ether);\n    } catch {\n      TestEvents.fail(\"Snipe should succeed\");\n    }\n  }\n\n  function simple_marketOrder_test() public {\n    mkr.newOffer(1.1 ether, 1 ether, 50_000, 0);\n    mkr.newOffer(1.2 ether, 1 ether, 50_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\");\n\n    baseT.approve(address(mgv), 10 ether);\n    quoteT.approve(address(mgv), 10 ether);\n    uint balTaker = baseT.balanceOf(address(this));\n    uint balMaker = quoteT.balanceOf(address(mkr));\n\n    try mgv.marketOrder(base, quote, 2 ether, 4 ether, true) returns (\n      uint takerGot,\n      uint takerGave\n    ) {\n      TestEvents.eq(\n        takerGot,\n        2 ether,\n        \"Incorrect declared delivered amount (taker)\"\n      );\n      TestEvents.eq(\n        takerGave,\n        2.3 ether,\n        \"Incorrect declared delivered amount (maker)\"\n      );\n      TestEvents.eq(\n        baseT.balanceOf(address(this)) - balTaker,\n        2 ether,\n        \"Incorrect delivered amount (taker)\"\n      );\n      TestEvents.eq(\n        quoteT.balanceOf(address(mkr)) - balMaker,\n        2.3 ether,\n        \"Incorrect delivered amount (maker)\"\n      );\n    } catch {\n      TestEvents.fail(\"Market order should succeed\");\n    }\n  }\n\n  function simple_fillWants_test() public {\n    mkr.newOffer(2 ether, 2 ether, 50_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\");\n    quoteT.approve(address(mgv), 10 ether);\n\n    (uint takerGot, uint takerGave) = mgv.marketOrder(\n      base,\n      quote,\n      1 ether,\n      2 ether,\n      true\n    );\n    TestEvents.eq(\n      takerGot,\n      1 ether,\n      \"Incorrect declared delivered amount (taker)\"\n    );\n    TestEvents.eq(\n      takerGave,\n      1 ether,\n      \"Incorrect declared delivered amount (maker)\"\n    );\n  }\n\n  function simple_fillGives_test() public {\n    mkr.newOffer(2 ether, 2 ether, 50_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\");\n    quoteT.approve(address(mgv), 10 ether);\n\n    (uint takerGot, uint takerGave) = mgv.marketOrder(\n      base,\n      quote,\n      1 ether,\n      2 ether,\n      false\n    );\n    TestEvents.eq(\n      takerGave,\n      2 ether,\n      \"Incorrect declared delivered amount (maker)\"\n    );\n    TestEvents.eq(\n      takerGot,\n      2 ether,\n      \"Incorrect declared delivered amount (taker)\"\n    );\n  }\n\n  function fillGives_at_0_wants_works_test() public {\n    uint ofr = mkr.newOffer(0 ether, 2 ether, 50_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\");\n    quoteT.approve(address(mgv), 10 ether);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 2 ether, 0 ether, 300_000];\n\n    (, uint takerGot, uint takerGave) = mgv.snipes(base, quote, targets, false);\n    TestEvents.eq(\n      takerGave,\n      0 ether,\n      \"Incorrect declared delivered amount (maker)\"\n    );\n    TestEvents.eq(\n      takerGot,\n      2 ether,\n      \"Incorrect declared delivered amount (taker)\"\n    );\n  }\n\n  function empty_wants_fillGives_test() public {\n    mkr.newOffer(2 ether, 2 ether, 50_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\");\n    quoteT.approve(address(mgv), 10 ether);\n\n    (uint takerGot, uint takerGave) = mgv.marketOrder(\n      base,\n      quote,\n      0 ether,\n      2 ether,\n      false\n    );\n    TestEvents.eq(\n      takerGave,\n      2 ether,\n      \"Incorrect declared delivered amount (maker)\"\n    );\n    TestEvents.eq(\n      takerGot,\n      2 ether,\n      \"Incorrect declared delivered amount (taker)\"\n    );\n  }\n\n  function empty_wants_fillWants_test() public {\n    mkr.newOffer(2 ether, 2 ether, 50_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\");\n    quoteT.approve(address(mgv), 10 ether);\n\n    (uint takerGot, uint takerGave) = mgv.marketOrder(\n      base,\n      quote,\n      0 ether,\n      2 ether,\n      true\n    );\n    TestEvents.eq(\n      takerGave,\n      0 ether,\n      \"Incorrect declared delivered amount (maker)\"\n    );\n    TestEvents.eq(\n      takerGot,\n      0 ether,\n      \"Incorrect declared delivered amount (taker)\"\n    );\n  }\n\n  function taker_has_no_quote_fails_order_test() public {\n    uint ofr = mkr.newOffer(100 ether, 2 ether, 50_000, 0);\n    mkr.expect(\"mgv/tradeSuccess\");\n\n    quoteT.approve(address(mgv), 100 ether);\n    baseT.approve(address(mgv), 1 ether); // not necessary since no fee\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 2 ether, 100 ether, 100_000];\n    try mgv.snipes(base, quote, targets, true) {\n      TestEvents.fail(\n        \"Taker does not have enough quote tokens, order should fail\"\n      );\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/takerTransferFail\", \"wrong revert reason\");\n    }\n  }\n\n  function maker_has_not_enough_base_fails_order_test() public {\n    uint ofr = mkr.newOffer(1 ether, 100 ether, 100_000, 0);\n    mkr.expect(\"mgv/makerTransferFail\");\n    // getting rid of base tokens\n    //mkr.transferToken(baseT,address(this),5 ether);\n    quoteT.approve(address(mgv), 0.5 ether);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 50 ether, 0.5 ether, 100_000];\n    (uint successes, , ) = mgv.snipes(base, quote, targets, true);\n    TestEvents.check(successes == 0, \"order should fail\");\n    TestEvents.expectFrom(address(mgv));\n    emit OfferFail(\n      base,\n      quote,\n      ofr,\n      address(this),\n      50 ether,\n      0.5 ether,\n      \"mgv/makerTransferFail\"\n    );\n  }\n\n  function maker_revert_is_logged_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    mkr.expect(\"mgv/makerRevert\");\n    mkr.shouldRevert(true);\n    quoteT.approve(address(mgv), 1 ether);\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 50_000];\n    mgv.snipes(base, quote, targets, true);\n    TestEvents.expectFrom(address(mgv));\n    emit OfferFail(\n      base,\n      quote,\n      ofr,\n      address(this),\n      1 ether,\n      1 ether,\n      \"mgv/makerRevert\"\n    );\n  }\n\n  function snipe_on_higher_price_fails_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    quoteT.approve(address(mgv), 0.5 ether);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 0.5 ether, 100_000];\n    (uint successes, , ) = mgv.snipes(base, quote, targets, true);\n    TestEvents.check(\n      successes == 0,\n      \"Order should fail when order price is higher than offer\"\n    );\n  }\n\n  function snipe_on_higher_gas_fails_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    quoteT.approve(address(mgv), 1 ether);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 50_000];\n    (uint successes, , ) = mgv.snipes(base, quote, targets, true);\n    TestEvents.check(\n      successes == 0,\n      \"Order should fail when order gas is higher than offer\"\n    );\n  }\n\n  function detect_lowgas_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    quoteT.approve(address(mgv), 100 ether);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 100_000];\n    bytes memory cd = abi.encodeWithSelector(\n      mgv.snipes.selector,\n      base,\n      quote,\n      targets,\n      true\n    );\n\n    (bool noRevert, bytes memory data) = address(mgv).call{gas: 130000}(cd);\n    if (noRevert) {\n      TestEvents.fail(\"take should fail due to low gas\");\n    } else {\n      TestUtils.revertEq(\n        TestUtils.getReason(data),\n        \"mgv/notEnoughGasForMakerTrade\"\n      );\n    }\n  }\n\n  function snipe_on_lower_price_succeeds_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    quoteT.approve(address(mgv), 2 ether);\n    uint balTaker = baseT.balanceOf(address(this));\n    uint balMaker = quoteT.balanceOf(address(mkr));\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 2 ether, 100_000];\n    (uint successes, , ) = mgv.snipes(base, quote, targets, true);\n    TestEvents.check(\n      successes == 1,\n      \"Order should succeed when order price is lower than offer\"\n    );\n    // checking order was executed at Maker's price\n    TestEvents.eq(\n      baseT.balanceOf(address(this)) - balTaker,\n      1 ether,\n      \"Incorrect delivered amount (taker)\"\n    );\n    TestEvents.eq(\n      quoteT.balanceOf(address(mkr)) - balMaker,\n      1 ether,\n      \"Incorrect delivered amount (maker)\"\n    );\n  }\n\n  /* Note as for jan 5 2020: by locally pushing the block gas limit to 38M, you can go up to 162 levels of recursion before hitting \"revert for an unknown reason\" -- I'm assuming that's the stack limit. */\n  function recursion_depth_is_acceptable_test() public {\n    for (uint i = 0; i < 50; i++) {\n      mkr.newOffer(0.001 ether, 0.001 ether, 50_000, i);\n    }\n    quoteT.approve(address(mgv), 10 ether);\n    // 6/1/20 : ~50k/offer with optims\n    //uint g = gasleft();\n    //console.log(\"gas used per offer: \",(g-gasleft())/50);\n  }\n\n  function partial_fill_test() public {\n    quoteT.approve(address(mgv), 1 ether);\n    mkr.newOffer(0.1 ether, 0.1 ether, 50_000, 0);\n    mkr.newOffer(0.1 ether, 0.1 ether, 50_000, 1);\n    mkr.expect(\"mgv/tradeSuccess\");\n    (uint takerGot, ) = mgv.marketOrder(\n      base,\n      quote,\n      0.15 ether,\n      0.15 ether,\n      true\n    );\n    TestEvents.eq(\n      takerGot,\n      0.15 ether,\n      \"Incorrect declared partial fill amount\"\n    );\n    TestEvents.eq(\n      baseT.balanceOf(address(this)),\n      0.15 ether,\n      \"incorrect partial fill\"\n    );\n  }\n\n  // ! unreliable test, depends on gas use\n  function market_order_stops_for_high_price_test() public {\n    quoteT.approve(address(mgv), 1 ether);\n    for (uint i = 0; i < 10; i++) {\n      mkr.newOffer((i + 1) * (0.1 ether), 0.1 ether, 50_000, i);\n    }\n    mkr.expect(\"mgv/tradeSuccess\");\n    // first two offers are at right price\n    uint takerWants = 2 * (0.1 ether + 0.1 ether);\n    uint takerGives = 2 * (0.1 ether + 0.2 ether);\n    mgv.marketOrder{gas: 350_000}(base, quote, takerWants, takerGives, true);\n  }\n\n  // ! unreliable test, depends on gas use\n  function market_order_stops_for_filled_mid_offer_test() public {\n    quoteT.approve(address(mgv), 1 ether);\n    for (uint i = 0; i < 10; i++) {\n      mkr.newOffer(i * (0.1 ether), 0.1 ether, 50_000, i);\n    }\n    mkr.expect(\"mgv/tradeSuccess\");\n    // first two offers are at right price\n    uint takerWants = 0.1 ether + 0.05 ether;\n    uint takerGives = 0.1 ether + 0.1 ether;\n    mgv.marketOrder{gas: 350_000}(base, quote, takerWants, takerGives, true);\n  }\n\n  function market_order_stops_for_filled_after_offer_test() public {\n    quoteT.approve(address(mgv), 1 ether);\n    for (uint i = 0; i < 10; i++) {\n      mkr.newOffer(i * (0.1 ether), 0.1 ether, 50_000, i);\n    }\n    mkr.expect(\"mgv/tradeSuccess\");\n    // first two offers are at right price\n    uint takerWants = 0.1 ether + 0.1 ether;\n    uint takerGives = 0.1 ether + 0.2 ether;\n    mgv.marketOrder{gas: 350_000}(base, quote, takerWants, takerGives, true);\n  }\n\n  function takerWants_wider_than_160_bits_fails_marketOrder_test() public {\n    try mgv.marketOrder(base, quote, 2**160, 1, true) {\n      TestEvents.fail(\"TakerWants > 160bits, order should fail\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/mOrder/takerWants/160bits\", \"wrong revert reason\");\n    }\n  }\n\n  function snipe_with_0_wants_ejects_offer_test() public {\n    quoteT.approve(address(mgv), 1 ether);\n    uint mkrBal = baseT.balanceOf(address(mkr));\n    uint ofr = mkr.newOffer(0.1 ether, 0.1 ether, 50_000, 0);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 0, 1 ether, 50_000];\n    (uint successes, , ) = mgv.snipes(base, quote, targets, true);\n    TestEvents.check(successes == 1, \"snipe should succeed\");\n    TestEvents.eq(mgv.best(base, quote), 0, \"offer should be gone\");\n    TestEvents.eq(\n      baseT.balanceOf(address(mkr)),\n      mkrBal,\n      \"mkr balance should not change\"\n    );\n  }\n\n  function unsafe_gas_left_fails_order_test() public {\n    mgv.setGasbase(base, quote, 1, 1);\n    quoteT.approve(address(mgv), 1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 120_000, 0);\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 120_000];\n    try mgv.snipes{gas: 120_000}(base, quote, targets, true) {\n      TestEvents.fail(\"unsafe gas amount, order should fail\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/notEnoughGasForMakerTrade\", \"wrong revert reason\");\n    }\n  }\n\n  function marketOrder_on_empty_book_returns_test() public {\n    try mgv.marketOrder(base, quote, 1 ether, 1 ether, true) {\n      TestEvents.succeed();\n    } catch Error(string memory) {\n      TestEvents.fail(\"market order on empty book should not fail\");\n    }\n  }\n\n  function marketOrder_on_empty_book_does_not_leave_lock_on_test() public {\n    mgv.marketOrder(base, quote, 1 ether, 1 ether, true);\n    TestEvents.check(\n      !mgv.locked(base, quote),\n      \"mgv should not be locked after marketOrder on empty OB\"\n    );\n  }\n\n  function takerWants_is_zero_succeeds_test() public {\n    try mgv.marketOrder(base, quote, 0, 1 ether, true) returns (\n      uint got,\n      uint gave\n    ) {\n      TestEvents.eq(got, 0, \"Taker got too much\");\n      TestEvents.eq(gave, 0 ether, \"Taker gave too much\");\n    } catch {\n      TestEvents.fail(\"Unexpected revert\");\n    }\n  }\n\n  function takerGives_is_zero_succeeds_test() public {\n    try mgv.marketOrder(base, quote, 1 ether, 0, true) returns (\n      uint got,\n      uint gave\n    ) {\n      TestEvents.eq(got, 0, \"Taker got too much\");\n      TestEvents.eq(gave, 0 ether, \"Taker gave too much\");\n    } catch {\n      TestEvents.fail(\"Unexpected revert\");\n    }\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/PermitHelper.sol": {
      "content": "pragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\n\nimport \"../AbstractMangrove.sol\";\nimport \"../MgvLib.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\nimport \"./Agents/TestMaker.sol\";\nimport \"./Agents/TestMoriartyMaker.sol\";\nimport \"./Agents/MakerDeployer.sol\";\nimport \"./Agents/TestTaker.sol\";\n\n/* *********************************************** */\n/* THIS IS NOT A `hardhat test-solidity` TEST FILE */\n/* *********************************************** */\n\n/* See test/permit.js, this helper sets up a mgv for the javascript tester of the permit functionality */\n\ncontract PermitHelper is IMaker {\n  receive() external payable {}\n\n  AbstractMangrove mgv;\n  address base;\n  address quote;\n\n  function makerExecute(ML.SingleOrder calldata)\n    external\n    override\n    returns (bytes32)\n  {\n    return \"\";\n  }\n\n  function makerPosthook(ML.SingleOrder calldata, ML.OrderResult calldata)\n    external\n    override\n  {}\n\n  constructor() payable {\n    TestToken baseT = TokenSetup.setup(\"A\", \"$A\");\n    TestToken quoteT = TokenSetup.setup(\"B\", \"$B\");\n    base = address(baseT);\n    quote = address(quoteT);\n    mgv = MgvSetup.setup(baseT, quoteT);\n\n    bool noRevert;\n    (noRevert, ) = address(mgv).call{value: 10 ether}(\"\");\n\n    baseT.mint(address(this), 2 ether);\n    quoteT.mint(msg.sender, 2 ether);\n\n    baseT.approve(address(mgv), 1 ether);\n\n    Display.register(msg.sender, \"Permit signer\");\n    Display.register(address(this), \"Permit Helper\");\n    Display.register(base, \"$A\");\n    Display.register(quote, \"$B\");\n    Display.register(address(mgv), \"mgv\");\n\n    mgv.newOffer(base, quote, 1 ether, 1 ether, 100_000, 0, 0);\n  }\n\n  function mgvAddress() external view returns (address) {\n    return address(mgv);\n  }\n\n  function baseAddress() external view returns (address) {\n    return base;\n  }\n\n  function quoteAddress() external view returns (address) {\n    return quote;\n  }\n\n  function no_allowance() external {\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [uint(1), 1 ether, 1 ether, 300_000];\n    try mgv.snipesFor(base, quote, targets, true, msg.sender) {\n      revert(\"snipesFor without allowance should revert\");\n    } catch Error(string memory reason) {\n      if (keccak256(bytes(reason)) != keccak256(\"mgv/lowAllowance\")) {\n        revert(\"revert when no allowance should be due to no allowance\");\n      }\n    }\n  }\n\n  function wrong_permit(\n    uint value,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    try\n      mgv.permit({\n        outbound_tkn: base,\n        inbound_tkn: quote,\n        owner: msg.sender,\n        spender: address(this),\n        value: value,\n        deadline: deadline,\n        v: v,\n        r: r,\n        s: s\n      })\n    {\n      revert(\"Permit with bad v,r,s should revert\");\n    } catch Error(string memory reason) {\n      if (\n        keccak256(bytes(reason)) != keccak256(\"mgv/permit/invalidSignature\")\n      ) {\n        revert(\"permit failed, but signature should be deemed invalid\");\n      }\n    }\n  }\n\n  function expired_permit(\n    uint value,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    try\n      mgv.permit({\n        outbound_tkn: base,\n        inbound_tkn: quote,\n        owner: msg.sender,\n        spender: address(this),\n        value: value,\n        deadline: deadline,\n        v: v,\n        r: r,\n        s: s\n      })\n    {\n      revert(\"Permit with expired deadline should revert\");\n    } catch Error(string memory reason) {\n      if (keccak256(bytes(reason)) != keccak256(\"mgv/permit/expired\")) {\n        revert(\"permit failed, but deadline should be deemed expired\");\n      }\n    }\n  }\n\n  function good_permit(\n    uint value,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    mgv.permit(\n      base,\n      quote,\n      msg.sender,\n      address(this),\n      value,\n      deadline,\n      v,\n      r,\n      s\n    );\n\n    if (mgv.allowances(base, quote, msg.sender, address(this)) != value) {\n      revert(\"Allowance not set\");\n    }\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [uint(1), 1 ether, 1 ether, 300_000];\n    (uint successes, uint takerGot, uint takerGave) = mgv.snipesFor(\n      base,\n      quote,\n      targets,\n      true,\n      msg.sender\n    );\n    if (successes != 0) {\n      revert(\"Snipe should succeed\");\n    }\n    if (takerGot != 1 ether) {\n      revert(\"takerGot should be 1 ether\");\n    }\n\n    if (takerGave != 1 ether) {\n      revert(\"takerGave should be 1 ether\");\n    }\n\n    if (\n      mgv.allowances(base, quote, msg.sender, address(this)) !=\n      (value - 1 ether)\n    ) {\n      revert(\"Allowance incorrectly decreased\");\n    }\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Pedagogical.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\n\nimport \"../AbstractMangrove.sol\";\nimport \"../MgvLib.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\nimport \"./Agents/TestMaker.sol\";\nimport \"./Agents/TestMoriartyMaker.sol\";\nimport \"./Agents/MakerDeployer.sol\";\nimport \"./Agents/TestTaker.sol\";\nimport \"./Agents/Compound.sol\";\n\ncontract Pedagogical_Test {\n  receive() external payable {}\n\n  AbstractMangrove mgv;\n  TestToken bat;\n  TestToken dai;\n  TestTaker tkr;\n  TestMaker mkr;\n  Compound compound;\n\n  function example_1_offerbook_test() public {\n    setupMakerBasic();\n\n    Display.log(\"Filling book\");\n\n    mkr.newOffer({wants: 1 ether, gives: 1 ether, gasreq: 300_000, pivotId: 0});\n\n    mkr.newOffer({\n      wants: 1.1 ether,\n      gives: 1 ether,\n      gasreq: 300_000,\n      pivotId: 0\n    });\n\n    mkr.newOffer({\n      wants: 1.2 ether,\n      gives: 1 ether,\n      gasreq: 300_000,\n      pivotId: 0\n    });\n\n    //logBook\n    TestUtils.logOfferBook(mgv, address(bat), address(dai), 3);\n    Display.logBalances(\n      [address(bat), address(dai)],\n      address(mkr),\n      address(tkr)\n    );\n  }\n\n  function example_2_markerOrder_test() public {\n    example_1_offerbook_test();\n\n    Display.log(\n      \"Market order. Taker wants 2.7 exaunits and gives 3.5 exaunits.\"\n    );\n    (uint got, uint gave) = tkr.marketOrder({\n      wants: 2.7 ether,\n      gives: 3.5 ether\n    });\n    Display.log(\"Market order ended. Got / gave\", got, gave);\n\n    TestUtils.logOfferBook(mgv, address(bat), address(dai), 1);\n    Display.logBalances(\n      [address(bat), address(dai)],\n      address(mkr),\n      address(tkr)\n    );\n  }\n\n  function example_3_redeem_test() public {\n    setupMakerCompound();\n\n    Display.log(\"Maker posts an offer for 1 exaunit\");\n    uint ofr = mkr.newOffer({\n      wants: 1 ether,\n      gives: 1 ether,\n      gasreq: 600_000,\n      pivotId: 0\n    });\n\n    TestUtils.logOfferBook(mgv, address(bat), address(dai), 1);\n    Display.logBalances(\n      [address(bat), address(dai)],\n      address(mkr),\n      address(tkr),\n      address(compound)\n    );\n    Display.logBalances(\n      [address(compound.c(bat)), address(compound.c(dai))],\n      address(mkr)\n    );\n\n    Display.log(\"Taker takes offer for 0.3 exaunits\");\n    bool took = tkr.take(ofr, 0.3 ether);\n    if (took) {\n      Display.log(\"Take successful\");\n    } else {\n      Display.log(\"Take failed\");\n    }\n\n    TestUtils.logOfferBook(mgv, address(bat), address(dai), 1);\n    Display.logBalances(\n      [address(bat), address(dai)],\n      address(mkr),\n      address(tkr),\n      address(compound)\n    );\n  }\n\n  function example_4_callback_test() public {\n    setupMakerCallback();\n\n    Display.log(\"Maker posts 1 offer\");\n    mkr.newOffer({wants: 1 ether, gives: 1 ether, gasreq: 400_000, pivotId: 0});\n\n    TestUtils.logOfferBook(mgv, address(bat), address(dai), 1);\n    Display.logBalances(\n      [address(bat), address(dai)],\n      address(mkr),\n      address(tkr)\n    );\n\n    Display.log(\n      \"Market order begins. Maker will be called back and reinsert its offer\"\n    );\n    (uint got, uint gave) = tkr.marketOrder({wants: 1 ether, gives: 1 ether});\n    Display.log(\"Market order complete. got / gave:\", got, gave);\n\n    TestUtils.logOfferBook(mgv, address(bat), address(dai), 1);\n    Display.logBalances(\n      [address(bat), address(dai)],\n      address(mkr),\n      address(tkr)\n    );\n  }\n\n  function _beforeAll() public {\n    bat = new TestToken({\n      admin: address(this),\n      name: \"Basic attention token\",\n      symbol: \"BAT\"\n    });\n\n    dai = new TestToken({admin: address(this), name: \"Dai\", symbol: \"DAI\"});\n\n    mgv = new Mangrove({\n      governance: address(this),\n      gasprice: 40,\n      gasmax: 1_000_000\n    });\n\n    // activate a market where taker buys BAT using DAI\n    mgv.activate({\n      outbound_tkn: address(bat),\n      inbound_tkn: address(dai),\n      fee: 0,\n      density: 100,\n      overhead_gasbase: 30_000,\n      offer_gasbase: 10_000\n    });\n\n    tkr = new TestTaker({mgv: mgv, base: bat, quote: dai});\n\n    mgv.fund{value: 10 ether}(address(this));\n\n    dai.mint({amount: 10 ether, to: address(tkr)});\n    tkr.approveMgv({amount: 10 ether, token: dai});\n\n    Display.register({addr: msg.sender, name: \"Test Runner\"});\n    Display.register({addr: address(this), name: \"Testing Contract\"});\n    Display.register({addr: address(bat), name: \"BAT\"});\n    Display.register({addr: address(dai), name: \"DAI\"});\n    Display.register({addr: address(mgv), name: \"mgv\"});\n    Display.register({addr: address(tkr), name: \"taker\"});\n  }\n\n  function setupMakerBasic() internal {\n    mkr = new Maker_basic({mgv: mgv, base: bat, quote: dai});\n\n    Display.register({addr: address(mkr), name: \"maker-basic\"});\n\n    // testing contract starts with 1000 ETH\n    address(mkr).transfer(10 ether);\n    mkr.provisionMgv({amount: 5 ether});\n    bat.mint({amount: 10 ether, to: address(mkr)});\n  }\n\n  function setupMakerCompound() internal {\n    compound = new Compound();\n    Display.register(address(compound), \"compound\");\n    Display.register(address(compound.c(bat)), \"cBAT\");\n    Display.register(address(compound.c(dai)), \"cDAI\");\n\n    Maker_compound _mkr = new Maker_compound({\n      mgv: mgv,\n      base: bat,\n      quote: dai,\n      compound: compound\n    });\n\n    mkr = _mkr;\n\n    bat.mint({amount: 10 ether, to: address(mkr)});\n    _mkr.useCompound();\n\n    Display.register({addr: address(mkr), name: \"maker-compound\"});\n\n    // testing contract starts with 1000 ETH\n    address(mkr).transfer(10 ether);\n    mkr.provisionMgv({amount: 5 ether});\n  }\n\n  function setupMakerCallback() internal {\n    Display.log(\"Setting up maker with synchronous callback\");\n    mkr = new Maker_callback({mgv: mgv, base: bat, quote: dai});\n\n    Display.register({addr: address(mkr), name: \"maker-callback\"});\n\n    // testing contract starts with 1000 ETH\n    address(mkr).transfer(10 ether);\n    mkr.provisionMgv({amount: 5 ether});\n\n    bat.mint({amount: 10 ether, to: address(mkr)});\n  }\n}\n\n// Provisioned.\n// Sends amount to taker.\ncontract Maker_basic is TestMaker {\n  constructor(\n    AbstractMangrove mgv,\n    ERC20BL base,\n    ERC20BL quote\n  ) TestMaker(mgv, base, quote) {\n    approveMgv(base, 500 ether);\n  }\n\n  function makerExecute(ML.SingleOrder calldata)\n    public\n    pure\n    override\n    returns (bytes32)\n  {\n    return \"\";\n    //ERC20(order.outbound_tkn).transfer({recipient: taker, amount: order.wants});\n  }\n}\n\n// Not provisioned.\n// Redeems money from fake-Compound\ncontract Maker_compound is TestMaker {\n  Compound _compound;\n\n  constructor(\n    AbstractMangrove mgv,\n    ERC20BL base,\n    ERC20BL quote,\n    Compound compound\n  ) TestMaker(mgv, base, quote) {\n    _compound = compound;\n    approveMgv(base, 500 ether);\n    base.approve(address(compound), 500 ether);\n    quote.approve(address(compound), 500 ether);\n  }\n\n  function useCompound() external {\n    Display.log(\"Maker deposits 10 exaunits at Compound.\");\n    _compound.mint(ERC20BL(_base), 10 ether);\n  }\n\n  function makerExecute(ML.SingleOrder calldata order)\n    public\n    override\n    returns (bytes32)\n  {\n    _compound.mint({token: ERC20BL(order.inbound_tkn), amount: order.gives});\n    Display.log(\"Maker redeems from Compound.\");\n    _compound.redeem({\n      token: ERC20BL(order.outbound_tkn),\n      amount: order.wants,\n      to: address(this)\n    });\n    return \"\";\n  }\n}\n\n// Provisioned.\n// Reinserts the offer if necessary.\ncontract Maker_callback is TestMaker {\n  constructor(\n    AbstractMangrove mgv,\n    ERC20BL base,\n    ERC20BL quote\n  ) TestMaker(mgv, base, quote) {\n    approveMgv(base, 500 ether);\n  }\n\n  function makerExecute(ML.SingleOrder calldata)\n    public\n    pure\n    override\n    returns (bytes32)\n  {\n    return \"\";\n    //ERC20BL(order.outbound_tkn).transfer({recipient: taker, amount: order.wants});\n  }\n\n  uint volume = 1 ether;\n  uint price = 340; // in %\n  uint gasreq = 400_000;\n\n  function makerPosthook(ML.SingleOrder calldata order, ML.OrderResult calldata)\n    external\n    override\n  {\n    Display.log(\"Reinserting offer...\");\n    AbstractMangrove mgv = AbstractMangrove(msg.sender);\n    mgv.updateOffer({\n      outbound_tkn: order.outbound_tkn,\n      inbound_tkn: order.inbound_tkn,\n      wants: (price * volume) / 100,\n      gives: volume,\n      gasreq: gasreq,\n      gasprice: 0,\n      pivotId: 0,\n      offerId: order.offerId\n    });\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Agents/Compound.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\n\nimport \"hardhat/console.sol\";\n\nimport \"../Toolbox/TestUtils.sol\";\n\nimport \"./TestToken.sol\";\n\ncontract Compound {\n  constructor() {}\n\n  mapping(ERC20BL => mapping(address => uint)) deposits;\n  mapping(ERC20BL => TestToken) cTokens;\n\n  //function grant(address to, IERC20 token, uint amount) {\n  //deposits[token][to] += amount;\n  //c(token).mint(to, amount);\n  //}\n\n  function c(ERC20BL token) public returns (TestToken) {\n    if (address(cTokens[token]) == address(0)) {\n      string memory cName = TestUtils.append(\"c\", token.name());\n      string memory cSymbol = TestUtils.append(\"c\", token.symbol());\n      cTokens[token] = new TestToken(address(this), cName, cSymbol);\n    }\n\n    return cTokens[token];\n  }\n\n  function mint(ERC20BL token, uint amount) external {\n    token.transferFrom(msg.sender, address(this), amount);\n    deposits[token][msg.sender] += amount;\n    c(token).mint(msg.sender, amount);\n  }\n\n  function redeem(\n    address to,\n    ERC20BL token,\n    uint amount\n  ) external {\n    c(token).burn(msg.sender, amount);\n    token.transfer(to, amount);\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Monitor.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\n\nimport \"../AbstractMangrove.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\nimport \"./Agents/TestMonitor.sol\";\n\n// In these tests, the testing contract is the market maker.\ncontract Monitor_Test {\n  receive() external payable {}\n\n  AbstractMangrove mgv;\n  TestMaker mkr;\n  MgvMonitor monitor;\n  address base;\n  address quote;\n\n  function a_beforeAll() public {\n    TestToken baseT = TokenSetup.setup(\"A\", \"$A\");\n    TestToken quoteT = TokenSetup.setup(\"B\", \"$B\");\n    monitor = new MgvMonitor();\n    base = address(baseT);\n    quote = address(quoteT);\n    mgv = MgvSetup.setup(baseT, quoteT);\n    mkr = MakerSetup.setup(mgv, base, quote);\n\n    address(mkr).transfer(10 ether);\n\n    mkr.provisionMgv(5 ether);\n    bool noRevert;\n    (noRevert, ) = address(mgv).call{value: 10 ether}(\"\");\n\n    baseT.mint(address(mkr), 2 ether);\n    quoteT.mint(address(this), 2 ether);\n\n    baseT.approve(address(mgv), 1 ether);\n    quoteT.approve(address(mgv), 1 ether);\n\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"Test Contract\");\n    Display.register(base, \"$A\");\n    Display.register(quote, \"$B\");\n    Display.register(address(mgv), \"mgv\");\n    Display.register(address(mkr), \"maker[$A,$B]\");\n  }\n\n  function initial_monitor_values_test() public {\n    (bytes32 config, ) = mgv.config(base, quote);\n    TestEvents.check(\n      MP.global_unpack_useOracle(config) == 0,\n      \"initial useOracle should be false\"\n    );\n    TestEvents.check(\n      MP.global_unpack_notify(config) == 0,\n      \"initial notify should be false\"\n    );\n  }\n\n  function set_monitor_values_test() public {\n    mgv.setMonitor(address(monitor));\n    mgv.setUseOracle(true);\n    mgv.setNotify(true);\n    (bytes32 config, ) = mgv.config(base, quote);\n    TestEvents.eq(\n      MP.global_unpack_monitor(config),\n      address(monitor),\n      \"monitor should be set\"\n    );\n    TestEvents.check(\n      MP.global_unpack_useOracle(config) > 0,\n      \"useOracle should be set\"\n    );\n    TestEvents.check(\n      MP.global_unpack_notify(config) > 0,\n      \"notify should be set\"\n    );\n  }\n\n  function set_oracle_density_with_useOracle_works_test() public {\n    mgv.setMonitor(address(monitor));\n    mgv.setUseOracle(true);\n    mgv.setDensity(base, quote, 898);\n    monitor.setDensity(base, quote, 899);\n    (, bytes32 config) = mgv.config(base, quote);\n    TestEvents.eq(\n      MP.local_unpack_density(config),\n      899,\n      \"density should be set oracle\"\n    );\n  }\n\n  function set_oracle_density_without_useOracle_fails_test() public {\n    mgv.setMonitor(address(monitor));\n    mgv.setDensity(base, quote, 898);\n    monitor.setDensity(base, quote, 899);\n    (, bytes32 config) = mgv.config(base, quote);\n    TestEvents.eq(\n      MP.local_unpack_density(config),\n      898,\n      \"density should be set by mgv\"\n    );\n  }\n\n  function set_oracle_gasprice_with_useOracle_works_test() public {\n    mgv.setMonitor(address(monitor));\n    mgv.setUseOracle(true);\n    mgv.setGasprice(900);\n    monitor.setGasprice(901);\n    (bytes32 config, ) = mgv.config(base, quote);\n    TestEvents.eq(\n      MP.global_unpack_gasprice(config),\n      901,\n      \"gasprice should be set by oracle\"\n    );\n  }\n\n  function set_oracle_gasprice_without_useOracle_fails_test() public {\n    mgv.setMonitor(address(monitor));\n    mgv.setGasprice(900);\n    monitor.setGasprice(901);\n    (bytes32 config, ) = mgv.config(base, quote);\n    TestEvents.eq(\n      MP.global_unpack_gasprice(config),\n      900,\n      \"gasprice should be set by mgv\"\n    );\n  }\n\n  function invalid_oracle_address_throws_test() public {\n    mgv.setMonitor(address(42));\n    mgv.setUseOracle(true);\n    try mgv.config(base, quote) {\n      TestEvents.fail(\"Call to invalid oracle address should throw\");\n    } catch {\n      TestEvents.succeed();\n    }\n  }\n\n  function notify_works_on_success_when_set_test() public {\n    mkr.approveMgv(IERC20(base), 1 ether);\n    mgv.setMonitor(address(monitor));\n    mgv.setNotify(true);\n    uint ofrId = mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    bytes32 offer = mgv.offers(base, quote, ofrId);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofrId, 0.04 ether, 0.05 ether, 100_000];\n    (uint successes, , ) = mgv.snipes(base, quote, targets, true);\n    TestEvents.check(successes == 1, \"snipe should succeed\");\n    (bytes32 _global, bytes32 _local) = mgv.config(base, quote);\n    _local = ((_local & bytes32(0xffffffffffffffffffffffffffff000000ffffffffffffffffffffffffffffff) | bytes32((uint(1) << 232) >> 112)) & bytes32(0xffffffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffff) | bytes32((uint(1) << 248) >> 104));\n\n    ML.SingleOrder memory order = ML.SingleOrder({\n      outbound_tkn: base,\n      inbound_tkn: quote,\n      offerId: ofrId,\n      offer: offer,\n      wants: 0.04 ether,\n      gives: 0.04 ether, // wants has been updated to offer price\n      offerDetail: mgv.offerDetails(base, quote, ofrId),\n      global: _global,\n      local: _local\n    });\n\n    TestEvents.expectFrom(address(monitor));\n    emit L.TradeSuccess(order, address(this));\n  }\n\n  function notify_works_on_fail_when_set_test() public {\n    mgv.setMonitor(address(monitor));\n    mgv.setNotify(true);\n    uint ofrId = mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    bytes32 offer = mgv.offers(base, quote, ofrId);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofrId, 0.04 ether, 0.05 ether, 100_000];\n    (uint successes, , ) = mgv.snipes(base, quote, targets, true);\n    TestEvents.check(successes == 0, \"snipe should fail\");\n\n    (bytes32 _global, bytes32 _local) = mgv.config(base, quote);\n    // config sent during maker callback has stale best and, is locked\n    _local = ((_local & bytes32(0xffffffffffffffffffffffffffff000000ffffffffffffffffffffffffffffff) | bytes32((uint(1) << 232) >> 112)) & bytes32(0xffffffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffff) | bytes32((uint(1) << 248) >> 104));\n\n    ML.SingleOrder memory order = ML.SingleOrder({\n      outbound_tkn: base,\n      inbound_tkn: quote,\n      offerId: ofrId,\n      offer: offer,\n      wants: 0.04 ether,\n      gives: 0.04 ether, // gives has been updated to offer price\n      offerDetail: mgv.offerDetails(base, quote, ofrId),\n      global: _global,\n      local: _local\n    });\n\n    TestEvents.expectFrom(address(monitor));\n    emit L.TradeFail(order, address(this));\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Agents/TestMonitor.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\n\nimport \"../../MgvLib.sol\";\n\nlibrary L {\n  event TradeSuccess(MgvLib.SingleOrder order, address taker);\n  event TradeFail(MgvLib.SingleOrder order, address taker);\n}\n\ncontract MgvMonitor is IMgvMonitor {\n  uint gasprice;\n  mapping(address => mapping(address => uint)) private densities;\n\n  function setGasprice(uint _gasprice) external {\n    gasprice = _gasprice;\n  }\n\n  function setDensity(\n    address base,\n    address quote,\n    uint _density\n  ) external {\n    densities[base][quote] = _density;\n  }\n\n  function read(address base, address quote)\n    external\n    view\n    override\n    returns (uint, uint)\n  {\n    return (gasprice, densities[base][quote]);\n  }\n\n  function notifySuccess(MgvLib.SingleOrder calldata sor, address taker)\n    external\n    override\n  {\n    emit L.TradeSuccess(sor, taker);\n  }\n\n  function notifyFail(MgvLib.SingleOrder calldata sor, address taker)\n    external\n    override\n  {\n    emit L.TradeFail(sor, taker);\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/MM1T_Test.sol": {
      "content": "pragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\n\nimport \"../AbstractMangrove.sol\";\nimport \"../MgvLib.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\nimport \"./Agents/TestMaker.sol\";\nimport \"./Agents/TestTaker.sol\";\nimport \"./Agents/MM1.sol\";\n\ncontract MM1T_Test {\n  receive() external payable {}\n\n  AbstractMangrove mgv;\n  TestTaker tkr;\n  TestMaker mkr;\n  MM1 mm1;\n  address base;\n  address quote;\n\n  function a_beforeAll() public {\n    TestToken baseT = TokenSetup.setup(\"A\", \"$A\");\n    TestToken quoteT = TokenSetup.setup(\"B\", \"$B\");\n    base = address(baseT);\n    quote = address(quoteT);\n    mgv = MgvSetup.setup(baseT, quoteT);\n    tkr = TakerSetup.setup(mgv, base, quote);\n    mkr = MakerSetup.setup(mgv, base, quote);\n    mm1 = new MM1{value: 2 ether}(mgv, base, quote);\n\n    address(tkr).transfer(10 ether);\n    address(mkr).transfer(10 ether);\n\n    //bool noRevert;\n    //(noRevert, ) = address(mgv).call{value: 10 ether}(\"\");\n\n    mkr.provisionMgv(5 ether);\n\n    baseT.mint(address(tkr), 10 ether);\n    baseT.mint(address(mkr), 10 ether);\n    baseT.mint(address(mm1), 2 ether);\n\n    quoteT.mint(address(tkr), 10 ether);\n    quoteT.mint(address(mkr), 10 ether);\n    quoteT.mint(address(mm1), 2 ether);\n\n    mm1.refresh();\n\n    //baseT.approve(address(mgv), 1 ether);\n    //quoteT.approve(address(mgv), 1 ether);\n    tkr.approveMgv(quoteT, 1000 ether);\n    tkr.approveMgv(baseT, 1000 ether);\n    mkr.approveMgv(quoteT, 1000 ether);\n    mkr.approveMgv(baseT, 1000 ether);\n\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"Gatekeeping_Test/maker\");\n    Display.register(base, \"$A\");\n    Display.register(quote, \"$B\");\n    Display.register(address(mgv), \"mgv\");\n    Display.register(address(tkr), \"taker[$A,$B]\");\n    //Display.register(address(dual_mkr), \"maker[$B,$A]\");\n    Display.register(address(mkr), \"maker\");\n    Display.register(address(mm1), \"MM1\");\n  }\n\n  function ta_test() public {\n    TestUtils.logOfferBook(mgv, base, quote, 3);\n    TestUtils.logOfferBook(mgv, quote, base, 3);\n    (MgvLib.Offer memory ofr, ) = mgv.offerInfo(base, quote, 1);\n    console.log(\"prev\", ofr.prev);\n    mkr.newOffer(base, quote, 0.05 ether, 0.1 ether, 200_000, 0);\n    mkr.newOffer(quote, base, 0.05 ether, 0.05 ether, 200_000, 0);\n    TestUtils.logOfferBook(mgv, base, quote, 3);\n    TestUtils.logOfferBook(mgv, quote, base, 3);\n\n    tkr.marketOrder(0.01 ether, 0.01 ether);\n    TestUtils.logOfferBook(mgv, base, quote, 3);\n    TestUtils.logOfferBook(mgv, quote, base, 3);\n\n    mkr.newOffer(base, quote, 0.05 ether, 0.1 ether, 200_000, 0);\n    mm1.refresh();\n    TestUtils.logOfferBook(mgv, base, quote, 3);\n    TestUtils.logOfferBook(mgv, quote, base, 3);\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Agents/MM1.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\nimport {ITaker, IMaker, MgvLib as DC, HasMgvEvents, IMgvMonitor} from \"../../MgvLib.sol\";\nimport \"../../AbstractMangrove.sol\";\nimport \"../Toolbox/TestUtils.sol\";\nimport \"hardhat/console.sol\";\n\n/* TODO\n * dans makerExecute: check oracle price to see if I'm still in reasonable spread\n * don't sell all liquidity otherwie what is my price when I have 0 balance ? at least check that.\n */\n\ncontract MM1 {\n  uint immutable sell_id;\n  uint immutable buy_id;\n  address immutable a_addr;\n  address immutable b_addr;\n  AbstractMangrove immutable mgv;\n\n  /* This MM has 1 offer on each side of a book. After each take, it updates both offers.\n     The new price is based on the midprice between each books, a base_spread,\n     and the ratio of a/b inventories normalized by the current midprice. */\n\n  constructor(\n    AbstractMangrove _mgv,\n    address _a_addr,\n    address _b_addr\n  ) payable {\n    mgv = _mgv;\n    a_addr = _a_addr;\n    b_addr = _b_addr;\n\n    _mgv.fund{value: 1 ether}(address(this));\n\n    IERC20(_a_addr).approve(address(_mgv), 10000 ether);\n    IERC20(_b_addr).approve(address(_mgv), 10000 ether);\n\n    sell_id = _mgv.newOffer(_a_addr, _b_addr, 1, 1 ether, 40_000, 0, 0);\n    buy_id = _mgv.newOffer(_b_addr, _a_addr, 1, 1 ether, 40_000, 0, 0);\n  }\n\n  function refresh() external {\n    doMakerPosthook();\n  }\n\n  function makerExecute(DC.SingleOrder calldata) external returns (bytes32) {\n    return \"\";\n  }\n\n  function makerPosthook(DC.SingleOrder calldata, DC.OrderResult calldata)\n    external\n  {\n    doMakerPosthook();\n  }\n\n  /* Shifting to avoid overflows during intermediary steps */\n  /* TODO use a fixed point library */\n  uint constant SHF = 30;\n\n  function doMakerPosthook() internal {\n    // a&b must be k bits at most\n    uint b = IERC20(b_addr).balanceOf(address(this)) >> SHF;\n    uint a = IERC20(a_addr).balanceOf(address(this)) >> SHF;\n\n    //console.log(\"b\",b);\n    //console.log(\"a\",a);\n\n    uint base_spread = 500; // base_spread is in basis points\n    uint d_d = 10000; // delta = d_n / d_d\n\n    // best offers\n    uint best_sell_id = mgv.best(a_addr, b_addr);\n    (DC.Offer memory best_sell, ) = mgv.offerInfo(a_addr, b_addr, best_sell_id);\n\n    //console.log(\"initial bs.w\",best_sell.wants);\n    //console.log(\"initial bs.g\",best_sell.gives);\n\n    // if no offer on a/b pair\n    if (\n      best_sell_id == sell_id || (best_sell.wants == 0 && best_sell.gives == 0)\n    ) {\n      //console.log(\"no offer on a/b pair\");\n      best_sell.wants = b;\n      best_sell.gives = a;\n    } else {\n      best_sell.wants = best_sell.wants >> SHF;\n      best_sell.gives = best_sell.gives >> SHF;\n    }\n\n    //console.log(\"bs.w\",best_sell.wants);\n    //console.log(\"bs.g\",best_sell.gives);\n\n    uint best_buy_id = mgv.best(b_addr, a_addr);\n    (DC.Offer memory best_buy, ) = mgv.offerInfo(b_addr, a_addr, best_buy_id);\n\n    //console.log(\"initial bb.w\",best_buy.wants);\n    //console.log(\"initial bb.g\",best_buy.gives);\n\n    // if no offer on b/a pair\n    if (best_buy_id == buy_id || (best_buy.wants == 0 && best_buy.gives == 0)) {\n      //console.log(\"no offer on b/a pair\");\n      best_buy.wants = a;\n      best_buy.gives = b;\n    } else {\n      best_buy.wants = best_buy.wants >> SHF;\n      best_buy.gives = best_buy.gives >> SHF;\n    }\n\n    //console.log(\"bb.w\",best_buy.wants);\n    //console.log(\"bb.g\",best_buy.gives);\n\n    // average price numerator (same for buy&sell)\n    // at most (96-SHF)*2+1 bits\n    uint m_n = best_sell.wants *\n      best_buy.wants +\n      best_sell.gives *\n      best_buy.gives;\n    //console.log(\"m_n\",m_n);\n\n    uint d_n = 10000 + base_spread; // at most 14 bits\n\n    /* SELL */\n    /********/\n    {\n      // midprice of A in B is m_n/sell_m_d\n      // at most (96-SHF)*2+1 bits\n      uint sell_m_d = 2 * best_sell.gives * best_buy.wants;\n      //console.log(\"sell_m_d\",sell_m_d);\n\n      uint sell_gives = a << SHF;\n      //console.log(\"sell_gives\",sell_gives);\n      // normalized_BA_inv_ratio = b / (2 * a * b)\n      // skew = 0.5 + inv/2 = (m_n * a + sell_m_d * b) / (2 * m_n * a)\n      // sell_wants = delta * midprice * a * skew\n\n      uint sell_wants_n = (d_n * (m_n * a + sell_m_d * b)) << (3 * SHF);\n      //console.log(\"sell_wants_n\",sell_wants_n);\n      uint sell_wants_d = (2 * sell_m_d * d_d) << (3 * SHF);\n      //console.log(\"sell_wants_d\",sell_wants_d);\n      uint sell_wants = (sell_wants_n / sell_wants_d) << SHF;\n\n      //console.log(\"sell_wants\",sell_wants);\n      //console.log(\"sell_gives\",sell_gives);\n      Display.log(sell_wants, sell_gives);\n\n      mgv.updateOffer({\n        outbound_tkn: a_addr,\n        inbound_tkn: b_addr,\n        wants: sell_wants,\n        gives: sell_gives,\n        gasreq: 400_000,\n        gasprice: 0,\n        pivotId: sell_id,\n        offerId: sell_id\n      });\n    }\n\n    /* BUY */\n    /*******/\n\n    uint buy_m_d = 2 * best_sell.wants * best_buy.gives;\n\n    uint buy_gives = b << SHF;\n\n    // buy_wants = buy_delta * buy_midprice * b * buy_skew;\n    uint buy_wants_n = d_n * (m_n * b + buy_m_d * a);\n    uint buy_wants_d = 2 * buy_m_d * d_d;\n    uint buy_wants = (buy_wants_n / buy_wants_d) << SHF;\n\n    mgv.updateOffer({\n      outbound_tkn: b_addr,\n      inbound_tkn: a_addr,\n      wants: buy_wants,\n      gives: buy_gives,\n      gasreq: 400_000,\n      gasprice: 0,\n      pivotId: buy_id,\n      offerId: buy_id\n    });\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Toolbox/ThrowCatch.sol": {
      "content": "pragma solidity ^0.7.4;\npragma abicoder v2;\n\n// SPDX-License-Identifier: Unlicense\n\n// We can't even encode storage references without the experimental encoder\n\n\n\nimport {Test as T} from \"@giry/hardhat-test-solidity/test.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Throw_Test {\n  bool called;\n\n  receive() external payable {}\n\n  function throws() external {\n    bytes memory s = new bytes(1000); //spend some gas\n    s;\n    called = true;\n  }\n\n  function not_enough_gas_to_call_test() public {\n    try this.throws{gas: 100}() {\n      T.fail(\"Function should have failed\");\n    } catch {\n      T.check(!called, \"Function should not have been called\");\n    }\n  }\n\n  function enough_gas_to_call_test() public {\n    try this.throws{gas: 1000}() {\n      T.fail(\"Function should have failed\");\n    } catch {\n      T.check(!called, \"Function should have run out of gas\");\n    }\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Toolbox/StorageEncoding.sol": {
      "content": "pragma solidity ^0.7.4;\npragma abicoder v2;\n\n// SPDX-License-Identifier: Unlicense\n\n/* Testing bad storage encoding */\n\n// We can't even encode storage references without the experimental encoder\n\n\n\nimport {Test as TestEvents} from \"@giry/hardhat-test-solidity/test.sol\";\nimport \"hardhat/console.sol\";\n\ncontract StorageEncoding {}\n\nstruct S {\n  uint a;\n}\n\nlibrary Lib {\n  function a(S storage s) public view {\n    s; // silence warning about unused parameter\n    console.log(\"in Lib.a: calldata received\");\n    console.logBytes(msg.data);\n  }\n}\n\ncontract Failer_Test {\n  receive() external payable {}\n\n  function exec() external view {\n    console.log(\"exec\");\n    require(false);\n  }\n\n  function execBig() external view {\n    console.log(\"execBig\");\n    string memory wtf = new string(100_000);\n    require(false, wtf);\n  }\n\n  function failed_yul_test() public {\n    bytes memory b = new bytes(100_000);\n    b;\n    uint g0 = gasleft();\n    bytes memory cd = abi.encodeWithSelector(this.execBig.selector);\n    bytes memory retdata = new bytes(32);\n    assembly {\n      let success := delegatecall(\n        500000,\n        address(),\n        add(cd, 32),\n        4,\n        add(retdata, 32),\n        0\n      )\n    }\n    console.log(\"GasUsed: %d\", g0 - gasleft());\n  }\n\n  function failer_small_test() public {\n    uint g0 = gasleft();\n    (bool success, bytes memory retdata) = address(this).delegatecall{\n      gas: 500_000\n    }(abi.encodeWithSelector(this.exec.selector));\n    success;\n    retdata;\n    console.log(\"GasUsed: %d\", g0 - gasleft());\n  }\n\n  function failer_big_with_retdata_bytes_test() public {\n    bytes memory b = new bytes(100_000);\n    b;\n    uint g0 = gasleft();\n    (bool success, bytes memory retdata) = address(this).delegatecall{\n      gas: 500_000\n    }(abi.encodeWithSelector(this.execBig.selector));\n    success;\n    retdata;\n\n    console.log(\"GasUsed: %d\", g0 - gasleft());\n  }\n}\n\ncontract StorageEncoding_Test {\n  receive() external payable {}\n\n  S sss; // We add some padding so the storage ref for s is not 0\n  S ss;\n  S s;\n\n  function _test() public {\n    console.log(\"Lib.a selector:\");\n    console.logBytes4(Lib.a.selector);\n    console.log(\"___________________\");\n\n    console.log(\"[Encoding s manually]\");\n    console.log(\"abi.encodeWithSelector(Lib.a.selector,s)):\");\n    bytes memory data = abi.encodeWithSelector(Lib.a.selector, s);\n    console.logBytes(data);\n    console.log(\"Calling address(Lib).delegatecall(u)...\");\n    bool success;\n    (success, ) = address(Lib).delegatecall(data);\n    console.log(\"___________________\");\n\n    console.log(\"[Encoding s with compiler]\");\n    console.log(\"Calling Lib.a(s)...\");\n    Lib.a(s);\n    console.log(\"___________________\");\n  }\n}\n\ncontract Abi_Test {\n  receive() external payable {}\n\n  function wordOfBytes(bytes memory data) internal pure returns (bytes32 w) {\n    assembly {\n      w := mload(add(data, 32))\n    }\n  }\n\n  function bytesOfWord(bytes32 w) internal pure returns (bytes memory data) {\n    data = new bytes(32);\n    assembly {\n      mstore(add(data, 32), w)\n    }\n  }\n\n  function wordOfUint(uint x) internal pure returns (bytes32 w) {\n    w = bytes32(x);\n  }\n\n  enum Arity {\n    N,\n    U,\n    B,\n    T\n  }\n  bytes32 constant MASKHEADER =\n    0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n  bytes32 constant MASKFIRSTARG =\n    0x00000000000000000000000000ffffffffffffffffffffffffffffffffffffff;\n\n  function encode_decode_test() public {\n    bytes memory x = abi.encodePacked(\n      Arity.B,\n      uint96(1 ether),\n      uint96(2 ether)\n    );\n    bytes32 w = wordOfBytes(x);\n    console.logBytes32(w);\n    console.logBytes32(w >> (31 * 8));\n    bytes memory header = bytesOfWord(w >> (31 * 8)); // header is encode in the first byte\n    Arity t = abi.decode(header, (Arity));\n    TestEvents.check(t == Arity.B, \"Incorrect decoding of header\");\n    bytes memory arg1 = bytesOfWord((w & MASKHEADER) >> (19 * 8));\n    console.logBytes(arg1);\n    TestEvents.check(\n      uint96(1 ether) == abi.decode(arg1, (uint96)),\n      \"Incorrect decoding of arg1\"\n    );\n    bytes memory arg2 = bytesOfWord((w & MASKFIRSTARG) >> (7 * 8));\n    console.logBytes(arg2);\n    TestEvents.check(\n      uint96(2 ether) == abi.decode(arg2, (uint96)),\n      \"Incorrect decoding of arg2\"\n    );\n  }\n}\n\n// contract EncodeDecode_Test {\n//   receive() external payable {}\n//   enum T {U,B}\n\n//   function encode(uint192 x) internal view returns (bytes memory){\n//     console.log(\"encoding\",uint(x));\n//     bytes memory data = new bytes(32);\n//     data = abi.encode(T.U,abi.encode(x));\n//     console.logBytes(data);\n//     return data;\n//   }\n//   function encode(uint96 x, uint96 y) internal view returns (bytes memory){\n//     console.log(\"encoding\",uint(x),uint(y));\n\n//     bytes memory data = new bytes(32);\n//     data = abi.encode(T.B,abi.encode(x,y));\n//     console.logBytes(data);\n//     return data;\n//   }\n\n//   function decode(bytes memory data) internal view returns (uint[] memory) {\n//     console.log(\"Decoding\");\n//     console.logBytes(data);\n//     (T t,bytes memory data_) = abi.decode(data,(T,bytes));\n//     if (t==T.B) {\n//       console.log(\"Binary predicate detected\");\n//       uint[] memory args = new uint[](2);\n//       (uint96 x, uint96 y) = abi.decode(data_,(uint96,uint96));\n//       args[0] = uint(x);\n//       args[1] = uint(y);\n//       return args;\n//     }\n//     else{\n//       console.log(\"Unary predicate detected\");\n//       uint[] memory args = new uint[](1);\n//       args[0] = uint(abi.decode(data_,(uint192)));\n//       return args;\n//     }\n//   }\n\n//   function encode_decode(uint x) internal view {\n//     bytes memory data = encode(uint192(x));\n//     uint[] memory args = decode(data);\n//     for (uint i=0;i<args.length;i++){\n//       console.log(args[i]);\n//     }\n//   }\n\n//   function encode_decode(uint x, uint y) internal view {\n//     bytes memory data = encode(uint96(x), uint96(y));\n//     uint[] memory args = decode(data);\n//     for (uint i=0;i<args.length;i++){\n//       console.log(args[i]);\n//     }\n//   }\n\n//   function encode_decode_test() public view {\n//     encode_decode(123456789);\n//     encode_decode(1234,56789);\n//   }\n\n// }\n"
    },
    "cache/solpp-generated-contracts/Tests/MgvReader_Test.sol": {
      "content": "pragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\n\nimport \"../AbstractMangrove.sol\";\nimport \"../MgvLib.sol\";\nimport \"hardhat/console.sol\";\nimport \"@giry/hardhat-test-solidity/test.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\nimport \"./Agents/TestMaker.sol\";\nimport \"./Agents/MakerDeployer.sol\";\nimport \"./Agents/TestTaker.sol\";\nimport {MgvReader} from \"../periphery/MgvReader.sol\";\n\ncontract Oracle {\n  function read(address base, address quote)\n    external\n    view\n    returns (uint, uint)\n  {\n    return (23, 2);\n  }\n}\n\n// In these tests, the testing contract is the market maker.\ncontract MgvReader_Test is HasMgvEvents {\n  receive() external payable {}\n\n  AbstractMangrove mgv;\n  TestMaker mkr;\n  MgvReader reader;\n  address base;\n  address quote;\n  Oracle oracle;\n\n  function a_beforeAll() public {\n    TestToken baseT = TokenSetup.setup(\"A\", \"$A\");\n    TestToken quoteT = TokenSetup.setup(\"B\", \"$B\");\n    oracle = new Oracle();\n\n    base = address(baseT);\n    quote = address(quoteT);\n    mgv = MgvSetup.setup(baseT, quoteT);\n    mkr = MakerSetup.setup(mgv, base, quote);\n    reader = new MgvReader(address(mgv));\n\n    address(mkr).transfer(10 ether);\n\n    bool noRevert;\n    (noRevert, ) = address(mgv).call{value: 10 ether}(\"\");\n\n    mkr.provisionMgv(5 ether);\n\n    baseT.mint(address(this), 2 ether);\n    quoteT.mint(address(mkr), 1 ether);\n\n    baseT.approve(address(mgv), 1 ether);\n    quoteT.approve(address(mgv), 1 ether);\n\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"Gatekeeping_Test/maker\");\n    Display.register(base, \"$A\");\n    Display.register(quote, \"$B\");\n    Display.register(address(mgv), \"mgv\");\n    Display.register(address(mkr), \"maker[$A,$B]\");\n  }\n\n  function read_packed_test() public {\n    (\n      uint currentId,\n      uint[] memory offerIds,\n      ML.Offer[] memory offers,\n      ML.OfferDetail[] memory details\n    ) = reader.offerList(base, quote, 0, 50);\n\n    TestEvents.eq(offerIds.length, 0, \"ids: wrong length on 2elem\");\n    TestEvents.eq(offers.length, 0, \"offers: wrong length on 1elem\");\n    TestEvents.eq(details.length, 0, \"details: wrong length on 1elem\");\n    // test 1 elem\n    mkr.newOffer(1 ether, 1 ether, 10_000, 0);\n\n    (currentId, offerIds, offers, details) = reader.offerList(\n      base,\n      quote,\n      0,\n      50\n    );\n\n    TestEvents.eq(offerIds.length, 1, \"ids: wrong length on 1elem\");\n    TestEvents.eq(offers.length, 1, \"offers: wrong length on 1elem\");\n    TestEvents.eq(details.length, 1, \"details: wrong length on 1elem\");\n\n    // test 2 elem\n    mkr.newOffer(0.9 ether, 1 ether, 10_000, 0);\n\n    (currentId, offerIds, offers, details) = reader.offerList(\n      base,\n      quote,\n      0,\n      50\n    );\n\n    TestEvents.eq(offerIds.length, 2, \"ids: wrong length on 2elem\");\n    TestEvents.eq(offers.length, 2, \"offers: wrong length on 1elem\");\n    TestEvents.eq(details.length, 2, \"details: wrong length on 1elem\");\n\n    // test 2 elem read from elem 1\n    (currentId, offerIds, offers, details) = reader.offerList(\n      base,\n      quote,\n      1,\n      50\n    );\n    TestEvents.eq(\n      offerIds.length,\n      1,\n      \"ids: wrong length 2elem start from id 1\"\n    );\n    TestEvents.eq(offers.length, 1, \"offers: wrong length on 1elem\");\n    TestEvents.eq(details.length, 1, \"details: wrong length on 1elem\");\n\n    // test 3 elem read in chunks of 2\n    mkr.newOffer(0.8 ether, 1 ether, 10_000, 0);\n    (currentId, offerIds, offers, details) = reader.offerList(\n      base,\n      quote,\n      0,\n      2\n    );\n    TestEvents.eq(\n      offerIds.length,\n      2,\n      \"ids: wrong length on 3elem chunk size 2\"\n    );\n    TestEvents.eq(offers.length, 2, \"offers: wrong length on 1elem\");\n    TestEvents.eq(details.length, 2, \"details: wrong length on 1elem\");\n\n    // test offer order\n    (currentId, offerIds, offers, details) = reader.offerList(\n      base,\n      quote,\n      0,\n      50\n    );\n    TestEvents.eq(offers[0].wants, 0.8 ether, \"wrong wants for offers[0]\");\n    TestEvents.eq(offers[1].wants, 0.9 ether, \"wrong wants for offers[0]\");\n    TestEvents.eq(offers[2].wants, 1 ether, \"wrong wants for offers[0]\");\n  }\n\n  function returns_zero_on_nonexisting_offer_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 10_000, 0);\n    mkr.retractOffer(ofr);\n    (, uint[] memory offerIds, , ) = reader.offerList(base, quote, ofr, 50);\n    TestEvents.eq(\n      offerIds.length,\n      0,\n      \"should have 0 offers since starting point is out of the book\"\n    );\n  }\n\n  function no_wasted_time_test() public {\n    reader.offerList(base, quote, 0, 50); // warming up caches\n\n    uint g = gasleft();\n    reader.offerList(base, quote, 0, 50);\n    uint used1 = g - gasleft();\n\n    g = gasleft();\n    reader.offerList(base, quote, 0, 50000000);\n    uint used2 = g - gasleft();\n\n    TestEvents.eq(\n      used1,\n      used2,\n      \"gas spent should not depend on maxOffers when offers length < maxOffers\"\n    );\n  }\n\n  function correct_endpoints_0_test() public {\n    uint startId;\n    uint length;\n    (startId, length) = reader.offerListEndPoints(base, quote, 0, 100000);\n    TestEvents.eq(startId, 0, \"0.0 wrong startId\");\n    TestEvents.eq(length, 0, \"0.0 wrong length\");\n\n    (startId, length) = reader.offerListEndPoints(base, quote, 32, 100000);\n    TestEvents.eq(startId, 0, \"0.1 wrong startId\");\n    TestEvents.eq(length, 0, \"0.1 wrong length\");\n  }\n\n  function correct_endpoints_1_test() public {\n    uint startId;\n    uint length;\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n\n    (startId, length) = reader.offerListEndPoints(base, quote, 0, 0);\n    TestEvents.eq(startId, 1, \"1.0 wrong startId\");\n    TestEvents.eq(length, 0, \"1.0 wrong length\");\n\n    (startId, length) = reader.offerListEndPoints(base, quote, 1, 1);\n    TestEvents.eq(startId, 1, \"1.1 wrong startId\");\n    TestEvents.eq(length, 1, \"1.1 wrong length\");\n\n    (startId, length) = reader.offerListEndPoints(base, quote, 1, 1321);\n    TestEvents.eq(startId, 1, \"1.2 wrong startId\");\n    TestEvents.eq(length, 1, \"1.2 wrong length\");\n\n    (startId, length) = reader.offerListEndPoints(base, quote, 2, 12);\n    TestEvents.eq(startId, 0, \"1.0 wrong startId\");\n    TestEvents.eq(length, 0, \"1.0 wrong length\");\n  }\n\n  function try_provision() internal {\n    uint prov = reader.getProvision(base, quote, 0, 0);\n    uint bal1 = mgv.balanceOf(address(mkr));\n    mkr.newOffer(1 ether, 1 ether, 0, 0);\n    uint bal2 = mgv.balanceOf(address(mkr));\n    TestEvents.eq(bal1 - bal2, prov, \"provision computation is wrong\");\n  }\n\n  function provision_0_test() public {\n    try_provision();\n  }\n\n  function provision_1_test() public {\n    mgv.setGasbase(base, quote, 17_000, 280_000);\n    try_provision();\n  }\n\n  function provision_oracle_test() public {\n    mgv.setMonitor(address(oracle));\n    mgv.setUseOracle(true);\n    try_provision();\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/periphery/MgvReader.sol": {
      "content": "pragma solidity ^0.7.6;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvReader.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n\nimport {MgvLib as ML} from \"../MgvLib.sol\";\nimport {MgvPack as MP} from \"../MgvPack.sol\";\n\ninterface MangroveLike {\n  function best(address,address) external view returns (uint);\n  function offers(address,address,uint) external view returns (bytes32);\n  function offerDetails(address,address,uint) external view returns (bytes32);\n  function offerInfo(address,address,uint) external view returns (ML.Offer memory, ML.OfferDetail memory);\n  function config(address,address) external view returns (bytes32,bytes32);\n}\n\ncontract MgvReader {\n  MangroveLike immutable mgv;\n\n  constructor(address _mgv) {\n    mgv = MangroveLike(payable(_mgv));\n  }\n\n  /*\n   * Returns two uints.\n   *\n   * `startId` is the id of the best live offer with id equal or greater than\n   * `fromId`, 0 if there is no such offer.\n   *\n   * `length` is 0 if `startId == 0`. Other it is the number of live offers as good or worse than the offer with\n   * id `startId`.\n   */\n  function offerListEndPoints(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint fromId,\n    uint maxOffers\n  ) public view returns (uint startId, uint length) {\n    if (fromId == 0) {\n      startId = mgv.best(outbound_tkn, inbound_tkn);\n    } else {\n      startId = MP.offer_unpack_gives(\n        mgv.offers(outbound_tkn, inbound_tkn, fromId)\n      ) > 0\n        ? fromId\n        : 0;\n    }\n\n    uint currentId = startId;\n\n    while (currentId != 0 && length < maxOffers) {\n      currentId = MP.offer_unpack_next(\n        mgv.offers(outbound_tkn, inbound_tkn, currentId)\n      );\n      length = length + 1;\n    }\n\n    return (startId, length);\n  }\n\n  // Returns the orderbook for the outbound_tkn/inbound_tkn pair in packed form. First number is id of next offer (0 is we're done). First array is ids, second is offers (as bytes32), third is offerDetails (as bytes32). Array will be of size `min(# of offers in out/in list, maxOffers)`.\n  function packedOfferList(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint fromId,\n    uint maxOffers\n  )\n    public\n    view\n    returns (\n      uint,\n      uint[] memory,\n      bytes32[] memory,\n      bytes32[] memory\n    )\n  {\n    (uint currentId, uint length) = offerListEndPoints(\n      outbound_tkn,\n      inbound_tkn,\n      fromId,\n      maxOffers\n    );\n\n    uint[] memory offerIds = new uint[](length);\n    bytes32[] memory offers = new bytes32[](length);\n    bytes32[] memory details = new bytes32[](length);\n\n    uint i = 0;\n\n    while (currentId != 0 && i < length) {\n      offerIds[i] = currentId;\n      offers[i] = mgv.offers(outbound_tkn, inbound_tkn, currentId);\n      details[i] = mgv.offerDetails(outbound_tkn, inbound_tkn, currentId);\n      currentId = MP.offer_unpack_next(offers[i]);\n      i = i + 1;\n    }\n\n    return (currentId, offerIds, offers, details);\n  }\n\n  // Returns the orderbook for the outbound_tkn/inbound_tkn pair in unpacked form. First number is id of next offer (0 if we're done). First array is ids, second is offers (as structs), third is offerDetails (as structs). Array will be of size `min(# of offers in out/in list, maxOffers)`.\n  function offerList(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint fromId,\n    uint maxOffers\n  )\n    public\n    view\n    returns (\n      uint,\n      uint[] memory,\n      ML.Offer[] memory,\n      ML.OfferDetail[] memory\n    )\n  {\n    (uint currentId, uint length) = offerListEndPoints(\n      outbound_tkn,\n      inbound_tkn,\n      fromId,\n      maxOffers\n    );\n\n    uint[] memory offerIds = new uint[](length);\n    ML.Offer[] memory offers = new ML.Offer[](length);\n    ML.OfferDetail[] memory details = new ML.OfferDetail[](length);\n\n    uint i = 0;\n    while (currentId != 0 && i < length) {\n      offerIds[i] = currentId;\n      (offers[i], details[i]) = mgv.offerInfo(\n        outbound_tkn,\n        inbound_tkn,\n        currentId\n      );\n      currentId = offers[i].next;\n      i = i + 1;\n    }\n\n    return (currentId, offerIds, offers, details);\n  }\n\n  function getProvision(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint ofr_gasreq,\n    uint ofr_gasprice\n  ) external view returns (uint) {\n    (bytes32 global, bytes32 local) = mgv.config(outbound_tkn, inbound_tkn);\n    uint _gp;\n    uint global_gasprice = MP.global_unpack_gasprice(global);\n    if (global_gasprice > ofr_gasprice) {\n      _gp = global_gasprice;\n    } else {\n      _gp = ofr_gasprice;\n    }\n    return\n      (ofr_gasreq +\n        MP.local_unpack_overhead_gasbase(local) +\n        MP.local_unpack_offer_gasbase(local)) *\n      _gp *\n      10**9;\n  }\n\n  /* Returns the configuration in an ABI-compatible struct. Should not be called internally, would be a huge memory copying waste. Use `config` instead. */\n  function config(address outbound_tkn, address inbound_tkn)\n    external\n    view\n    returns (ML.Global memory global, ML.Local memory local)\n  {\n    (bytes32 _global, bytes32 _local) = mgv.config(outbound_tkn, inbound_tkn);\n    return (\n      ML.Global({\n        monitor: address(uint((_global << 0)) >> 96),\n        useOracle: uint(uint((_global << 160)) >> 248) > 0,\n        notify: uint(uint((_global << 168)) >> 248) > 0,\n        gasprice: uint(uint((_global << 176)) >> 240),\n        gasmax: uint(uint((_global << 192)) >> 232),\n        dead: uint(uint((_global << 216)) >> 248) > 0\n      }),\n      ML.Local({\n        active: uint(uint((_local << 0)) >> 248) > 0,\n        overhead_gasbase: uint(uint((_local << 56)) >> 232),\n        offer_gasbase: uint(uint((_local << 80)) >> 232),\n        fee: uint(uint((_local << 8)) >> 240),\n        density: uint(uint((_local << 24)) >> 224),\n        best: uint(uint((_local << 112)) >> 232),\n        lock: uint(uint((_local << 104)) >> 248) > 0,\n        last: uint(uint((_local << 136)) >> 232)\n      })\n    );\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/MakerOperations.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\n\nimport \"../AbstractMangrove.sol\";\nimport \"../MgvLib.sol\";\nimport {MgvPack as MP} from \"../MgvPack.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\nimport \"./Agents/TestMaker.sol\";\nimport \"./Agents/TestMoriartyMaker.sol\";\nimport \"./Agents/MakerDeployer.sol\";\nimport \"./Agents/TestTaker.sol\";\n\ncontract MakerOperations_Test is IMaker, HasMgvEvents {\n  AbstractMangrove mgv;\n  TestMaker mkr;\n  TestMaker mkr2;\n  TestTaker tkr;\n  TestToken base;\n  TestToken quote;\n  address _base;\n  address _quote;\n\n  receive() external payable {}\n\n  function a_beforeAll() public {\n    base = TokenSetup.setup(\"A\", \"$A\");\n    _base = address(base);\n    quote = TokenSetup.setup(\"B\", \"$B\");\n    _quote = address(quote);\n\n    mgv = MgvSetup.setup(base, quote);\n    mkr = MakerSetup.setup(mgv, _base, _quote);\n    mkr2 = MakerSetup.setup(mgv, _base, _quote);\n    tkr = TakerSetup.setup(mgv, _base, _quote);\n\n    address(mkr).transfer(10 ether);\n    mkr.approveMgv(base, 10 ether);\n    address(mkr2).transfer(10 ether);\n    mkr2.approveMgv(base, 10 ether);\n\n    address(tkr).transfer(10 ether);\n\n    quote.mint(address(tkr), 1 ether);\n    tkr.approveMgv(quote, 1 ether);\n\n    base.approve(address(mgv), 10 ether);\n\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"MakerOperations_Test\");\n    Display.register(_base, \"$A\");\n    Display.register(_quote, \"$B\");\n    Display.register(address(mgv), \"mgv\");\n    Display.register(address(mkr), \"maker\");\n    Display.register(address(mkr2), \"maker2\");\n    Display.register(address(tkr), \"taker\");\n  }\n\n  function provision_adds_freeWei_and_ethers_test() public {\n    uint mgv_bal = address(mgv).balance;\n    uint amt1 = 235;\n    uint amt2 = 1.3 ether;\n\n    mkr.provisionMgv(amt1);\n\n    TestEvents.eq(mkr.freeWei(), amt1, \"incorrect mkr freeWei amount (1)\");\n    TestEvents.eq(\n      address(mgv).balance,\n      mgv_bal + amt1,\n      \"incorrect mgv ETH balance (1)\"\n    );\n\n    mkr.provisionMgv(amt2);\n\n    TestEvents.eq(\n      mkr.freeWei(),\n      amt1 + amt2,\n      \"incorrect mkr freeWei amount (2)\"\n    );\n    TestEvents.eq(\n      address(mgv).balance,\n      mgv_bal + amt1 + amt2,\n      \"incorrect mgv ETH balance (2)\"\n    );\n  }\n\n  // since we check calldata, execute must be internal\n  function makerExecute(ML.SingleOrder calldata order)\n    external\n    override\n    returns (bytes32 ret)\n  {\n    ret; // silence unused function parameter warning\n    uint num_args = 9;\n    uint selector_bytes = 4;\n    uint length = selector_bytes + num_args * 32;\n    TestEvents.eq(\n      msg.data.length,\n      length,\n      \"calldata length in execute is incorrect\"\n    );\n\n    TestEvents.eq(order.outbound_tkn, _base, \"wrong base\");\n    TestEvents.eq(order.inbound_tkn, _quote, \"wrong quote\");\n    TestEvents.eq(order.wants, 0.05 ether, \"wrong takerWants\");\n    TestEvents.eq(order.gives, 0.05 ether, \"wrong takerGives\");\n    TestEvents.eq(\n      MgvPack.offerDetail_unpack_gasreq(order.offerDetail),\n      200_000,\n      \"wrong gasreq\"\n    );\n    TestEvents.eq(order.offerId, 1, \"wrong offerId\");\n    TestEvents.eq(\n      MgvPack.offer_unpack_wants(order.offer),\n      0.05 ether,\n      \"wrong offerWants\"\n    );\n    TestEvents.eq(\n      MgvPack.offer_unpack_gives(order.offer),\n      0.05 ether,\n      \"wrong offerGives\"\n    );\n    // test flashloan\n    TestEvents.eq(\n      quote.balanceOf(address(this)),\n      0.05 ether,\n      \"wrong quote balance\"\n    );\n    return \"\";\n  }\n\n  function makerPosthook(\n    ML.SingleOrder calldata order,\n    ML.OrderResult calldata result\n  ) external override {}\n\n  function calldata_and_balance_in_makerExecute_are_correct_test() public {\n    bool funded;\n    (funded, ) = address(mgv).call{value: 1 ether}(\"\");\n    base.mint(address(this), 1 ether);\n    uint ofr = mgv.newOffer(\n      _base,\n      _quote,\n      0.05 ether,\n      0.05 ether,\n      200_000,\n      0,\n      0\n    );\n    require(tkr.take(ofr, 0.05 ether), \"take must work or test is void\");\n  }\n\n  function withdraw_removes_freeWei_and_ethers_test() public {\n    uint mgv_bal = address(mgv).balance;\n    uint amt1 = 0.86 ether;\n    uint amt2 = 0.12 ether;\n\n    mkr.provisionMgv(amt1);\n    bool success = mkr.withdrawMgv(amt2);\n    TestEvents.check(success, \"mkr was not able to withdraw from mgv\");\n    TestEvents.eq(mkr.freeWei(), amt1 - amt2, \"incorrect mkr freeWei amount\");\n    TestEvents.eq(\n      address(mgv).balance,\n      mgv_bal + amt1 - amt2,\n      \"incorrect mgv ETH balance\"\n    );\n  }\n\n  function withdraw_too_much_fails_test() public {\n    uint amt1 = 6.003 ether;\n    mkr.provisionMgv(amt1);\n    try mkr.withdrawMgv(amt1 + 1) {\n      TestEvents.fail(\"mkr cannot withdraw more than it has\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/insufficientProvision\", \"wrong revert reason\");\n    }\n  }\n\n  function newOffer_without_freeWei_fails_test() public {\n    try mkr.newOffer(1 ether, 1 ether, 0, 0) {\n      TestEvents.fail(\"mkr cannot create offer without provision\");\n    } catch Error(string memory r) {\n      TestEvents.eq(\n        r,\n        \"mgv/insufficientProvision\",\n        \"new offer failed for wrong reason\"\n      );\n    }\n  }\n\n  function posthook_fail_message_test() public {\n    mkr.provisionMgv(1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50000, 0);\n\n    mkr.setShouldFailHook(true);\n    tkr.take(ofr, 0.1 ether); // fails but we don't care\n\n    TestEvents.expectFrom(address(mgv));\n    emit PosthookFail(_base, _quote, ofr);\n  }\n\n  function badReturn_fails_test() public {\n    mkr.provisionMgv(1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50000, 0);\n\n    mkr.shouldAbort(true);\n    bool success = tkr.take(ofr, 0.1 ether);\n    TestEvents.check(!success, \"take should fail\");\n    mkr.expect(\"abort\");\n  }\n\n  function delete_restores_balance_test() public {\n    mkr.provisionMgv(1 ether);\n    uint bal = mkr.freeWei();\n    mkr.retractOfferWithDeprovision(mkr.newOffer(1 ether, 1 ether, 2300, 0));\n\n    TestEvents.eq(mkr.freeWei(), bal, \"delete has not restored balance\");\n  }\n\n  function delete_offer_log_test() public {\n    mkr.provisionMgv(1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 2300, 0);\n    mkr.retractOfferWithDeprovision(ofr);\n    TestEvents.expectFrom(address(mgv));\n    emit OfferRetract(_base, _quote, ofr);\n  }\n\n  function retract_retracted_does_not_drain_test() public {\n    mkr.provisionMgv(1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 10_000, 0);\n\n    mkr.retractOffer(ofr);\n\n    uint bal1 = mgv.balanceOf(address(mkr));\n    mkr.retractOfferWithDeprovision(ofr);\n    uint bal2 = mgv.balanceOf(address(mkr));\n    TestEvents.less(bal1, bal2, \"Balance should have increased\");\n\n    mkr.retractOfferWithDeprovision(ofr);\n    uint bal3 = mgv.balanceOf(address(mkr));\n    TestEvents.eq(bal3, bal2, \"Balance should not have increased\");\n  }\n\n  function retract_taken_does_not_drain_test() public {\n    mkr.provisionMgv(1 ether);\n    base.mint(address(mkr), 1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n\n    bool success = tkr.take(ofr, 0.1 ether);\n    TestEvents.eq(success, true, \"Snipe should succeed\");\n\n    uint bal1 = mgv.balanceOf(address(mkr));\n    mkr.retractOfferWithDeprovision(ofr);\n    uint bal2 = mgv.balanceOf(address(mkr));\n    TestEvents.less(bal1, bal2, \"Balance should have increased\");\n\n    mkr.retractOfferWithDeprovision(ofr);\n    uint bal3 = mgv.balanceOf(address(mkr));\n    TestEvents.eq(bal3, bal2, \"Balance should not have increased\");\n  }\n\n  function retract_offer_log_test() public {\n    mkr.provisionMgv(1 ether);\n    uint ofr = mkr.newOffer(0.9 ether, 1 ether, 2300, 100);\n    mkr.retractOffer(ofr);\n    TestEvents.expectFrom(address(mgv));\n    emit OfferRetract(_base, _quote, ofr);\n  }\n\n  function retract_offer_maintains_balance_test() public {\n    mkr.provisionMgv(1 ether);\n    uint bal = mkr.freeWei();\n    uint prov = TestUtils.getProvision(mgv, _base, _quote, 2300);\n    mkr.retractOffer(mkr.newOffer(1 ether, 1 ether, 2300, 0));\n    TestEvents.eq(mkr.freeWei(), bal - prov, \"unexpected maker balance\");\n  }\n\n  function retract_middle_offer_leaves_a_valid_book_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(0.9 ether, 1 ether, 2300, 100);\n    uint ofr = mkr.newOffer({\n      wants: 1 ether,\n      gives: 1 ether,\n      gasreq: 2300,\n      gasprice: 100,\n      pivotId: 0\n    });\n    uint ofr1 = mkr.newOffer(1.1 ether, 1 ether, 2300, 100);\n\n    mkr.retractOffer(ofr);\n    TestEvents.check(\n      !mgv.isLive(mgv.offers(_base, _quote, ofr)),\n      \"Offer was not removed from OB\"\n    );\n    (ML.Offer memory offer, ) = mgv.offerInfo(_base, _quote, ofr);\n    TestEvents.eq(offer.prev, ofr0, \"Invalid prev\");\n    TestEvents.eq(offer.next, ofr1, \"Invalid next\");\n    TestEvents.eq(offer.gives, 0, \"offer gives was not set to 0\");\n    TestEvents.eq(offer.gasprice, 100, \"offer gasprice is incorrect\");\n\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, offer.prev)),\n      \"Invalid OB\"\n    );\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, offer.next)),\n      \"Invalid OB\"\n    );\n    (ML.Offer memory offer0, ) = mgv.offerInfo(_base, _quote, offer.prev);\n    (ML.Offer memory offer1, ) = mgv.offerInfo(_base, _quote, offer.next);\n    TestEvents.eq(offer1.prev, ofr0, \"Invalid snitching for ofr1\");\n    TestEvents.eq(offer0.next, ofr1, \"Invalid snitching for ofr0\");\n  }\n\n  function retract_best_offer_leaves_a_valid_book_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr = mkr.newOffer({\n      wants: 1 ether,\n      gives: 1 ether,\n      gasreq: 2300,\n      gasprice: 100,\n      pivotId: 0\n    });\n    uint ofr1 = mkr.newOffer(1.1 ether, 1 ether, 2300, 100);\n    mkr.retractOffer(ofr);\n    TestEvents.check(\n      !mgv.isLive(mgv.offers(_base, _quote, ofr)),\n      \"Offer was not removed from OB\"\n    );\n    (ML.Offer memory offer, ) = mgv.offerInfo(_base, _quote, ofr);\n    TestEvents.eq(offer.prev, 0, \"Invalid prev\");\n    TestEvents.eq(offer.next, ofr1, \"Invalid next\");\n    TestEvents.eq(offer.gives, 0, \"offer gives was not set to 0\");\n    TestEvents.eq(offer.gasprice, 100, \"offer gasprice is incorrect\");\n\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, offer.next)),\n      \"Invalid OB\"\n    );\n    (ML.Offer memory offer1, ) = mgv.offerInfo(_base, _quote, offer.next);\n    TestEvents.eq(offer1.prev, 0, \"Invalid snitching for ofr1\");\n    (, bytes32 cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(\n      MP.local_unpack_best(cfg),\n      ofr1,\n      \"Invalid best after retract\"\n    );\n  }\n\n  function retract_worst_offer_leaves_a_valid_book_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr = mkr.newOffer({\n      wants: 1 ether,\n      gives: 1 ether,\n      gasreq: 2300,\n      gasprice: 100,\n      pivotId: 0\n    });\n    uint ofr0 = mkr.newOffer(0.9 ether, 1 ether, 2300, 100);\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, ofr)),\n      \"Offer was not removed from OB\"\n    );\n    mkr.retractOffer(ofr);\n    (ML.Offer memory offer, ) = mgv.offerInfo(_base, _quote, ofr);\n    TestEvents.eq(offer.prev, ofr0, \"Invalid prev\");\n    TestEvents.eq(offer.next, 0, \"Invalid next\");\n    TestEvents.eq(offer.gives, 0, \"offer gives was not set to 0\");\n    TestEvents.eq(offer.gasprice, 100, \"offer gasprice is incorrect\");\n\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, offer.prev)),\n      \"Invalid OB\"\n    );\n    (ML.Offer memory offer0, ) = mgv.offerInfo(_base, _quote, offer.prev);\n    TestEvents.eq(offer0.next, 0, \"Invalid snitching for ofr0\");\n    (, bytes32 cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(\n      MP.local_unpack_best(cfg),\n      ofr0,\n      \"Invalid best after retract\"\n    );\n  }\n\n  function delete_wrong_offer_fails_test() public {\n    mkr.provisionMgv(1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 2300, 0);\n    try mkr2.retractOfferWithDeprovision(ofr) {\n      TestEvents.fail(\"mkr2 should not be able to delete mkr's offer\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/retractOffer/unauthorized\", \"wrong revert reason\");\n    }\n  }\n\n  function retract_wrong_offer_fails_test() public {\n    mkr.provisionMgv(1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 2300, 0);\n    try mkr2.retractOffer(ofr) {\n      TestEvents.fail(\"mkr2 should not be able to retract mkr's offer\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/retractOffer/unauthorized\", \"wrong revert reason\");\n    }\n  }\n\n  function gasreq_max_with_newOffer_ok_test() public {\n    mkr.provisionMgv(1 ether);\n    uint gasmax = 750000;\n    mgv.setGasmax(gasmax);\n    mkr.newOffer(1 ether, 1 ether, gasmax, 0);\n  }\n\n  function gasreq_too_high_fails_newOffer_test() public {\n    uint gasmax = 12;\n    mgv.setGasmax(gasmax);\n    try mkr.newOffer(1 ether, 1 ether, gasmax + 1, 0) {\n      TestEvents.fail(\"gasreq above gasmax, newOffer should fail\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/writeOffer/gasreq/tooHigh\", \"wrong revert reason\");\n    }\n  }\n\n  function min_density_with_newOffer_ok_test() public {\n    mkr.provisionMgv(1 ether);\n    uint density = 10**7;\n    mgv.setGasbase(_base, _quote, 0, 1);\n    mgv.setDensity(_base, _quote, density);\n    mkr.newOffer(1 ether, density, 0, 0);\n  }\n\n  function low_density_fails_newOffer_test() public {\n    uint density = 10**7;\n    mgv.setGasbase(_base, _quote, 0, 1);\n    mgv.setDensity(_base, _quote, density);\n    try mkr.newOffer(1 ether, density - 1, 0, 0) {\n      TestEvents.fail(\"density too low, newOffer should fail\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/writeOffer/density/tooLow\", \"wrong revert reason\");\n    }\n  }\n\n  function maker_gets_no_freeWei_on_partial_fill_test() public {\n    mkr.provisionMgv(1 ether);\n    base.mint(address(mkr), 1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    uint oldBalance = mgv.balanceOf(address(mkr));\n    bool success = tkr.take(ofr, 0.1 ether);\n    TestEvents.check(success, \"take must succeed\");\n    TestEvents.eq(\n      mgv.balanceOf(address(mkr)),\n      oldBalance,\n      \"mkr balance must not change\"\n    );\n  }\n\n  function maker_gets_no_freeWei_on_full_fill_test() public {\n    mkr.provisionMgv(1 ether);\n    base.mint(address(mkr), 1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    uint oldBalance = mgv.balanceOf(address(mkr));\n    bool success = tkr.take(ofr, 1 ether);\n    TestEvents.check(success, \"take must succeed\");\n    TestEvents.eq(\n      mgv.balanceOf(address(mkr)),\n      oldBalance,\n      \"mkr balance must not change\"\n    );\n  }\n\n  function insertions_are_correctly_ordered_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr2 = mkr.newOffer(1.1 ether, 1 ether, 100_000, 0);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.1 ether, 1 ether, 50_000, 0);\n    uint ofr01 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (, bytes32 loc_cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(ofr0, MP.local_unpack_best(loc_cfg), \"Wrong best offer\");\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, ofr0)),\n      \"Oldest equivalent offer should be first\"\n    );\n    (MgvLib.Offer memory offer, ) = mgv.offerInfo(_base, _quote, ofr0);\n    uint _ofr01 = offer.next;\n    TestEvents.eq(_ofr01, ofr01, \"Wrong 2nd offer\");\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, _ofr01)),\n      \"Oldest equivalent offer should be first\"\n    );\n    (offer, ) = mgv.offerInfo(_base, _quote, _ofr01);\n    uint _ofr1 = offer.next;\n    TestEvents.eq(_ofr1, ofr1, \"Wrong 3rd offer\");\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, _ofr1)),\n      \"Oldest equivalent offer should be first\"\n    );\n    (offer, ) = mgv.offerInfo(_base, _quote, _ofr1);\n    uint _ofr2 = offer.next;\n    TestEvents.eq(_ofr2, ofr2, \"Wrong 4th offer\");\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, _ofr2)),\n      \"Oldest equivalent offer should be first\"\n    );\n    (offer, ) = mgv.offerInfo(_base, _quote, _ofr2);\n    TestEvents.eq(offer.next, 0, \"Invalid OB\");\n  }\n\n  // insertTest price, density (gives/gasreq) vs (gives'/gasreq'), age\n  // nolongerBest\n  // idemPrice\n  // idemBest\n  // A.BCD --> ABC.D\n\n  function update_offer_resets_age_and_updates_best_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (, bytes32 cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(ofr0, MP.local_unpack_best(cfg), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether, 100_000, ofr0, ofr0);\n    (, cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(\n      ofr1,\n      MP.local_unpack_best(cfg),\n      \"Best offer should have changed\"\n    );\n  }\n\n  function update_offer_price_nolonger_best_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (, bytes32 cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(ofr0, MP.local_unpack_best(cfg), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether + 1, 1.0 ether, 100_000, ofr0, ofr0);\n    (, cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(\n      ofr1,\n      MP.local_unpack_best(cfg),\n      \"Best offer should have changed\"\n    );\n  }\n\n  function update_offer_density_nolonger_best_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (, bytes32 cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(ofr0, MP.local_unpack_best(cfg), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether, 100_001, ofr0, ofr0);\n    (, cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(\n      ofr1,\n      MP.local_unpack_best(cfg),\n      \"Best offer should have changed\"\n    );\n  }\n\n  function update_offer_price_with_self_as_pivot_becomes_best_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (, bytes32 cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(ofr0, MP.local_unpack_best(cfg), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether + 1, 100_000, ofr1, ofr1);\n    (, cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(\n      ofr1,\n      MP.local_unpack_best(cfg),\n      \"Best offer should have changed\"\n    );\n  }\n\n  function update_offer_density_with_self_as_pivot_becomes_best_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1.0 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1.0 ether, 100_000, 0);\n    (, bytes32 cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(ofr0, MP.local_unpack_best(cfg), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether, 99_999, ofr1, ofr1);\n    (, cfg) = mgv.config(_base, _quote);\n    TestUtils.logOfferBook(mgv, _base, _quote, 2);\n    TestEvents.eq(\n      MP.local_unpack_best(cfg),\n      ofr1,\n      \"Best offer should have changed\"\n    );\n  }\n\n  function update_offer_price_with_best_as_pivot_becomes_best_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (, bytes32 cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(ofr0, MP.local_unpack_best(cfg), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether + 1, 100_000, ofr0, ofr1);\n    (, cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(\n      ofr1,\n      MP.local_unpack_best(cfg),\n      \"Best offer should have changed\"\n    );\n  }\n\n  function update_offer_density_with_best_as_pivot_becomes_best_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1.0 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1.0 ether, 100_000, 0);\n    (, bytes32 cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(ofr0, MP.local_unpack_best(cfg), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether, 99_999, ofr0, ofr1);\n    (, cfg) = mgv.config(_base, _quote);\n    TestUtils.logOfferBook(mgv, _base, _quote, 2);\n    TestEvents.eq(\n      MP.local_unpack_best(cfg),\n      ofr1,\n      \"Best offer should have changed\"\n    );\n  }\n\n  function update_offer_price_with_best_as_pivot_changes_prevnext_test()\n    public\n  {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr2 = mkr.newOffer(1.1 ether, 1 ether, 100_000, 0);\n    uint ofr3 = mkr.newOffer(1.2 ether, 1 ether, 100_000, 0);\n\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, ofr)),\n      \"Insertion error\"\n    );\n    (MgvLib.Offer memory offer, ) = mgv.offerInfo(_base, _quote, ofr);\n    TestEvents.eq(offer.prev, ofr0, \"Wrong prev offer\");\n    TestEvents.eq(offer.next, ofr1, \"Wrong next offer\");\n    mkr.updateOffer(1.1 ether, 1.0 ether, 100_000, ofr0, ofr);\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, ofr)),\n      \"Insertion error\"\n    );\n    (offer, ) = mgv.offerInfo(_base, _quote, ofr);\n    TestEvents.eq(offer.prev, ofr2, \"Wrong prev offer after update\");\n    TestEvents.eq(offer.next, ofr3, \"Wrong next offer after update\");\n  }\n\n  function update_offer_price_with_self_as_pivot_changes_prevnext_test()\n    public\n  {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr2 = mkr.newOffer(1.1 ether, 1 ether, 100_000, 0);\n    uint ofr3 = mkr.newOffer(1.2 ether, 1 ether, 100_000, 0);\n\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, ofr)),\n      \"Insertion error\"\n    );\n    (MgvLib.Offer memory offer, ) = mgv.offerInfo(_base, _quote, ofr);\n    TestEvents.eq(offer.prev, ofr0, \"Wrong prev offer\");\n    TestEvents.eq(offer.next, ofr1, \"Wrong next offer\");\n    mkr.updateOffer(1.1 ether, 1.0 ether, 100_000, ofr, ofr);\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, ofr)),\n      \"Insertion error\"\n    );\n    (offer, ) = mgv.offerInfo(_base, _quote, ofr);\n    TestEvents.eq(offer.prev, ofr2, \"Wrong prev offer after update\");\n    TestEvents.eq(offer.next, ofr3, \"Wrong next offer after update\");\n  }\n\n  function update_offer_density_with_best_as_pivot_changes_prevnext_test()\n    public\n  {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr2 = mkr.newOffer(1.0 ether, 1 ether, 100_001, 0);\n    uint ofr3 = mkr.newOffer(1.0 ether, 1 ether, 100_002, 0);\n\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, ofr)),\n      \"Insertion error\"\n    );\n    (MgvLib.Offer memory offer, ) = mgv.offerInfo(_base, _quote, ofr);\n    TestEvents.eq(offer.prev, ofr0, \"Wrong prev offer\");\n    TestEvents.eq(offer.next, ofr1, \"Wrong next offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether, 100_001, ofr0, ofr);\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, ofr)),\n      \"Update error\"\n    );\n    (offer, ) = mgv.offerInfo(_base, _quote, ofr);\n    TestEvents.eq(offer.prev, ofr2, \"Wrong prev offer after update\");\n    TestEvents.eq(offer.next, ofr3, \"Wrong next offer after update\");\n  }\n\n  function update_offer_density_with_self_as_pivot_changes_prevnext_test()\n    public\n  {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr1 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    uint ofr2 = mkr.newOffer(1.0 ether, 1 ether, 100_001, 0);\n    uint ofr3 = mkr.newOffer(1.0 ether, 1 ether, 100_002, 0);\n\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, ofr)),\n      \"Insertion error\"\n    );\n    (MgvLib.Offer memory offer, ) = mgv.offerInfo(_base, _quote, ofr);\n    TestEvents.eq(offer.prev, ofr0, \"Wrong prev offer\");\n    TestEvents.eq(offer.next, ofr1, \"Wrong next offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether, 100_001, ofr, ofr);\n    TestEvents.check(\n      mgv.isLive(mgv.offers(_base, _quote, ofr)),\n      \"Insertion error\"\n    );\n    (offer, ) = mgv.offerInfo(_base, _quote, ofr);\n    TestEvents.eq(offer.prev, ofr2, \"Wrong prev offer after update\");\n    TestEvents.eq(offer.next, ofr3, \"Wrong next offer after update\");\n  }\n\n  function update_offer_after_higher_gasprice_change_fails_test() public {\n    uint provision = TestUtils.getProvision(mgv, _base, _quote, 100_000);\n    mkr.provisionMgv(provision);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (bytes32 cfg, ) = mgv.config(_base, _quote);\n    mgv.setGasprice(MP.global_unpack_gasprice(cfg) + 1); //gasprice goes up\n    try mkr.updateOffer(1.0 ether + 2, 1.0 ether, 100_000, ofr0, ofr0) {\n      TestEvents.fail(\"Update offer should have failed\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/insufficientProvision\", \"wrong revert reason\");\n    }\n  }\n\n  function update_offer_after_higher_gasprice_change_succeeds_when_over_provisioned_test()\n    public\n  {\n    (bytes32 cfg, ) = mgv.config(_base, _quote);\n    uint gasprice = MP.global_unpack_gasprice(cfg);\n    uint provision = TestUtils.getProvision(\n      mgv,\n      _base,\n      _quote,\n      100_000,\n      gasprice\n    );\n    mkr.provisionMgv(provision * 2); // provisionning twice the required amount\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0); // locking exact bounty\n    mgv.setGasprice(gasprice + 1); //gasprice goes up\n    uint provision_ = TestUtils.getProvision( // new theoretical provision\n      mgv,\n      _base,\n      _quote,\n      100_000,\n      gasprice + 1\n    );\n    (cfg, ) = mgv.config(_base, _quote);\n    try mkr.updateOffer(1.0 ether + 2, 1.0 ether, 100_000, ofr0, ofr0) {\n      TestEvents.expectFrom(address(mgv));\n      emit Credit(address(mkr), provision * 2);\n      emit OfferWrite(\n        _base,\n        _quote,\n        address(mkr),\n        1.0 ether,\n        1.0 ether,\n        gasprice, // offer at old gasprice\n        100_000,\n        ofr0,\n        0\n      );\n      emit Debit(address(mkr), provision); // transfering missing provision into offer bounty\n      emit OfferWrite(\n        _base,\n        _quote,\n        address(mkr),\n        1.0 ether + 2,\n        1.0 ether,\n        MP.global_unpack_gasprice(cfg), // offer gasprice should be the new gasprice\n        100_000,\n        ofr0,\n        0\n      );\n      emit Debit(address(mkr), provision_ - provision); // transfering missing provision into offer bounty\n    } catch {\n      TestEvents.fail(\"Update offer should have succeeded\");\n    }\n  }\n\n  function update_offer_after_lower_gasprice_change_succeeds_test() public {\n    uint provision = TestUtils.getProvision(mgv, _base, _quote, 100_000);\n    mkr.provisionMgv(provision);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    (bytes32 cfg, ) = mgv.config(_base, _quote);\n    mgv.setGasprice(MP.global_unpack_gasprice(cfg) - 1); //gasprice goes down\n    uint _provision = TestUtils.getProvision(mgv, _base, _quote, 100_000);\n    try mkr.updateOffer(1.0 ether + 2, 1.0 ether, 100_000, ofr0, ofr0) {\n      TestEvents.eq(\n        mgv.balanceOf(address(mkr)),\n        provision - _provision,\n        \"Maker balance is incorrect\"\n      );\n      TestEvents.expectFrom(address(mgv));\n      emit Credit(address(mkr), provision - _provision);\n    } catch {\n      TestEvents.fail(\"Update offer should have succeeded\");\n    }\n  }\n\n  function update_offer_next_to_itself_does_not_break_ob_test() public {\n    mkr.provisionMgv(1 ether);\n    uint left = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    uint right = mkr.newOffer(1 ether + 3, 1 ether, 100_000, 0);\n    uint center = mkr.newOffer(1 ether + 1, 1 ether, 100_000, 0);\n    mkr.updateOffer(1 ether + 2, 1 ether, 100_000, center, center);\n    (MgvLib.Offer memory ofr, ) = mgv.offerInfo(_base, _quote, center);\n    TestEvents.eq(ofr.prev, left, \"ofr.prev should be unchanged\");\n    TestEvents.eq(ofr.next, right, \"ofr.next should be unchanged\");\n  }\n\n  function update_on_retracted_offer_test() public {\n    uint provision = TestUtils.getProvision(mgv, _base, _quote, 100_000);\n    mkr.provisionMgv(provision);\n    uint offerId = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    mkr.retractOfferWithDeprovision(offerId);\n    mkr.withdrawMgv(provision);\n    TestEvents.eq(\n      mgv.balanceOf(address(mkr)),\n      0,\n      \"Maker should have no more provision on Mangrove\"\n    );\n    (MgvLib.Offer memory ofr, ) = mgv.offerInfo(_base, _quote, offerId);\n    TestEvents.eq(ofr.gives, 0, \"Retracted offer should have 0 gives\");\n    TestEvents.eq(\n      ofr.gasprice,\n      0,\n      \"Deprovisioned offer should have 0 gasprice\"\n    );\n    try mkr.updateOffer(1 ether + 2, 1 ether, 100_000, offerId, offerId) {\n      TestEvents.fail(\n        \"Deprovisioned offer cannot be updated unless reprovisioned\"\n      );\n    } catch Error(string memory message) {\n      TestEvents.eq(message, \"mgv/insufficientProvision\", \"\");\n      mkr.provisionMgv(provision);\n      try mkr.updateOffer(1 ether + 2, 1 ether, 100_000, offerId, offerId) {\n        (ofr, ) = mgv.offerInfo(_base, _quote, offerId);\n        TestEvents.eq(ofr.gives, 1 ether, \"Offer not correctly updated\");\n      } catch {\n        TestEvents.fail(\"Updating offer should succeed\");\n      }\n    }\n  }\n\n  function testOBBest(uint id) internal {\n    (MgvLib.Offer memory ofr, ) = mgv.offerInfo(_base, _quote, id);\n    TestEvents.eq(mgv.best(_base, _quote), id, \"testOBBest: not best\");\n    TestEvents.eq(ofr.prev, 0, \"testOBBest: prev not 0\");\n  }\n\n  function testOBWorst(uint id) internal {\n    (MgvLib.Offer memory ofr, ) = mgv.offerInfo(_base, _quote, id);\n    TestEvents.eq(ofr.next, 0, \"testOBWorst fail\");\n  }\n\n  function testOBLink(uint left, uint right) internal {\n    (MgvLib.Offer memory ofr, ) = mgv.offerInfo(_base, _quote, left);\n    TestEvents.eq(ofr.next, right, \"testOBLink: wrong ofr.next\");\n    (ofr, ) = mgv.offerInfo(_base, _quote, right);\n    TestEvents.eq(ofr.prev, left, \"testOBLink: wrong ofr.prev\");\n  }\n\n  function testOBOrder(uint[1] memory ids) internal {\n    testOBBest(ids[0]);\n    testOBWorst(ids[0]);\n  }\n\n  function testOBOrder(uint[2] memory ids) internal {\n    testOBBest(ids[0]);\n    testOBLink(ids[0], ids[1]);\n    testOBWorst(ids[1]);\n  }\n\n  function testOBOrder(uint[3] memory ids) internal {\n    testOBBest(ids[0]);\n    testOBLink(ids[0], ids[1]);\n    testOBLink(ids[1], ids[2]);\n    testOBWorst(ids[2]);\n  }\n\n  function complex_offer_update_left_1_1_test() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    mkr.updateOffer(x + 1, x, g, 0, two);\n\n    testOBOrder([one, two]);\n  }\n\n  function complex_offer_update_right_1_test() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    mkr.updateOffer(x + 1, x, g, two, two);\n\n    testOBOrder([one, two]);\n  }\n\n  function complex_offer_update_left_1_2_test() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    mkr.updateOffer(x + 5, x, g, 0, two);\n\n    testOBOrder([one, two]);\n  }\n\n  function complex_offer_update_right_1_2_test() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    mkr.updateOffer(x + 5, x, g, two, two);\n\n    testOBOrder([one, two]);\n  }\n\n  function complex_offer_update_left_2_test() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    uint three = mkr.newOffer(x + 5, x, g, 0);\n    mkr.updateOffer(x + 1, x, g, 0, three);\n\n    testOBOrder([one, three, two]);\n  }\n\n  function complex_offer_update_right_2_test() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    uint three = mkr.newOffer(x + 5, x, g, 0);\n    mkr.updateOffer(x + 4, x, g, three, one);\n\n    testOBOrder([two, one, three]);\n  }\n\n  function complex_offer_update_left_3_test() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    mkr.retractOffer(two);\n    mkr.updateOffer(x + 3, x, g, 0, two);\n\n    testOBOrder([one, two]);\n  }\n\n  function complex_offer_update_right_3_test() public {\n    mkr.provisionMgv(1 ether);\n    uint x = 1 ether;\n    uint g = 100_000;\n\n    uint one = mkr.newOffer(x, x, g, 0);\n    uint two = mkr.newOffer(x + 3, x, g, 0);\n    mkr.retractOffer(one);\n    mkr.updateOffer(x, x, g, 0, one);\n\n    testOBOrder([one, two]);\n  }\n\n  function update_offer_prev_to_itself_does_not_break_ob_test() public {\n    mkr.provisionMgv(1 ether);\n    uint left = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    uint right = mkr.newOffer(1 ether + 3, 1 ether, 100_000, 0);\n    uint center = mkr.newOffer(1 ether + 2, 1 ether, 100_000, 0);\n    mkr.updateOffer(1 ether + 1, 1 ether, 100_000, center, center);\n    (MgvLib.Offer memory ofr, ) = mgv.offerInfo(_base, _quote, center);\n    TestEvents.eq(ofr.prev, left, \"ofr.prev should be unchanged\");\n    TestEvents.eq(ofr.next, right, \"ofr.next should be unchanged\");\n  }\n\n  function update_offer_price_stays_best_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1.0 ether + 2, 1 ether, 100_000, 0);\n    (, bytes32 cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(ofr0, MP.local_unpack_best(cfg), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether + 1, 1.0 ether, 100_000, ofr0, ofr0);\n    (, cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(\n      ofr0,\n      MP.local_unpack_best(cfg),\n      \"Best offer should not have changed\"\n    );\n  }\n\n  function update_offer_density_stays_best_test() public {\n    mkr.provisionMgv(10 ether);\n    uint ofr0 = mkr.newOffer(1.0 ether, 1 ether, 100_000, 0);\n    mkr.newOffer(1.0 ether, 1 ether, 100_002, 0);\n    (, bytes32 cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(ofr0, MP.local_unpack_best(cfg), \"Wrong best offer\");\n    mkr.updateOffer(1.0 ether, 1.0 ether, 100_001, ofr0, ofr0);\n    (, cfg) = mgv.config(_base, _quote);\n    TestEvents.eq(\n      ofr0,\n      MP.local_unpack_best(cfg),\n      \"Best offer should not have changed\"\n    );\n  }\n\n  function gasbase_is_deducted_1_test() public {\n    uint overhead_gasbase = 100_000;\n    uint offer_gasbase = 20_000;\n    mkr.provisionMgv(1 ether);\n    mgv.setGasbase(_base, _quote, overhead_gasbase, offer_gasbase);\n    mgv.setGasprice(1);\n    mgv.setDensity(_base, _quote, 0);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 0, 0);\n    tkr.take(ofr, 0.1 ether);\n    TestEvents.eq(\n      mgv.balanceOf(address(mkr)),\n      1 ether - (overhead_gasbase + offer_gasbase) * 10**9,\n      \"Wrong gasbase deducted\"\n    );\n  }\n\n  function gasbase_is_deducted_2_test() public {\n    uint overhead_gasbase = 100_000;\n    uint offer_gasbase = 20_000;\n    mkr.provisionMgv(1 ether);\n    mgv.setGasbase(_base, _quote, overhead_gasbase, offer_gasbase);\n    mgv.setGasprice(1);\n    mgv.setDensity(_base, _quote, 0);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 0, 0);\n    tkr.take(ofr, 0.1 ether);\n    TestEvents.eq(\n      mgv.balanceOf(address(mkr)),\n      1 ether - (overhead_gasbase + offer_gasbase) * 10**9,\n      \"Wrong gasbase deducted\"\n    );\n  }\n\n  // test gasbase deduction and test that gasbase changes are tracked\n  function gasbase_with_change_is_deducted_multi_1_test() public {\n    uint overhead_gasbase = 100_000;\n    uint offer_gasbase = 20_000;\n    mkr.provisionMgv(1 ether);\n    mkr2.provisionMgv(1 ether);\n    mgv.setGasbase(_base, _quote, overhead_gasbase, offer_gasbase);\n    mgv.setGasprice(1);\n    mgv.setDensity(_base, _quote, 0);\n    mkr2.newOffer(1 ether, 1 ether, 0, 0);\n    mkr.newOffer(1 ether, 1 ether, 0, 0);\n    overhead_gasbase = 90_000;\n    offer_gasbase = 10_000;\n    mgv.setGasbase(_base, _quote, overhead_gasbase, offer_gasbase);\n    tkr.marketOrder(0.1 ether, 0.1 ether);\n    TestEvents.eq(\n      mgv.balanceOf(address(mkr)),\n      1 ether - (overhead_gasbase / 2 + offer_gasbase) * 10**9,\n      \"Wrong gasbase deducted\"\n    );\n  }\n\n  // test gasbase deduction and test that gasbase changes are tracked\n  function gasbase_is_deducted_multi_2_test() public {\n    uint overhead_gasbase = 100_000;\n    uint offer_gasbase = 20_000;\n    mkr.provisionMgv(1 ether);\n    mkr2.provisionMgv(1 ether);\n    mgv.setGasbase(_base, _quote, overhead_gasbase, offer_gasbase);\n    mgv.setGasprice(1);\n    mgv.setDensity(_base, _quote, 0);\n    mkr2.newOffer(1 ether, 1 ether, 0, 0);\n    mkr2.newOffer(1 ether, 1 ether, 0, 0);\n    mkr.newOffer(1 ether, 1 ether, 0, 0);\n    overhead_gasbase = 90_000;\n    offer_gasbase = 10_000;\n    mgv.setGasbase(_base, _quote, overhead_gasbase, offer_gasbase);\n    tkr.marketOrder(0.1 ether, 0.1 ether);\n    TestEvents.eq(\n      mgv.balanceOf(address(mkr)),\n      1 ether - (overhead_gasbase / 3 + offer_gasbase) * 10**9,\n      \"Wrong gasbase deducted\"\n    );\n  }\n\n  function gasbase_is_deducted_multi_3_test() public {\n    uint overhead_gasbase = 30_000;\n    uint offer_gasbase = 20_000;\n    mkr.provisionMgv(1 ether);\n    mkr2.provisionMgv(1 ether);\n    mgv.setGasbase(_base, _quote, overhead_gasbase, offer_gasbase);\n    mgv.setGasprice(1);\n    mgv.setDensity(_base, _quote, 0);\n    mkr2.newOffer(1 ether, 1 ether, 0, 0);\n    mkr.newOffer(1 ether, 1 ether, 0, 0);\n    mkr.newOffer(1 ether, 1 ether, 0, 0);\n    overhead_gasbase = 21_000;\n    offer_gasbase = 10_000;\n    mgv.setGasbase(_base, _quote, overhead_gasbase, offer_gasbase);\n    tkr.marketOrder(0.1 ether, 0.1 ether);\n    TestEvents.eq(\n      mgv.balanceOf(address(mkr)),\n      1 ether - ((2 * overhead_gasbase) / 3 + offer_gasbase * 2) * 10**9,\n      \"Wrong gasbase deducted\"\n    );\n  }\n\n  function penalty_gasprice_is_mgv_gasprice_test() public {\n    mgv.setGasprice(10);\n    mkr.shouldFail(true);\n    mkr.provisionMgv(1 ether);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    uint oldProvision = mgv.balanceOf(address(mkr));\n    mgv.setGasprice(10000);\n    (uint gave, uint got) = tkr.marketOrder(1 ether, 1 ether);\n    TestEvents.check(gave == got && got == 0, \"market Order should be noop\");\n    uint gotBack = mgv.balanceOf(address(mkr)) - oldProvision;\n    TestEvents.eq(gotBack, 0, \"Should not have gotten any provision back\");\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Integration/Scenarii.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\n\n//import \"../Mangrove.sol\";\n//import \"../MgvLib.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"../Toolbox/TestUtils.sol\";\n// import \"../Toolbox/Display.sol\";\n\nimport \"../Agents/TestToken.sol\";\nimport \"../Agents/TestMaker.sol\";\nimport \"../Agents/TestMoriartyMaker.sol\";\nimport \"../Agents/MakerDeployer.sol\";\nimport \"../Agents/TestTaker.sol\";\nimport \"../Agents/TestDelegateTaker.sol\";\nimport \"../Agents/OfferManager.sol\";\n\nimport \"./TestCancelOffer.sol\";\nimport \"./TestCollectFailingOffer.sol\";\nimport \"./TestInsert.sol\";\nimport \"./TestSnipe.sol\";\nimport \"./TestFailingMarketOrder.sol\";\nimport \"./TestMarketOrder.sol\";\n\n// Pretest libraries are for deploying large contracts independently.\n// Otherwise bytecode can be too large. See EIP 170 for more on size limit:\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-170.md\n\ncontract Scenarii_Test {\n  AbstractMangrove mgv;\n  TestTaker taker;\n  MakerDeployer makers;\n  TestToken base;\n  TestToken quote;\n  TestUtils.Balances balances;\n  uint[] offerOf;\n\n  mapping(uint => mapping(TestUtils.Info => uint)) offers;\n\n  receive() external payable {}\n\n  function saveOffers() internal {\n    uint offerId = mgv.best(address(base), address(quote));\n    while (offerId != 0) {\n      (ML.Offer memory offer, ML.OfferDetail memory offerDetail) = mgv\n        .offerInfo(address(base), address(quote), offerId);\n      offers[offerId][TestUtils.Info.makerWants] = offer.wants;\n      offers[offerId][TestUtils.Info.makerGives] = offer.gives;\n      offers[offerId][TestUtils.Info.gasreq] = offerDetail.gasreq;\n      offerId = offer.next;\n    }\n  }\n\n  function saveBalances() internal {\n    uint[] memory balA = new uint[](makers.length());\n    uint[] memory balB = new uint[](makers.length());\n    uint[] memory balWei = new uint[](makers.length());\n    for (uint i = 0; i < makers.length(); i++) {\n      balA[i] = base.balanceOf(address(makers.getMaker(i)));\n      balB[i] = quote.balanceOf(address(makers.getMaker(i)));\n      balWei[i] = mgv.balanceOf(address(makers.getMaker(i)));\n    }\n    balances = TestUtils.Balances({\n      mgvBalanceWei: address(mgv).balance,\n      mgvBalanceFees: base.balanceOf(TestUtils.adminOf(mgv)),\n      takerBalanceA: base.balanceOf(address(taker)),\n      takerBalanceB: quote.balanceOf(address(taker)),\n      takerBalanceWei: mgv.balanceOf(address(taker)),\n      makersBalanceA: balA,\n      makersBalanceB: balB,\n      makersBalanceWei: balWei\n    });\n  }\n\n  function a_deployToken_beforeAll() public {\n    //console.log(\"IN BEFORE ALL\");\n    base = TokenSetup.setup(\"A\", \"$A\");\n    quote = TokenSetup.setup(\"B\", \"$B\");\n\n    TestUtils.not0x(address(base));\n    TestUtils.not0x(address(quote));\n\n    Display.register(address(0), \"NULL_ADDRESS\");\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"Mgv_Test\");\n    Display.register(address(base), \"base\");\n    Display.register(address(quote), \"quote\");\n  }\n\n  function b_deployMgv_beforeAll() public {\n    mgv = MgvSetup.setup(base, quote);\n    Display.register(address(mgv), \"Mgv\");\n    TestUtils.not0x(address(mgv));\n    mgv.setFee(address(base), address(quote), 300);\n  }\n\n  function c_deployMakersTaker_beforeAll() public {\n    makers = MakerDeployerSetup.setup(mgv, address(base), address(quote));\n    makers.deploy(4);\n    for (uint i = 1; i < makers.length(); i++) {\n      Display.register(\n        address(makers.getMaker(i)),\n        TestUtils.append(\"maker-\", TestUtils.uint2str(i))\n      );\n    }\n    Display.register(address(makers.getMaker(0)), \"failer\");\n    taker = TakerSetup.setup(mgv, address(base), address(quote));\n    Display.register(address(taker), \"taker\");\n  }\n\n  function d_provisionAll_beforeAll() public {\n    // low level tranfer because makers needs gas to transfer to each maker\n    (bool success, ) = address(makers).call{gas: gasleft(), value: 80 ether}(\n      \"\"\n    ); // msg.value is distributed evenly amongst makers\n    require(success, \"maker transfer\");\n\n    for (uint i = 0; i < makers.length(); i++) {\n      TestMaker maker = makers.getMaker(i);\n      maker.provisionMgv(10 ether);\n      base.mint(address(maker), 5 ether);\n    }\n\n    quote.mint(address(taker), 5 ether);\n    taker.approveMgv(quote, 5 ether);\n    taker.approveMgv(base, 50 ether);\n    saveBalances();\n  }\n\n  function snipe_insert_and_fail_test() public {\n    offerOf = TestInsert.run(balances, mgv, makers, taker, base, quote);\n    //TestUtils.printOfferBook(mgv);\n    TestUtils.logOfferBook(mgv, address(base), address(quote), 4);\n\n    //TestEvents.logString(\"=== Snipe test ===\", 0);\n    saveBalances();\n    saveOffers();\n    TestSnipe.run(balances, offers, mgv, makers, taker, base, quote);\n    TestUtils.logOfferBook(mgv, address(base), address(quote), 4);\n\n    // restore offer that was deleted after partial fill, minus taken amount\n    makers.getMaker(2).updateOffer(\n      1 ether - 0.375 ether,\n      0.8 ether - 0.3 ether,\n      80_000,\n      0,\n      2\n    );\n\n    TestUtils.logOfferBook(mgv, address(base), address(quote), 4);\n\n    //TestEvents.logString(\"=== Market order test ===\", 0);\n    saveBalances();\n    saveOffers();\n    TestMarketOrder.run(balances, offers, mgv, makers, taker, base, quote);\n    TestUtils.logOfferBook(mgv, address(base), address(quote), 4);\n\n    //TestEvents.logString(\"=== Failling offer test ===\", 0);\n    saveBalances();\n    saveOffers();\n    TestCollectFailingOffer.run(\n      balances,\n      offers,\n      mgv,\n      offerOf[0],\n      makers,\n      taker,\n      base,\n      quote\n    );\n    TestUtils.logOfferBook(mgv, address(base), address(quote), 4);\n    saveBalances();\n    saveOffers();\n  }\n}\n\ncontract DeepCollect_Test {\n  TestToken base;\n  TestToken quote;\n  AbstractMangrove mgv;\n  TestTaker tkr;\n  TestMoriartyMaker evil;\n\n  receive() external payable {}\n\n  function a_beforeAll() public {\n    base = TokenSetup.setup(\"A\", \"$A\");\n    quote = TokenSetup.setup(\"B\", \"$B\");\n    mgv = MgvSetup.setup(base, quote);\n    tkr = TakerSetup.setup(mgv, address(base), address(quote));\n\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"DeepCollect_Tester\");\n    Display.register(address(base), \"$A\");\n    Display.register(address(quote), \"$B\");\n    Display.register(address(mgv), \"mgv\");\n    Display.register(address(tkr), \"taker\");\n\n    quote.mint(address(tkr), 5 ether);\n    tkr.approveMgv(quote, 20 ether);\n    tkr.approveMgv(base, 20 ether);\n\n    evil = new TestMoriartyMaker(mgv, address(base), address(quote));\n    Display.register(address(evil), \"Moriarty\");\n\n    (bool success, ) = address(evil).call{gas: gasleft(), value: 20 ether}(\"\");\n    require(success, \"maker transfer\");\n    evil.provisionMgv(10 ether);\n    base.mint(address(evil), 5 ether);\n    evil.approveMgv(base, 5 ether);\n\n    evil.newOffer({\n      wants: 1 ether,\n      gives: 0.5 ether,\n      gasreq: 100000,\n      pivotId: 0\n    });\n  }\n\n  function market_with_failures_test() public {\n    //TestEvents.logString(\"=== DeepCollect test ===\", 0);\n    TestFailingMarketOrder.moWithFailures(\n      mgv,\n      address(base),\n      address(quote),\n      tkr\n    );\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Agents/TestDelegateTaker.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\nimport \"../../AbstractMangrove.sol\";\nimport \"./OfferManager.sol\";\nimport \"./TestToken.sol\";\n\ncontract TestDelegateTaker is ITaker {\n  OfferManager ofrMgr;\n  TestToken base;\n  TestToken quote;\n\n  constructor(\n    OfferManager _ofrMgr,\n    TestToken _base,\n    TestToken _quote\n  ) {\n    ofrMgr = _ofrMgr;\n    base = _base;\n    quote = _quote;\n  }\n\n  receive() external payable {}\n\n  function takerTrade(\n    //NB this is not called if mgv is not a flashTaker mgv\n    address,\n    address,\n    uint,\n    uint shouldGive\n  ) external override {\n    if (msg.sender == address(ofrMgr)) {\n      TestToken(quote).mint(address(this), shouldGive); // taker should have been given admin status for quote\n    } // taker should have approved ofrMgr for quote\n  }\n\n  function delegateOrder(\n    OfferManager mgr,\n    uint wants,\n    uint gives,\n    AbstractMangrove mgv,\n    bool invertedResidual\n  ) public {\n    try quote.approve(address(mgr), gives) {\n      mgr.order{value: 0.01 ether}(\n        mgv,\n        address(base),\n        address(quote),\n        wants,\n        gives,\n        invertedResidual\n      );\n    } catch {\n      require(false, \"failed to approve mgr\");\n    }\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Integration/TestCancelOffer.sol": {
      "content": "pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\nimport \"../Toolbox/TestUtils.sol\";\n\nlibrary TestCancelOffer {\n  function run(\n    TestUtils.Balances storage balances,\n    mapping(uint => mapping(TestUtils.Info => uint)) storage offers,\n    AbstractMangrove mgv,\n    TestMaker wrongOwner,\n    TestMaker maker,\n    uint offerId,\n    TestTaker, /* taker */\n    TestToken base,\n    TestToken quote\n  ) external {\n    try wrongOwner.retractOfferWithDeprovision(offerId) {\n      TestEvents.fail(\"Invalid authorization to cancel order\");\n    } catch Error(string memory reason) {\n      TestEvents.eq(reason, \"mgv/cancelOffer/unauthorized\", \"Unexpected throw\");\n      try maker.retractOfferWithDeprovision(offerId) {\n        maker.retractOfferWithDeprovision(0);\n        uint provisioned =\n          TestUtils.getProvision(\n            mgv,\n            address(base),\n            address(quote),\n            offers[offerId][TestUtils.Info.gasreq]\n          );\n        TestEvents.eq(\n          mgv.balanceOf(address(maker)),\n          balances.makersBalanceWei[offerId] + provisioned,\n          \"Incorrect returned provision to maker\"\n        );\n      } catch {\n        TestEvents.fail(\"Cancel order failed unexpectedly\");\n      }\n    }\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Integration/TestCollectFailingOffer.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\nimport \"../Toolbox/TestUtils.sol\";\n\nlibrary TestCollectFailingOffer {\n  function run(\n    TestUtils.Balances storage balances,\n    mapping(uint => mapping(TestUtils.Info => uint)) storage offers,\n    AbstractMangrove mgv,\n    uint failingOfferId,\n    MakerDeployer makers,\n    TestTaker taker,\n    TestToken base,\n    TestToken quote\n  ) external {\n    // executing failing offer\n    try taker.takeWithInfo(failingOfferId, 0.5 ether) returns (\n      bool success,\n      uint takerGot,\n      uint takerGave\n    ) {\n      // take should return false not throw\n      TestEvents.check(!success, \"Failer should fail\");\n      TestEvents.eq(takerGot, 0, \"Failed offer should declare 0 takerGot\");\n      TestEvents.eq(takerGave, 0, \"Failed offer should declare 0 takerGave\");\n      // failingOffer should have been removed from Mgv\n      {\n        TestEvents.check(\n          !mgv.isLive(\n            mgv.offers(address(base), address(quote), failingOfferId)\n          ),\n          \"Failing offer should have been removed from Mgv\"\n        );\n      }\n      uint provision =\n        TestUtils.getProvision(\n          mgv,\n          address(base),\n          address(quote),\n          offers[failingOfferId][TestUtils.Info.gasreq]\n        );\n      uint returned =\n        mgv.balanceOf(address(makers.getMaker(0))) -\n          balances.makersBalanceWei[0];\n      TestEvents.eq(\n        address(mgv).balance,\n        balances.mgvBalanceWei - (provision - returned),\n        \"Mangrove has not send the correct amount to taker\"\n      );\n    } catch (bytes memory errorMsg) {\n      string memory err = abi.decode(errorMsg, (string));\n      TestEvents.fail(err);\n    }\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Integration/TestInsert.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\nimport \"../Toolbox/TestUtils.sol\";\n\nlibrary TestInsert {\n  function run(\n    TestUtils.Balances storage balances,\n    AbstractMangrove mgv,\n    MakerDeployer makers,\n    TestTaker, /* taker */ // silence warning about unused argument\n    TestToken base,\n    TestToken quote\n  ) public returns (uint[] memory) {\n    // each maker publishes an offer\n    uint[] memory offerOf = new uint[](makers.length());\n    offerOf[1] = makers.getMaker(1).newOffer({ // offer 1\n      wants: 1 ether,\n      gives: 0.5 ether,\n      gasreq: 50_000,\n      pivotId: 0\n    });\n    offerOf[2] = makers.getMaker(2).newOffer({ // offer 2\n      wants: 1 ether,\n      gives: 0.8 ether,\n      gasreq: 80_000,\n      pivotId: 1\n    });\n    offerOf[3] = makers.getMaker(3).newOffer({ // offer 3\n      wants: 0.5 ether,\n      gives: 1 ether,\n      gasreq: 90_000,\n      pivotId: 72\n    });\n    (bytes32 cfg, ) = mgv.config(address(base), address(quote));\n    offerOf[0] = makers.getMaker(0).newOffer({ //failer offer 4\n      wants: 20 ether,\n      gives: 10 ether,\n      gasreq: MP.global_unpack_gasmax(cfg),\n      pivotId: 0\n    });\n    //TestUtils.printOfferBook(mgv);\n    //Checking makers have correctly provisoned their offers\n    for (uint i = 0; i < makers.length(); i++) {\n      uint gasreq_i = TestUtils.getOfferInfo(\n        mgv,\n        address(base),\n        address(quote),\n        TestUtils.Info.gasreq,\n        offerOf[i]\n      );\n      uint provision_i = TestUtils.getProvision(\n        mgv,\n        address(base),\n        address(quote),\n        gasreq_i\n      );\n      TestEvents.eq(\n        mgv.balanceOf(address(makers.getMaker(i))),\n        balances.makersBalanceWei[i] - provision_i,\n        TestUtils.append(\n          \"Incorrect wei balance for maker \",\n          TestUtils.uint2str(i)\n        )\n      );\n    }\n    //Checking offers are correctly positioned (3 > 2 > 1 > 0)\n    uint offerId = mgv.best(address(base), address(quote));\n    uint expected_maker = 3;\n    while (offerId != 0) {\n      (ML.Offer memory offer, ML.OfferDetail memory od) = mgv.offerInfo(\n        address(base),\n        address(quote),\n        offerId\n      );\n      TestEvents.eq(\n        od.maker,\n        address(makers.getMaker(expected_maker)),\n        TestUtils.append(\n          \"Incorrect maker address at offer \",\n          TestUtils.uint2str(offerId)\n        )\n      );\n\n      expected_maker -= 1;\n      offerId = offer.next;\n    }\n    return offerOf;\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Integration/TestSnipe.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\nimport \"../Toolbox/TestUtils.sol\";\n\nlibrary TestSnipe {\n  function run(\n    TestUtils.Balances storage balances,\n    mapping(uint => mapping(TestUtils.Info => uint)) storage offers,\n    AbstractMangrove mgv,\n    MakerDeployer makers,\n    TestTaker taker,\n    TestToken base,\n    TestToken quote\n  ) external {\n    uint orderAmount = 0.3 ether;\n    uint snipedId = 2;\n    TestMaker maker = makers.getMaker(snipedId); // maker whose offer will be sniped\n\n    //(uint init_mkr_wants, uint init_mkr_gives,,,,,)=mgv.getOfferInfo(2);\n    //---------------SNIPE------------------//\n    uint takerGave;\n    uint takerGot;\n    {\n      bool takeSuccess;\n      (takeSuccess, takerGot, takerGave) = taker.takeWithInfo(\n        snipedId,\n        orderAmount\n      );\n\n      TestEvents.check(takeSuccess, \"snipe should be a success\");\n    }\n    TestEvents.eq(\n      base.balanceOf(TestUtils.adminOf(mgv)), //actual\n      balances.mgvBalanceFees +\n        TestUtils.getFee(mgv, address(base), address(quote), orderAmount), //expected\n      \"incorrect Mangrove A balance\"\n    );\n    TestEvents.eq(\n      base.balanceOf(address(taker)), // actual\n      balances.takerBalanceA +\n        orderAmount -\n        TestUtils.getFee(mgv, address(base), address(quote), orderAmount), // expected\n      \"incorrect taker A balance\"\n    );\n    TestEvents.eq(\n      takerGot,\n      orderAmount -\n        TestUtils.getFee(mgv, address(base), address(quote), orderAmount),\n      \"Incorrect takerGot\"\n    );\n    {\n      uint shouldGive =\n        (orderAmount * offers[snipedId][TestUtils.Info.makerWants]) /\n          offers[snipedId][TestUtils.Info.makerGives];\n      TestEvents.eq(\n        quote.balanceOf(address(taker)),\n        balances.takerBalanceB - shouldGive,\n        \"incorrect taker B balance\"\n      );\n      TestEvents.eq(takerGave, shouldGive, \"Incorrect takerGave\");\n    }\n    TestEvents.eq(\n      base.balanceOf(address(maker)),\n      balances.makersBalanceA[snipedId] - orderAmount,\n      \"incorrect maker A balance\"\n    );\n    TestEvents.eq(\n      quote.balanceOf(address(maker)),\n      balances.makersBalanceB[snipedId] +\n        (orderAmount * offers[snipedId][TestUtils.Info.makerWants]) /\n        offers[snipedId][TestUtils.Info.makerGives],\n      \"incorrect maker B balance\"\n    );\n    // Testing residual offer\n    (ML.Offer memory ofr, ) =\n      mgv.offerInfo(address(base), address(quote), snipedId);\n    TestEvents.check(ofr.gives == 0, \"Offer should not have a residual\");\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Integration/TestFailingMarketOrder.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\nimport \"../Toolbox/TestUtils.sol\";\n\nlibrary TestFailingMarketOrder {\n  function moWithFailures(\n    AbstractMangrove mgv,\n    address base,\n    address quote,\n    TestTaker taker\n  ) external {\n    taker.marketOrderWithFail({wants: 10 ether, gives: 30 ether});\n    TestEvents.check(\n      TestUtils.isEmptyOB(mgv, base, quote),\n      \"Offer book should be empty\"\n    );\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Integration/TestMarketOrder.sol": {
      "content": "pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\nimport \"../Toolbox/TestUtils.sol\";\n\nlibrary TestMarketOrder {\n  function run(\n    TestUtils.Balances storage balances,\n    mapping(uint => mapping(TestUtils.Info => uint)) storage offers,\n    AbstractMangrove mgv,\n    MakerDeployer makers,\n    TestTaker taker,\n    TestToken base,\n    TestToken quote\n  ) external {\n    uint takerWants = 1.6 ether; // of B token\n    uint takerGives = 2 ether; // of A token\n\n    (uint takerGot, uint takerGave) = taker.marketOrder(takerWants, takerGives);\n\n    // Checking Makers balances\n    for (uint i = 2; i < 4; i++) {\n      // offers 2 and 3 were consumed entirely\n      TestEvents.eq(\n        base.balanceOf(address(makers.getMaker(i))),\n        balances.makersBalanceA[i] - offers[i][TestUtils.Info.makerGives],\n        TestUtils.append(\n          \"Incorrect A balance for maker \",\n          TestUtils.uint2str(i)\n        )\n      );\n      TestEvents.eq(\n        quote.balanceOf(address(makers.getMaker(i))),\n        balances.makersBalanceB[i] + offers[i][TestUtils.Info.makerWants],\n        TestUtils.append(\n          \"Incorrect B balance for maker \",\n          TestUtils.uint2str(i)\n        )\n      );\n    }\n    uint leftMkrWants;\n    {\n      uint leftTkrWants = takerWants -\n        (offers[2][TestUtils.Info.makerGives] +\n          offers[3][TestUtils.Info.makerGives]);\n\n      leftMkrWants =\n        (offers[1][TestUtils.Info.makerWants] * leftTkrWants) /\n        offers[1][TestUtils.Info.makerGives];\n\n      TestEvents.eq(\n        base.balanceOf(address(makers.getMaker(1))),\n        balances.makersBalanceA[1] - leftTkrWants,\n        \"Incorrect A balance for maker 1\"\n      );\n    }\n\n    TestEvents.eq(\n      quote.balanceOf(address(makers.getMaker(1))),\n      balances.makersBalanceB[1] + leftMkrWants,\n      \"Incorrect B balance for maker 1\"\n    );\n\n    // Checking taker balance\n    TestEvents.eq(\n      base.balanceOf(address(taker)), // actual\n      balances.takerBalanceA +\n        takerWants -\n        TestUtils.getFee(mgv, address(base), address(quote), takerWants), // expected\n      \"incorrect taker A balance\"\n    );\n\n    TestEvents.eq(\n      takerGot,\n      takerWants -\n        TestUtils.getFee(mgv, address(base), address(quote), takerWants),\n      \"Incorrect declared takerGot\"\n    );\n\n    uint shouldGive = (offers[3][TestUtils.Info.makerWants] +\n      offers[2][TestUtils.Info.makerWants] +\n      leftMkrWants);\n    TestEvents.eq(\n      quote.balanceOf(address(taker)), // actual\n      balances.takerBalanceB - shouldGive, // expected\n      \"incorrect taker B balance\"\n    );\n\n    TestEvents.eq(takerGave, shouldGive, \"Incorrect declared takerGave\");\n\n    // Checking DEX Fee Balance\n    TestEvents.eq(\n      base.balanceOf(TestUtils.adminOf(mgv)), //actual\n      balances.mgvBalanceFees +\n        TestUtils.getFee(mgv, address(base), address(quote), takerWants), //expected\n      \"incorrect Mangrove balances\"\n    );\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Integration/AMM.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\n\nimport \"hardhat/console.sol\";\nimport {MgvPack as MP} from \"../../MgvPack.sol\";\nimport \"../Toolbox/TestUtils.sol\";\n\nimport \"../Agents/TestToken.sol\";\nimport \"../Agents/TestDelegateTaker.sol\";\nimport \"../Agents/OfferManager.sol\";\nimport \"../Agents/UniSwapMaker.sol\";\n\ncontract AMM_Test is HasMgvEvents {\n  AbstractMangrove mgv;\n  AbstractMangrove invMgv;\n  TestToken tk0;\n  TestToken tk1;\n\n  receive() external payable {}\n\n  function a_deployToken_beforeAll() public {\n    //console.log(\"IN BEFORE ALL\");\n    tk0 = TokenSetup.setup(\"tk0\", \"$tk0\");\n    tk1 = TokenSetup.setup(\"tk1\", \"$tk1\");\n\n    TestUtils.not0x(address(tk0));\n    TestUtils.not0x(address(tk1));\n\n    Display.register(address(0), \"NULL_ADDRESS\");\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"AMM_Test\");\n    Display.register(address(tk0), \"tk0\");\n    Display.register(address(tk1), \"tk1\");\n  }\n\n  function b_deployMgv_beforeAll() public {\n    mgv = MgvSetup.setup(tk0, tk1);\n    Display.register(address(mgv), \"Mgv\");\n    TestUtils.not0x(address(mgv));\n    //mgv.setFee(address(tk0), address(tk1), 300);\n\n    invMgv = MgvSetup.setup(tk0, tk1, true);\n    Display.register(address(invMgv), \"InvMgv\");\n    TestUtils.not0x(address(invMgv));\n    //invMgv.setFee(address(tk0), address(tk1), 300);\n  }\n\n  function prepare_offer_manager()\n    internal\n    returns (\n      OfferManager,\n      TestDelegateTaker,\n      TestDelegateTaker\n    )\n  {\n    OfferManager mgr = new OfferManager(mgv, invMgv);\n    Display.register(address(mgr), \"OfrMgr\");\n\n    TestDelegateTaker tkr = new TestDelegateTaker(mgr, tk0, tk1);\n    TestDelegateTaker _tkr = new TestDelegateTaker(mgr, tk1, tk0);\n    Display.register(address(tkr), \"Taker (tk0,tk1)\");\n    Display.register(address(_tkr), \"Taker (tk1,tk0)\");\n    bool noRevert0;\n    (noRevert0, ) = address(_tkr).call{value: 1 ether}(\"\");\n    bool noRevert1;\n    (noRevert1, ) = address(tkr).call{value: 1 ether}(\"\");\n    require(noRevert1 && noRevert0);\n\n    TestMaker maker = MakerSetup.setup(mgv, address(tk0), address(tk1));\n    Display.register(address(maker), \"Maker\");\n    tk0.mint(address(maker), 10 ether);\n    (bool success, ) = address(maker).call{gas: gasleft(), value: 10 ether}(\"\");\n    require(success);\n    maker.provisionMgv(10 ether);\n    maker.approveMgv(tk0, 10 ether);\n    maker.newOffer({\n      wants: 1 ether,\n      gives: 0.5 ether,\n      gasreq: 50_000,\n      pivotId: 0\n    });\n    maker.newOffer({\n      wants: 1 ether,\n      gives: 0.8 ether,\n      gasreq: 80_000,\n      pivotId: 1\n    });\n    maker.newOffer({\n      wants: 0.5 ether,\n      gives: 1 ether,\n      gasreq: 90_000,\n      pivotId: 72\n    });\n    return (mgr, tkr, _tkr);\n  }\n\n  function check_logs(address mgr, bool inverted) internal {\n    TestEvents.expectFrom(address(mgv));\n    emit OfferSuccess(\n      address(tk0),\n      address(tk1),\n      3,\n      address(mgr),\n      1 ether,\n      0.5 ether\n    );\n    emit OfferSuccess(\n      address(tk0),\n      address(tk1),\n      2,\n      address(mgr),\n      0.8 ether,\n      1 ether\n    );\n    AbstractMangrove MGV = mgv;\n    if (inverted) {\n      TestEvents.expectFrom(address(invMgv));\n      MGV = invMgv;\n    }\n    (bytes32 global, ) = MGV.config(address(0), address(0));\n    emit OfferWrite(\n      address(tk1),\n      address(tk0),\n      mgr,\n      1.2 ether,\n      1.2 ether,\n      MP.global_unpack_gasprice(global),\n      100_000,\n      1,\n      0\n    );\n    emit OfferSuccess(\n      address(tk1),\n      address(tk0),\n      1,\n      address(mgr),\n      1.2 ether,\n      1.2 ether\n    );\n    TestEvents.expectFrom(address(mgv));\n\n    (bytes32 cfg, ) = mgv.config(address(0), address(0));\n    emit OfferWrite(\n      address(tk0),\n      address(tk1),\n      mgr,\n      0.6 ether,\n      0.6 ether,\n      MP.global_unpack_gasprice(cfg),\n      100_000,\n      4,\n      0\n    );\n  }\n\n  function offer_manager_test() public {\n    (\n      OfferManager mgr,\n      TestDelegateTaker tkr,\n      TestDelegateTaker _tkr\n    ) = prepare_offer_manager();\n    tk1.mint(address(tkr), 5 ether);\n    tk0.mint(address(_tkr), 5 ether);\n\n    TestUtils.logOfferBook(mgv, address(tk0), address(tk1), 5);\n    Display.logBalances(\n      [address(tk0), address(tk1)],\n      address(tkr),\n      address(_tkr)\n    );\n\n    tkr.delegateOrder(mgr, 3 ether, 3 ether, mgv, false); // (A,B) order\n\n    Display.logBalances(\n      [address(tk0), address(tk1)],\n      address(tkr),\n      address(_tkr)\n    );\n    TestUtils.logOfferBook(mgv, address(tk0), address(tk1), 5); // taker has more A\n    TestUtils.logOfferBook(mgv, address(tk1), address(tk0), 2);\n    //Display.logBalances(tk0, tk1, address(taker));\n\n    _tkr.delegateOrder(mgr, 1.8 ether, 1.8 ether, mgv, false); // (B,A) order\n    TestUtils.logOfferBook(mgv, address(tk0), address(tk1), 5);\n    TestUtils.logOfferBook(mgv, address(tk1), address(tk0), 2);\n    Display.logBalances(\n      [address(tk0), address(tk1)],\n      address(tkr),\n      address(_tkr)\n    );\n\n    check_logs(address(mgr), false);\n  }\n\n  function inverted_offer_manager_test() public {\n    (\n      OfferManager mgr,\n      TestDelegateTaker tkr,\n      TestDelegateTaker _tkr\n    ) = prepare_offer_manager();\n\n    tk1.mint(address(tkr), 5 ether);\n    //tk0.mint(address(_taker), 5 ether);\n    tk0.addAdmin(address(_tkr)); // to test flashloan on the taker side\n\n    TestUtils.logOfferBook(mgv, address(tk0), address(tk1), 5);\n    Display.logBalances(\n      [address(tk0), address(tk1)],\n      address(tkr),\n      address(_tkr)\n    );\n\n    tkr.delegateOrder(mgr, 3 ether, 3 ether, mgv, true); // (A,B) order, residual posted on invertedMgv(B,A)\n\n    Display.logBalances(\n      [address(tk0), address(tk1)],\n      address(tkr),\n      address(_tkr)\n    );\n    TestUtils.logOfferBook(mgv, address(tk0), address(tk1), 5); // taker has more A\n    TestUtils.logOfferBook(invMgv, address(tk1), address(tk0), 2);\n    Display.logBalances([address(tk0), address(tk1)], address(tkr));\n\n    _tkr.delegateOrder(mgr, 1.8 ether, 1.8 ether, invMgv, false); // (B,A) FlashTaker order\n    TestUtils.logOfferBook(mgv, address(tk0), address(tk1), 5);\n    TestUtils.logOfferBook(invMgv, address(tk1), address(tk0), 2);\n    Display.logBalances(\n      [address(tk0), address(tk1)],\n      address(tkr),\n      address(_tkr)\n    );\n    check_logs(address(mgr), true);\n  }\n\n  function uniswap_like_maker_test() public {\n    UniSwapMaker amm = new UniSwapMaker(mgv, 100, 3); // creates the amm\n\n    Display.register(address(amm), \"UnisWapMaker\");\n    Display.register(address(this), \"TestRunner\");\n\n    tk1.mint(address(amm), 1000 ether);\n    tk0.mint(address(amm), 500 ether);\n\n    mgv.fund{value: 5 ether}(address(amm));\n\n    tk1.mint(address(this), 5 ether);\n    tk1.approve(address(mgv), 2**160 - 1);\n\n    tk0.mint(address(this), 5 ether);\n    tk0.approve(address(mgv), 2**160 - 1);\n\n    amm.newMarket(address(tk0), address(tk1));\n\n    TestUtils.logOfferBook(mgv, address(tk0), address(tk1), 1);\n    TestUtils.logOfferBook(mgv, address(tk1), address(tk0), 1);\n\n    mgv.marketOrder(address(tk0), address(tk1), 3 ether, 2**160 - 1, true);\n\n    TestUtils.logOfferBook(mgv, address(tk0), address(tk1), 1);\n    TestUtils.logOfferBook(mgv, address(tk1), address(tk0), 1);\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Agents/UniSwapMaker.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\nimport \"./TestToken.sol\";\nimport \"../../AbstractMangrove.sol\";\nimport {IMaker} from \"../../MgvLib.sol\";\n\n// Mangrove must be provisioned in the name of UniSwapMaker\n// UniSwapMaker must have ERC20 credit in tk0 and tk1 and these credits should not be shared (since contract is memoryless)\ncontract UniSwapMaker is IMaker {\n  AbstractMangrove mgv;\n  address private admin;\n  uint gasreq = 80_000;\n  uint8 share; // [1,100] for 1/1 to 1/100\n  uint8 fee; // per 1000\n  uint24 ofr0;\n  uint24 ofr1;\n\n  constructor(\n    AbstractMangrove _mgv,\n    uint _share,\n    uint _fee\n  ) {\n    require(_share > 1, \"Invalid parameters\");\n    require(uint8(_fee) == _fee && uint8(_share) == _share);\n    admin = msg.sender;\n    mgv = _mgv; // Abstract Mangrove\n    share = uint8(_share);\n    fee = uint8(_fee);\n  }\n\n  receive() external payable {}\n\n  function setParams(uint _fee, uint _share) external {\n    require(_share > 1, \"Invalid parameters\");\n    require(uint8(_fee) == _fee && uint8(_share) == _share);\n    if (msg.sender == admin) {\n      fee = uint8(_fee);\n      share = uint8(_share);\n    }\n  }\n\n  event Execute(\n    address mgv,\n    address base,\n    address quote,\n    uint offerId,\n    uint takerWants,\n    uint takerGives\n  );\n\n  function makerExecute(ML.SingleOrder calldata order)\n    external\n    override\n    returns (bytes32 avoid_compilation_warning)\n  {\n    avoid_compilation_warning;\n    require(msg.sender == address(mgv), \"Illegal call\");\n    emit Execute(\n      msg.sender,\n      order.outbound_tkn, // takerWants\n      order.inbound_tkn, // takerGives\n      order.offerId,\n      order.wants,\n      order.gives\n    );\n    return \"\";\n  }\n\n  // newPrice(makerWants,makerGives)\n  function newPrice(uint pool0, uint pool1) internal view returns (uint, uint) {\n    uint newGives = pool1 / share; // share = 100 for 1%\n    uint x = (newGives * pool0) / (pool1 - newGives); // forces newGives < poolGives\n    uint newWants = (1000 * x) / (1000 - fee); // fee < 1000\n    return (newWants, newGives);\n  }\n\n  function newMarket(address tk0, address tk1) public {\n    TestToken(tk0).approve(address(mgv), 2**256 - 1);\n    TestToken(tk1).approve(address(mgv), 2**256 - 1);\n\n    uint pool0 = TestToken(tk0).balanceOf(address(this));\n    uint pool1 = TestToken(tk1).balanceOf(address(this));\n\n    (uint wants0, uint gives1) = newPrice(pool0, pool1);\n    (uint wants1, uint gives0) = newPrice(pool1, pool0);\n    ofr0 = uint24(mgv.newOffer(tk0, tk1, wants0, gives1, gasreq, 0, 0));\n    ofr1 = uint24(mgv.newOffer(tk1, tk0, wants1, gives0, gasreq, 0, 0)); // natural OB\n  }\n\n  function makerPosthook(ML.SingleOrder calldata order, ML.OrderResult calldata)\n    external\n    override\n  {\n    // taker has paid maker\n    require(msg.sender == address(mgv)); // may not be necessary\n    uint pool0 = TestToken(order.inbound_tkn).balanceOf(address(this)); // pool0 has increased\n    uint pool1 = TestToken(order.outbound_tkn).balanceOf(address(this)); // pool1 has decreased\n\n    (uint newWants, uint newGives) = newPrice(pool0, pool1);\n\n    mgv.updateOffer(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      newWants,\n      newGives,\n      gasreq,\n      0, // gasprice\n      0, // best pivot\n      order.offerId // the offer that was executed\n    );\n    // for all pairs in opposite Dex:\n    uint OFR = ofr0;\n    if (order.offerId == ofr0) {\n      OFR = ofr1;\n    }\n\n    (newWants, newGives) = newPrice(pool1, pool0);\n    mgv.updateOffer(\n      order.inbound_tkn,\n      order.outbound_tkn,\n      newWants,\n      newGives,\n      gasreq,\n      0,\n      OFR,\n      OFR\n    );\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/MgvCleaner_Test.sol": {
      "content": "pragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\nimport \"../periphery/MgvCleaner.sol\";\n\nimport \"../MgvLib.sol\";\nimport \"hardhat/console.sol\";\nimport \"@giry/hardhat-test-solidity/test.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\nimport \"./Agents/TestMaker.sol\";\n// import \"./Agents/TestMoriartyMaker.sol\";\nimport \"./Agents/TestTaker.sol\";\n\n// In these tests, the testing contract is the market maker.\ncontract MgvCleaner_Test is HasMgvEvents {\n  receive() external payable {}\n\n  AbstractMangrove mgv;\n  TestTaker tkr;\n  TestMaker mkr;\n  address outbound;\n  address inbound;\n  MgvCleaner cleaner;\n\n  function a_beforeAll() public {\n    TestToken Outbound = TokenSetup.setup(\"A\", \"$A\");\n    TestToken Inbound = TokenSetup.setup(\"B\", \"$B\");\n    outbound = address(Outbound);\n    inbound = address(Inbound);\n    mgv = MgvSetup.setup(Outbound, Inbound);\n    mkr = MakerSetup.setup(mgv, outbound, inbound);\n    cleaner = new MgvCleaner(mgv);\n\n    address(mkr).transfer(10 ether);\n\n    mkr.provisionMgv(5 ether);\n\n    Inbound.mint(address(this), 2 ether);\n    Outbound.mint(address(mkr), 1 ether);\n\n    Outbound.approve(address(mgv), 1 ether);\n    Inbound.approve(address(mgv), 1 ether);\n    mkr.approveMgv(Outbound, 1 ether);\n\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"MgvCleaner_Test\");\n    Display.register(outbound, \"$A\");\n    Display.register(inbound, \"$B\");\n    Display.register(address(mgv), \"mgv\");\n    Display.register(address(mkr), \"maker[$A,$B]\");\n    Display.register(address(cleaner), \"cleaner\");\n  }\n\n  /* # Test Config */\n\n  function single_failing_offer_test() public {\n    mgv.approve(outbound, inbound, address(cleaner), type(uint).max);\n\n    mkr.shouldFail(true);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n\n    uint oldBal = address(this).balance;\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, type(uint).max];\n    cleaner.collect(outbound, inbound, targets, true);\n\n    uint newBal = address(this).balance;\n\n    TestEvents.more(newBal, oldBal, \"balance should have increased\");\n  }\n\n  function mult_failing_offer_test() public {\n    mgv.approve(outbound, inbound, address(cleaner), type(uint).max);\n\n    mkr.shouldFail(true);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    uint ofr2 = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n\n    uint oldBal = address(this).balance;\n\n    uint[4][] memory targets = new uint[4][](2);\n    targets[0] = [ofr, 1 ether, 1 ether, type(uint).max];\n    targets[1] = [ofr2, 1 ether, 1 ether, type(uint).max];\n    cleaner.collect(outbound, inbound, targets, true);\n\n    uint newBal = address(this).balance;\n\n    TestEvents.more(newBal, oldBal, \"balance should have increased\");\n  }\n\n  function no_fail_no_cleaning_test() public {\n    mgv.approve(outbound, inbound, address(cleaner), type(uint).max);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n\n    uint oldBal = address(this).balance;\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, type(uint).max];\n    try cleaner.collect(outbound, inbound, targets, true) {\n      TestEvents.fail(\"collect should fail since offer succeeded\");\n    } catch Error(string memory reason) {\n      TestEvents.eq(\n        \"mgvCleaner/anOfferDidNotFail\",\n        reason,\n        \"fail should be due to offer execution succeeding\"\n      );\n    }\n\n    uint newBal = address(this).balance;\n\n    TestEvents.eq(newBal, oldBal, \"balance should be the same\");\n  }\n\n  // For now there is no need to approve\n  // function no_approve_no_cleaning_test() public {\n  //   uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000,0);\n\n  //   uint[4][] memory targets = new uint[4][](1);\n  //   targets[0] = [ofr, 1 ether, 1 ether, type(uint).max];\n\n  //   try cleaner.collect(outbound, inbound,targets,true) {\n  //     TestEvents.fail(\"collect should fail since cleaner was not approved\");\n  //   } catch Error(string memory reason) {\n  //     TestEvents.eq(\"mgv/lowAllowance\",reason,\"Fail should be due to no allowance\");\n  //   }\n  // }\n}\n"
    },
    "cache/solpp-generated-contracts/periphery/MgvCleaner.sol": {
      "content": "pragma solidity ^0.7.6;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvCleaner.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nimport \"../Mangrove.sol\";\n\n/* The purpose of the Cleaner contract is to execute failing offers and collect\n * their associated bounty. It takes an array of offers with same definition as\n * `Mangrove.snipes` and expects them all to fail or not execute. */\n\n/* How to use:\n   1) Ensure *your* address approved Mangrove for the token you will provide to the offer (`inbound_tkn`).\n   2) Run `collect` on the offers that you detected were failing.\n\n   You can adjust takerWants/takerGives and gasreq as needed.\n\n   Note: in the current version you do not need to set MgvCleaner's allowance in Mangrove.\n   TODO: add `collectWith` with an additional `taker` argument.\n*/\ncontract MgvCleaner {\n  AbstractMangrove immutable MGV;\n\n  constructor(AbstractMangrove _MGV) {\n    MGV = _MGV;\n  }\n\n  receive() external payable {}\n\n  function collect(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint[4][] calldata targets,\n    bool fillWants\n  ) external returns (uint bal) {\n    (uint successes, , ) = MGV.snipesFor(\n      outbound_tkn,\n      inbound_tkn,\n      targets,\n      fillWants,\n      msg.sender\n    );\n    require(successes == 0, \"mgvCleaner/anOfferDidNotFail\");\n    bal = address(this).balance;\n    msg.sender.call{value: bal}(\"\");\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/lib/TradeHandler.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tBSD-2-Clause\n\n// TradeHandler.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\nimport {MgvPack as MP} from \"../../MgvPack.sol\";\nimport \"../../Mangrove.sol\";\nimport \"../../MgvLib.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract TradeHandler {\n  // internal bytes32 to select appropriate posthook\n  bytes32 constant RENEGED = \"mgvOffer/reneged\";\n  bytes32 constant OUTOFLIQUIDITY = \"mgvOffer/outOfLiquidity\";\n\n  // to wrap potentially reverting calls to mangrove\n  event PosthookFail(\n    address indexed outbound_tkn,\n    address indexed inbound_tkn,\n    uint offerId,\n    string message\n  );\n\n  event NotEnoughLiquidity(address token, uint amountMissing);\n  event PostHookError(address outbound_tkn, address inbound_tkn, uint offerId);\n\n  /// @notice extracts old offer from the order that is received from the Mangrove\n  function unpackOfferFromOrder(MgvLib.SingleOrder calldata order)\n    internal\n    pure\n    returns (\n      uint offer_wants,\n      uint offer_gives,\n      uint gasreq,\n      uint gasprice\n    )\n  {\n    gasreq = MP.offerDetail_unpack_gasreq(order.offerDetail);\n    (, , offer_wants, offer_gives, gasprice) = MP.offer_unpack(order.offer);\n  }\n\n  function getMissingProvision(\n    Mangrove mgv,\n    address outbound_tkn,\n    address inbound_tkn,\n    uint gasreq,\n    uint gasprice,\n    uint offerId\n  ) internal view returns (uint) {\n    (bytes32 globalData, bytes32 localData) = mgv.config(\n      outbound_tkn,\n      inbound_tkn\n    );\n    bytes32 offerData = mgv.offers(outbound_tkn, inbound_tkn, offerId);\n    bytes32 offerDetailData = mgv.offerDetails(\n      outbound_tkn,\n      inbound_tkn,\n      offerId\n    );\n    uint _gp;\n    if (MP.global_unpack_gasprice(globalData) > gasprice) {\n      _gp = MP.global_unpack_gasprice(globalData);\n    } else {\n      _gp = gasprice;\n    }\n    uint bounty = (gasreq +\n      MP.local_unpack_overhead_gasbase(localData) +\n      MP.local_unpack_offer_gasbase(localData)) *\n      _gp *\n      10**9; // in WEI\n    uint currentProvisionLocked = (MP.offerDetail_unpack_gasreq(\n      offerDetailData\n    ) +\n      MP.offerDetail_unpack_overhead_gasbase(offerDetailData) +\n      MP.offerDetail_unpack_offer_gasbase(offerDetailData)) *\n      MP.offer_unpack_gasprice(offerData) *\n      10**9;\n    uint currentProvision = currentProvisionLocked +\n      mgv.balanceOf(address(this));\n    return (currentProvision >= bounty ? 0 : bounty - currentProvision);\n  }\n\n  //queries the mangrove to get current gasprice (considered to compute bounty)\n  function getCurrentGasPrice(Mangrove mgv) internal view returns (uint) {\n    (bytes32 global_pack, ) = mgv.config(address(0), address(0));\n    return MP.global_unpack_gasprice(global_pack);\n  }\n\n  //truncate some bytes into a byte32 word\n  function truncateBytes(bytes memory data) internal pure returns (bytes32 w) {\n    assembly {\n      w := mload(add(data, 32))\n    }\n  }\n\n  function bytesOfWord(bytes32 w) internal pure returns (bytes memory) {\n    bytes memory b = new bytes(32);\n    assembly {\n      mstore(add(b, 32), w)\n    }\n    return b;\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/OfferMakerStrats/MangroveOffer.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tBSD-2-Clause\n\n// MangroveOffer.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nimport \"../lib/AccessControlled.sol\";\nimport \"../lib/Exponential.sol\";\nimport \"../lib/TradeHandler.sol\";\nimport \"../lib/consolerr/consolerr.sol\";\n\n/// MangroveOffer is the basic building block to implement a reactive offer that interfaces with the Mangrove\ncontract MangroveOffer is AccessControlled, IMaker, TradeHandler, Exponential {\n  Mangrove immutable MGV; // Address of the deployed Mangrove contract\n\n  // default values\n  uint public OFR_GASREQ = 1_000_000;\n\n  receive() external payable {}\n\n  // Offer constructor (caller will be admin)\n  constructor(address _MGV) {\n    (bytes32 global_pack, ) = Mangrove(payable(_MGV)).config(\n      address(0),\n      address(0)\n    );\n    uint dead = MP.global_unpack_dead(global_pack);\n    require(dead == 0, \"Mangrove contract is permanently disabled\"); //sanity check\n    MGV = Mangrove(payable(_MGV));\n  }\n\n  /// transfers token stored in `this` contract to some recipient address\n  function transferToken(\n    address token,\n    address recipient,\n    uint amount\n  ) external onlyAdmin returns (bool success) {\n    success = IERC20(token).transfer(recipient, amount);\n  }\n\n  /// trader needs to approve Mangrove to let it perform outbound token transfer at the end of the `makerExecute` function\n  function approveMangrove(address outbound_tkn, uint amount)\n    external\n    onlyAdmin\n  {\n    require(\n      IERC20(outbound_tkn).approve(address(MGV), amount),\n      \"Failed to approve Mangrove\"\n    );\n  }\n\n  /// withdraws ETH from the bounty vault of the Mangrove.\n  /// NB: `Mangrove.fund` function need not be called by `this` so is not included here.\n  function withdraw(address receiver, uint amount)\n    external\n    onlyAdmin\n    returns (bool noRevert)\n  {\n    require(MGV.withdraw(amount));\n    require(receiver != address(0), \"Cannot transfer WEIs to 0x0 address\");\n    (noRevert, ) = receiver.call{value: amount}(\"\");\n  }\n\n  // Posting a new offer on the (`outbound_tkn,inbound_tkn`) Offer List of Mangrove.\n  // NB #1: Offer maker MUST:\n  // * Approve Mangrove for at least `gives` amount of `outbound_tkn`.\n  // * Make sure that offer maker has enough WEI provision on Mangrove to cover for the new offer bounty\n  // * Make sure that `gasreq` and `gives` yield a sufficient offer density\n  // NB #2: This function may revert when the above points are not met, it is thus made external only so that it can be encapsulated when called during `makerExecute`.\n  function newOffer(\n    address outbound_tkn, // address of the ERC20 contract managing outbound tokens\n    address inbound_tkn, // address of the ERC20 contract managing outbound tokens\n    uint wants, // amount of `inbound_tkn` required for full delivery\n    uint gives, // max amount of `outbound_tkn` promised by the offer\n    uint gasreq, // max gas required by the offer when called. If maxUint256 is used here, default `OFR_GASREQ` will be considered instead\n    uint gasprice, // gasprice that should be consider to compute the bounty (Mangrove's gasprice will be used if this value is lower)\n    uint pivotId // identifier of an offer in the (`outbound_tkn,inbound_tkn`) Offer List after which the new offer should be inserted (gas cost of insertion will increase if the `pivotId` is far from the actual position of the new offer)\n  ) external internalOrAdmin returns (uint offerId) {\n    if (gasreq == type(uint).max) {\n      gasreq = OFR_GASREQ;\n    }\n    uint missing = __autoRefill__(\n      outbound_tkn,\n      inbound_tkn,\n      gasreq,\n      gasprice,\n      0\n    );\n    if (missing > 0) {\n      consolerr.errorUint(\"mgvOffer/new/outOfFunds: \", missing);\n    }\n    return\n      MGV.newOffer(\n        outbound_tkn,\n        inbound_tkn,\n        wants,\n        gives,\n        gasreq,\n        gasprice,\n        pivotId\n      );\n  }\n\n  //  Updates an existing `offerId` on the Mangrove. `updateOffer` rely on the same offer requirements as `newOffer` and may throw if they are not met.\n  //  Additionally `updateOffer` will thow if `this` contract is not the owner of `offerId`.\n  //  The `__autoRefill__` hook may be overridden to provide a method to refill offer provision automatically.\n  function updateOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint wants,\n    uint gives,\n    uint gasreq,\n    uint gasprice,\n    uint pivotId,\n    uint offerId\n  ) external internalOrAdmin {\n    uint missing = __autoRefill__(\n      outbound_tkn,\n      inbound_tkn,\n      gasreq,\n      gasprice,\n      offerId\n    );\n    if (missing > 0) {\n      consolerr.errorUint(\"mgvOffer/update/outOfFunds: \", missing);\n    }\n    MGV.updateOffer(\n      outbound_tkn,\n      inbound_tkn,\n      wants,\n      gives,\n      gasreq,\n      gasprice,\n      pivotId,\n      offerId\n    );\n  }\n\n  // Retracts `offerId` from the (`outbound_tkn`,`inbound_tkn`) Offer list of Mangrove. Function call will throw if `this` contract is not the owner of `offerId`.\n  function retractOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint offerId,\n    bool deprovision // if set to `true`, `this` contract will receive the remaining provision (in WEI) associated to `offerId`.\n  ) external internalOrAdmin {\n    MGV.retractOffer(outbound_tkn, inbound_tkn, offerId, deprovision);\n  }\n\n  // Returns the amount of WEI necessary to (re)provision the (re)posting of offer `offerID` in the (`outbound_tkn, inbound_tkn`) Offer List.\n  // If `OfferId` is not in the Offer List (possibly not live), the returned amount is the amount needed to post a fresh offer.\n  function getMissingProvision(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint gasreq,\n    uint gasprice,\n    uint offerId\n  ) public view returns (uint) {\n    return\n      getMissingProvision(\n        MGV,\n        outbound_tkn,\n        inbound_tkn,\n        gasreq,\n        gasprice,\n        offerId\n      );\n  }\n\n  /////// Mandatory callback functions\n\n  // `makerExecute` is the callback function to execute all offers that were posted on Mangrove by `this` contract.\n  // it may not be overriden although it can be customized using `__lastLook__`, `__put__` and `__get__` hooks.\n  // NB #1: When overriding the above hooks, the Offer Maker SHOULD make sure they do not revert in order to be able to post logs in case of bad executions.\n  // NB #2: if `makerExecute` does revert, the offer will be considered to be refusing the trade.\n  function makerExecute(MgvLib.SingleOrder calldata order)\n    external\n    override\n    onlyCaller(address(MGV))\n    returns (bytes32 ret)\n  {\n    if (!__lastLook__(order)) {\n      // hook to check order details and decide whether `this` contract should renege on the offer.\n      return RENEGED;\n    }\n    __put__(IERC20(order.inbound_tkn), order.gives); // implements what should be done with the liquidity that is flashswapped by the offer taker to `this` contract\n    uint missingGet = __get__(IERC20(order.outbound_tkn), order.wants); // implements how `this` contract should make the outbound tokens available\n    if (missingGet > 0) {\n      return OUTOFLIQUIDITY;\n    }\n  }\n\n  // `makerPosthook` is the callback function that is called by Mangrove *after* the offer execution.\n  // It may not be overriden although it can be customized via the post-hooks `__posthookSuccess__`, `__posthookGetFailure__`, `__posthookReneged__` and `__posthookFallback__` (see below).\n  // Offer Maker SHOULD make sure the overriden posthooks do not revert in order to be able to post logs in case of bad executions.\n  function makerPosthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata result\n  ) external override onlyCaller(address(MGV)) {\n    if (result.mgvData == \"mgv/tradeSuccess\") {\n      // if trade was a success\n      __posthookSuccess__(order);\n      return;\n    }\n    // if trade was aborted because of a lack of liquidity\n    if (result.makerData == OUTOFLIQUIDITY) {\n      __posthookGetFailure__(order);\n      return;\n    }\n    // if trade was reneged on during lastLook\n    if (result.makerData == RENEGED) {\n      __posthookReneged__(order);\n      return;\n    }\n    // if trade failed unexpectedly (`makerExecute` reverted or Mangrove failed to transfer the outbound tokens to the Offer Taker)\n    __posthookFallback__(order, result);\n    return;\n  }\n\n  ////// Customizable hooks for Taker Order'execution\n\n  // Override this hook to let the offer refill its provision on Mangrove (provided `this` contract has enough ETH).\n  // Use this hook to increase outbound token approval for Mangrove when the Offer Maker wishes to keep it tight.\n  // return value `missingETH` should be 0 if `offerId` doesn't lack provision.\n  function __autoRefill__(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint gasreq, // gas required by the offer to be reposted\n    uint gasprice, // gas price for the computation of the bounty\n    uint offerId // ID of the offer to be updated.\n  ) internal virtual returns (uint missingETH) {\n    outbound_tkn; //shh\n    inbound_tkn;\n    gasreq;\n    gasprice;\n    offerId;\n  }\n\n  // Override this hook to describe where the inbound token, which are flashswapped by the Offer Taker, should go during Taker Order's execution.\n  // `amount` is the quantity of outbound tokens whose destination is to be resolved.\n  // All tokens that are not transfered to a different contract remain listed in the balance of `this` contract\n  function __put__(IERC20 inbound_tkn, uint amount) internal virtual {\n    /// @notice receive payment is just stored at this address\n    inbound_tkn; //shh\n    amount;\n  }\n\n  // Override this hook to implement fetching `amount` of outbound tokens, possibly from another source than `this` contract during Taker Order's execution.\n  // For composability, return value MUST be the remaining quantity (i.e <= `amount`) of tokens remaining to be fetched.\n  function __get__(IERC20 outbound_tkn, uint amount)\n    internal\n    virtual\n    returns (uint)\n  {\n    uint local = outbound_tkn.balanceOf(address(this));\n    return (local > amount ? 0 : amount - local);\n  }\n\n  // Override this hook to implement a last look check during Taker Order's execution.\n  // Return value should be `true` if Taker Order is acceptable.\n  function __lastLook__(MgvLib.SingleOrder calldata order)\n    internal\n    virtual\n    returns (bool proceed)\n  {\n    order; //shh\n    proceed = true;\n  }\n\n  ////// Customizable post-hooks.\n\n  // Override this post-hook to implement what `this` contract should do when called back after a successfully executed order.\n  function __posthookSuccess__(MgvLib.SingleOrder calldata order)\n    internal\n    virtual\n  {\n    order; // shh\n  }\n\n  // Override this post-hook to implement what `this` contract should do when called back after an order that failed to be executed because of a lack of liquidity (not enough outbound tokens).\n  function __posthookGetFailure__(MgvLib.SingleOrder calldata order)\n    internal\n    virtual\n  {\n    uint missing = order.wants -\n      IERC20(order.outbound_tkn).balanceOf(address(this));\n    emit NotEnoughLiquidity(order.outbound_tkn, missing);\n  }\n\n  // Override this post-hook to implement what `this` contract should do when called back after an order that did not pass its last look (see `__lastLook__` hook).\n  function __posthookReneged__(MgvLib.SingleOrder calldata order)\n    internal\n    virtual\n  {\n    order; //shh\n  }\n\n  // Override this post-hook to implement fallback behavior when Taker Order's execution failed unexpectedly. Information from Mangrove is accessible in `result.mgvData` for logging purpose.\n  function __posthookFallback__(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata result\n  ) internal virtual {\n    emit PosthookFail(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      order.offerId,\n      string(bytesOfWord(result.mgvData))\n    );\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/lib/AccessControlled.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tBSD-2-Clause\n\n// AccessedControlled.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\ncontract AccessControlled {\n  address admin;\n\n  constructor() {\n    admin = msg.sender;\n  }\n\n  modifier onlyCaller(address caller) {\n    require(\n      caller == address(0) || msg.sender == caller,\n      \"AccessControlled/Invalid\"\n    );\n    _;\n  }\n\n  modifier onlyAdmin() {\n    require(msg.sender == admin, \"AccessControlled/Invalid\");\n    _;\n  }\n\n  modifier internalOrAdmin() {\n    require(\n      msg.sender == admin || msg.sender == address(this),\n      \"AccessControlled/Invalid\"\n    );\n    _;\n  }\n\n  function setAdmin(address _admin) external onlyAdmin {\n    admin = _admin;\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/lib/Exponential.sol": {
      "content": "pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier:\tBSD-3-Clause\n\n// Copyright 2020 Compound Labs, Inc.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\nimport \"./CarefulMath.sol\";\nimport \"./ExponentialNoError.sol\";\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @dev Legacy contract for compatibility reasons with existing contracts that still use MathError\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract Exponential is CarefulMath, ExponentialNoError {\n    /**\n     * @dev Creates an exponential from numerator and denominator values.\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n     *            or if `denom` is zero.\n     */\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\n    }\n\n    /**\n     * @dev Adds two exponentials, returning a new exponential.\n     */\n    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Subtracts two exponentials, returning a new exponential.\n     */\n    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\n     */\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(product));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return addUInt(truncate(product), addend);\n    }\n\n    /**\n     * @dev Divide an Exp by a scalar, returning a new Exp.\n     */\n    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, returning a new Exp.\n     */\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n        /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n        return getExp(numerator, divisor.mantissa);\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n     */\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(fraction));\n    }\n\n    /**\n     * @dev Multiplies two exponentials, returning a new exponential.\n     */\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        // We add half the scale before dividing so that we get rounding instead of truncation.\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n        assert(err2 == MathError.NO_ERROR);\n\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\n    }\n\n    /**\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n     */\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\n    }\n\n    /**\n     * @dev Multiplies three exponentials, returning a new exponential.\n     */\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n        (MathError err, Exp memory ab) = mulExp(a, b);\n        if (err != MathError.NO_ERROR) {\n            return (err, ab);\n        }\n        return mulExp(ab, c);\n    }\n\n    /**\n     * @dev Divides two exponentials, returning a new exponential.\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n     */\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        return getExp(a.mantissa, b.mantissa);\n    }\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/lib/consolerr/consolerr.sol": {
      "content": "pragma solidity >=0.6.10 <0.8.0;\n\n\n\n/*\n * Error logging\n * Author: Zac Williamson, AZTEC\n * Licensed under the Apache 2.0 license\n */\n\nlibrary consolerr {\n  function errorBytes(string memory reasonString, bytes memory varA)\n    internal\n    pure\n  {\n    (bytes32 revertPtr, bytes32 errorPtr) = initErrorPtr();\n    appendString(reasonString, errorPtr);\n    appendBytes(varA, errorPtr);\n\n    assembly {\n      revert(revertPtr, add(mload(errorPtr), 0x44))\n    }\n  }\n\n  function error(string memory reasonString, bytes32 varA) internal pure {\n    (bytes32 revertPtr, bytes32 errorPtr) = initErrorPtr();\n    appendString(reasonString, errorPtr);\n    append0x(errorPtr);\n    appendBytes32(varA, errorPtr);\n\n    assembly {\n      revert(revertPtr, add(mload(errorPtr), 0x44))\n    }\n  }\n\n  function error(\n    string memory reasonString,\n    bytes32 varA,\n    bytes32 varB\n  ) internal pure {\n    (bytes32 revertPtr, bytes32 errorPtr) = initErrorPtr();\n    appendString(reasonString, errorPtr);\n    append0x(errorPtr);\n    appendBytes32(varA, errorPtr);\n    appendComma(errorPtr);\n    append0x(errorPtr);\n    appendBytes32(varB, errorPtr);\n\n    assembly {\n      revert(revertPtr, add(mload(errorPtr), 0x44))\n    }\n  }\n\n  function error(\n    string memory reasonString,\n    bytes32 varA,\n    bytes32 varB,\n    bytes32 varC\n  ) internal pure {\n    (bytes32 revertPtr, bytes32 errorPtr) = initErrorPtr();\n    appendString(reasonString, errorPtr);\n    append0x(errorPtr);\n    appendBytes32(varA, errorPtr);\n    appendComma(errorPtr);\n    append0x(errorPtr);\n    appendBytes32(varB, errorPtr);\n    appendComma(errorPtr);\n    append0x(errorPtr);\n    appendBytes32(varC, errorPtr);\n\n    assembly {\n      revert(revertPtr, add(mload(errorPtr), 0x44))\n    }\n  }\n\n  function errorBytes32(string memory reasonString, bytes32 varA)\n    internal\n    pure\n  {\n    error(reasonString, varA);\n  }\n\n  function errorBytes32(\n    string memory reasonString,\n    bytes32 varA,\n    bytes32 varB\n  ) internal pure {\n    error(reasonString, varA, varB);\n  }\n\n  function errorBytes32(\n    string memory reasonString,\n    bytes32 varA,\n    bytes32 varB,\n    bytes32 varC\n  ) internal pure {\n    error(reasonString, varA, varB, varC);\n  }\n\n  function errorAddress(string memory reasonString, address varA)\n    internal\n    pure\n  {\n    (bytes32 revertPtr, bytes32 errorPtr) = initErrorPtr();\n    appendString(reasonString, errorPtr);\n    appendAddress(varA, errorPtr);\n\n    assembly {\n      revert(revertPtr, add(mload(errorPtr), 0x44))\n    }\n  }\n\n  function errorAddress(\n    string memory reasonString,\n    address varA,\n    address varB\n  ) internal pure {\n    (bytes32 revertPtr, bytes32 errorPtr) = initErrorPtr();\n    appendString(reasonString, errorPtr);\n    appendAddress(varA, errorPtr);\n    appendComma(errorPtr);\n    appendAddress(varB, errorPtr);\n\n    assembly {\n      revert(revertPtr, add(mload(errorPtr), 0x44))\n    }\n  }\n\n  function errorAddress(\n    string memory reasonString,\n    address varA,\n    address varB,\n    address varC\n  ) internal pure {\n    (bytes32 revertPtr, bytes32 errorPtr) = initErrorPtr();\n    appendString(reasonString, errorPtr);\n    appendAddress(varA, errorPtr);\n    appendComma(errorPtr);\n    appendAddress(varB, errorPtr);\n    appendComma(errorPtr);\n    appendAddress(varC, errorPtr);\n\n    assembly {\n      revert(revertPtr, add(mload(errorPtr), 0x44))\n    }\n  }\n\n  function errorUint(string memory reasonString, uint varA) internal pure {\n    (bytes32 revertPtr, bytes32 errorPtr) = initErrorPtr();\n    appendString(reasonString, errorPtr);\n    appendUint(varA, errorPtr);\n\n    assembly {\n      revert(revertPtr, add(mload(errorPtr), 0x44))\n    }\n  }\n\n  function errorUint(\n    string memory reasonString,\n    uint varA,\n    uint varB\n  ) internal pure {\n    (bytes32 revertPtr, bytes32 errorPtr) = initErrorPtr();\n    appendString(reasonString, errorPtr);\n    appendUint(varA, errorPtr);\n    appendComma(errorPtr);\n    appendUint(varB, errorPtr);\n\n    assembly {\n      revert(revertPtr, add(mload(errorPtr), 0x44))\n    }\n  }\n\n  function errorUint(\n    string memory reasonString,\n    uint varA,\n    uint varB,\n    uint varC\n  ) internal pure {\n    (bytes32 revertPtr, bytes32 errorPtr) = initErrorPtr();\n    appendString(reasonString, errorPtr);\n    appendUint(varA, errorPtr);\n    appendComma(errorPtr);\n    appendUint(varB, errorPtr);\n    appendComma(errorPtr);\n    appendUint(varC, errorPtr);\n\n    assembly {\n      revert(revertPtr, add(mload(errorPtr), 0x44))\n    }\n  }\n\n  function toAscii(bytes32 input)\n    internal\n    pure\n    returns (bytes32 hi, bytes32 lo)\n  {\n    assembly {\n      for {\n        let j := 0\n      } lt(j, 32) {\n        j := add(j, 0x01)\n      } {\n        let slice := add(0x30, and(input, 0xf))\n        if gt(slice, 0x39) {\n          slice := add(slice, 39)\n        }\n        lo := add(lo, shl(mul(8, j), slice))\n        input := shr(4, input)\n      }\n      for {\n        let k := 0\n      } lt(k, 32) {\n        k := add(k, 0x01)\n      } {\n        let slice := add(0x30, and(input, 0xf))\n        if gt(slice, 0x39) {\n          slice := add(slice, 39)\n        }\n        hi := add(hi, shl(mul(8, k), slice))\n        input := shr(4, input)\n      }\n    }\n  }\n\n  function appendComma(bytes32 stringPtr) internal pure {\n    assembly {\n      let stringLen := mload(stringPtr)\n\n      mstore(add(stringPtr, add(stringLen, 0x20)), \", \")\n      mstore(stringPtr, add(stringLen, 2))\n    }\n  }\n\n  function append0x(bytes32 stringPtr) internal pure {\n    assembly {\n      let stringLen := mload(stringPtr)\n      mstore(add(stringPtr, add(stringLen, 0x20)), \"0x\")\n      mstore(stringPtr, add(stringLen, 2))\n    }\n  }\n\n  function appendString(string memory toAppend, bytes32 stringPtr)\n    internal\n    pure\n  {\n    assembly {\n      let appendLen := mload(toAppend)\n      let stringLen := mload(stringPtr)\n      let appendPtr := add(stringPtr, add(0x20, stringLen))\n      for {\n        let i := 0\n      } lt(i, appendLen) {\n        i := add(i, 0x20)\n      } {\n        mstore(add(appendPtr, i), mload(add(toAppend, add(i, 0x20))))\n      }\n\n      // update string length\n      mstore(stringPtr, add(stringLen, appendLen))\n    }\n  }\n\n  function appendBytes(bytes memory toAppend, bytes32 stringPtr) internal pure {\n    uint bytesLen;\n    bytes32 inPtr;\n    assembly {\n      bytesLen := mload(toAppend)\n      inPtr := add(toAppend, 0x20)\n    }\n\n    for (uint i = 0; i < bytesLen; i += 0x20) {\n      bytes32 slice;\n      assembly {\n        slice := mload(inPtr)\n        inPtr := add(inPtr, 0x20)\n      }\n      appendBytes32(slice, stringPtr);\n    }\n\n    uint offset = bytesLen % 0x20;\n    if (offset > 0) {\n      // update length\n      assembly {\n        let lengthReduction := sub(0x20, offset)\n        let len := mload(stringPtr)\n        mstore(stringPtr, sub(len, lengthReduction))\n      }\n    }\n  }\n\n  function appendBytes32(bytes32 input, bytes32 stringPtr) internal pure {\n    assembly {\n      let hi\n      let lo\n      for {\n        let j := 0\n      } lt(j, 32) {\n        j := add(j, 0x01)\n      } {\n        let slice := add(0x30, and(input, 0xf))\n        slice := add(slice, mul(39, gt(slice, 0x39)))\n        lo := add(lo, shl(mul(8, j), slice))\n        input := shr(4, input)\n      }\n      for {\n        let k := 0\n      } lt(k, 32) {\n        k := add(k, 0x01)\n      } {\n        let slice := add(0x30, and(input, 0xf))\n        if gt(slice, 0x39) {\n          slice := add(slice, 39)\n        }\n        hi := add(hi, shl(mul(8, k), slice))\n        input := shr(4, input)\n      }\n\n      let stringLen := mload(stringPtr)\n\n      // mstore(add(stringPtr, add(stringLen, 0x20)), '0x')\n      mstore(add(stringPtr, add(stringLen, 0x20)), hi)\n      mstore(add(stringPtr, add(stringLen, 0x40)), lo)\n      mstore(stringPtr, add(stringLen, 0x40))\n    }\n  }\n\n  function appendAddress(address input, bytes32 stringPtr) internal pure {\n    assembly {\n      let hi\n      let lo\n      for {\n        let j := 0\n      } lt(j, 8) {\n        j := add(j, 0x01)\n      } {\n        let slice := add(0x30, and(input, 0xf))\n        slice := add(slice, mul(39, gt(slice, 0x39)))\n        lo := add(lo, shl(mul(8, j), slice))\n        input := shr(4, input)\n      }\n\n      lo := shl(192, lo)\n      for {\n        let k := 0\n      } lt(k, 32) {\n        k := add(k, 0x01)\n      } {\n        let slice := add(0x30, and(input, 0xf))\n        if gt(slice, 0x39) {\n          slice := add(slice, 39)\n        }\n        hi := add(hi, shl(mul(8, k), slice))\n        input := shr(4, input)\n      }\n\n      let stringLen := mload(stringPtr)\n\n      mstore(add(stringPtr, add(stringLen, 0x20)), \"0x\")\n      mstore(add(stringPtr, add(stringLen, 0x22)), hi)\n      mstore(add(stringPtr, add(stringLen, 0x42)), lo)\n      mstore(stringPtr, add(stringLen, 42))\n    }\n  }\n\n  function appendUint(uint input, bytes32 stringPtr) internal pure {\n    assembly {\n      // Clear out some low bytes\n      let result := mload(0x40)\n      if lt(result, 0x200) {\n        result := 0x200\n      }\n      mstore(add(result, 0xa0), mload(0x40))\n      mstore(add(result, 0xc0), mload(0x60))\n      mstore(add(result, 0xe0), mload(0x80))\n      mstore(add(result, 0x100), mload(0xa0))\n      mstore(add(result, 0x120), mload(0xc0))\n      mstore(add(result, 0x140), mload(0xe0))\n      mstore(add(result, 0x160), mload(0x100))\n      mstore(add(result, 0x180), mload(0x120))\n      mstore(add(result, 0x1a0), mload(0x140))\n\n      // Store lookup table that maps an integer from 0 to 99 into a 2-byte ASCII equivalent\n      mstore(\n        0x00,\n        0x0000000000000000000000000000000000000000000000000000000000003030\n      )\n      mstore(\n        0x20,\n        0x3031303230333034303530363037303830393130313131323133313431353136\n      )\n      mstore(\n        0x40,\n        0x3137313831393230323132323233323432353236323732383239333033313332\n      )\n      mstore(\n        0x60,\n        0x3333333433353336333733383339343034313432343334343435343634373438\n      )\n      mstore(\n        0x80,\n        0x3439353035313532353335343535353635373538353936303631363236333634\n      )\n      mstore(\n        0xa0,\n        0x3635363636373638363937303731373237333734373537363737373837393830\n      )\n      mstore(\n        0xc0,\n        0x3831383238333834383538363837383838393930393139323933393439353936\n      )\n      mstore(\n        0xe0,\n        0x3937393839390000000000000000000000000000000000000000000000000000\n      )\n\n      // Convert integer into string slices\n      function slice(v) -> y {\n        y := add(\n          add(\n            add(\n              add(\n                and(mload(shl(1, mod(v, 100))), 0xffff),\n                shl(16, and(mload(shl(1, mod(div(v, 100), 100))), 0xffff))\n              ),\n              add(\n                shl(32, and(mload(shl(1, mod(div(v, 10000), 100))), 0xffff)),\n                shl(48, and(mload(shl(1, mod(div(v, 1000000), 100))), 0xffff))\n              )\n            ),\n            add(\n              add(\n                shl(\n                  64,\n                  and(mload(shl(1, mod(div(v, 100000000), 100))), 0xffff)\n                ),\n                shl(\n                  80,\n                  and(mload(shl(1, mod(div(v, 10000000000), 100))), 0xffff)\n                )\n              ),\n              add(\n                shl(\n                  96,\n                  and(mload(shl(1, mod(div(v, 1000000000000), 100))), 0xffff)\n                ),\n                shl(\n                  112,\n                  and(mload(shl(1, mod(div(v, 100000000000000), 100))), 0xffff)\n                )\n              )\n            )\n          ),\n          add(\n            add(\n              add(\n                shl(\n                  128,\n                  and(\n                    mload(shl(1, mod(div(v, 10000000000000000), 100))),\n                    0xffff\n                  )\n                ),\n                shl(\n                  144,\n                  and(\n                    mload(shl(1, mod(div(v, 1000000000000000000), 100))),\n                    0xffff\n                  )\n                )\n              ),\n              add(\n                shl(\n                  160,\n                  and(\n                    mload(shl(1, mod(div(v, 100000000000000000000), 100))),\n                    0xffff\n                  )\n                ),\n                shl(\n                  176,\n                  and(\n                    mload(shl(1, mod(div(v, 10000000000000000000000), 100))),\n                    0xffff\n                  )\n                )\n              )\n            ),\n            add(\n              add(\n                shl(\n                  192,\n                  and(\n                    mload(shl(1, mod(div(v, 1000000000000000000000000), 100))),\n                    0xffff\n                  )\n                ),\n                shl(\n                  208,\n                  and(\n                    mload(\n                      shl(1, mod(div(v, 100000000000000000000000000), 100))\n                    ),\n                    0xffff\n                  )\n                )\n              ),\n              add(\n                shl(\n                  224,\n                  and(\n                    mload(\n                      shl(1, mod(div(v, 10000000000000000000000000000), 100))\n                    ),\n                    0xffff\n                  )\n                ),\n                shl(\n                  240,\n                  and(\n                    mload(\n                      shl(1, mod(div(v, 1000000000000000000000000000000), 100))\n                    ),\n                    0xffff\n                  )\n                )\n              )\n            )\n          )\n        )\n      }\n\n      mstore(0x100, 0x00)\n      mstore(0x120, 0x00)\n      mstore(0x140, slice(input))\n      input := div(input, 100000000000000000000000000000000)\n      if input {\n        mstore(0x120, slice(input))\n        input := div(input, 100000000000000000000000000000000)\n        if input {\n          mstore(0x100, slice(input))\n        }\n      }\n\n      function getMsbBytePosition(inp) -> y {\n        inp := sub(\n          inp,\n          0x3030303030303030303030303030303030303030303030303030303030303030\n        )\n        let v := and(\n          add(\n            inp,\n            0x7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f\n          ),\n          0x8080808080808080808080808080808080808080808080808080808080808080\n        )\n        v := or(v, shr(1, v))\n        v := or(v, shr(2, v))\n        v := or(v, shr(4, v))\n        v := or(v, shr(8, v))\n        v := or(v, shr(16, v))\n        v := or(v, shr(32, v))\n        v := or(v, shr(64, v))\n        v := or(v, shr(128, v))\n        y := mul(\n          iszero(iszero(inp)),\n          and(\n            div(\n              0x201f1e1d1c1b1a191817161514131211100f0e0d0c0b0a090807060504030201,\n              add(shr(8, v), 1)\n            ),\n            0xff\n          )\n        )\n      }\n\n      let len := getMsbBytePosition(mload(0x140))\n      if mload(0x120) {\n        len := add(getMsbBytePosition(mload(0x120)), 32)\n        if mload(0x100) {\n          len := add(getMsbBytePosition(mload(0x100)), 64)\n        }\n      }\n\n      let currentStringLength := mload(stringPtr)\n\n      let writePtr := add(stringPtr, add(currentStringLength, 0x20))\n\n      let offset := sub(96, len)\n      // mstore(result, len)\n      mstore(writePtr, mload(add(0x100, offset)))\n      mstore(add(writePtr, 0x20), mload(add(0x120, offset)))\n      mstore(add(writePtr, 0x40), mload(add(0x140, offset)))\n\n      // // update length\n      mstore(stringPtr, add(currentStringLength, len))\n\n      mstore(0x40, mload(add(result, 0xa0)))\n      mstore(0x60, mload(add(result, 0xc0)))\n      mstore(0x80, mload(add(result, 0xe0)))\n      mstore(0xa0, mload(add(result, 0x100)))\n      mstore(0xc0, mload(add(result, 0x120)))\n      mstore(0xe0, mload(add(result, 0x140)))\n      mstore(0x100, mload(add(result, 0x160)))\n      mstore(0x120, mload(add(result, 0x180)))\n      mstore(0x140, mload(add(result, 0x1a0)))\n    }\n  }\n\n  function initErrorPtr() internal pure returns (bytes32, bytes32) {\n    bytes32 mPtr;\n    bytes32 errorPtr;\n    assembly {\n      mPtr := mload(0x40)\n      if lt(mPtr, 0x200) {\n        // our uint -> base 10 ascii method requires about 0x200 bytes of mem\n        mPtr := 0x200\n      }\n      mstore(0x40, add(mPtr, 0x1000)) // let's reserve a LOT of memory for our error string.\n      mstore(\n        mPtr,\n        0x08c379a000000000000000000000000000000000000000000000000000000000\n      )\n      mstore(add(mPtr, 0x04), 0x20)\n      mstore(add(mPtr, 0x24), 0)\n      errorPtr := add(mPtr, 0x24)\n    }\n\n    return (mPtr, errorPtr);\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/lib/CarefulMath.sol": {
      "content": "pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier:\tBSD-3-Clause\n\n// Copyright 2020 Compound Labs, Inc.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n/**\n  * @title Careful Math\n  * @author Compound\n  * @notice Derived from OpenZeppelin's SafeMath library\n  *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n  */\ncontract CarefulMath {\n\n    /**\n     * @dev Possible error codes that we can return\n     */\n    enum MathError {\n        NO_ERROR,\n        DIVISION_BY_ZERO,\n        INTEGER_OVERFLOW,\n        INTEGER_UNDERFLOW\n    }\n\n    /**\n    * @dev Multiplies two numbers, returns an error on overflow.\n    */\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (a == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        uint c = a * b;\n\n        if (c / a != b) {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        } else {\n            return (MathError.NO_ERROR, c);\n        }\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b == 0) {\n            return (MathError.DIVISION_BY_ZERO, 0);\n        }\n\n        return (MathError.NO_ERROR, a / b);\n    }\n\n    /**\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b <= a) {\n            return (MathError.NO_ERROR, a - b);\n        } else {\n            return (MathError.INTEGER_UNDERFLOW, 0);\n        }\n    }\n\n    /**\n    * @dev Adds two numbers, returns an error on overflow.\n    */\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        uint c = a + b;\n\n        if (c >= a) {\n            return (MathError.NO_ERROR, c);\n        } else {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        }\n    }\n\n    /**\n    * @dev add a and b and then subtract c\n    */\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n        (MathError err0, uint sum) = addUInt(a, b);\n\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return subUInt(sum, c);\n    }\n\n    /**\n    * @dev min and max functions\n    */\n    function min(uint a, uint b) internal pure returns (uint) {\n        return (a < b ? a : b);\n    }\n    function max(uint a, uint b) internal pure returns (uint) {\n        return (a > b ? a : b);\n    }\n\n    uint constant MAXUINT = uint(-1);\n    uint constant MAXUINT96 = uint96(-1);\n    uint constant MAXUINT24 = uint24(-1);\n}"
    },
    "cache/solpp-generated-contracts/Strategies/lib/ExponentialNoError.sol": {
      "content": "pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier:\tBSD-3-Clause\n\n// Copyright 2020 Compound Labs, Inc.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract ExponentialNoError {\n    uint constant expScale = 1e18;\n    uint constant doubleScale = 1e36;\n    uint constant halfExpScale = expScale/2;\n    uint constant mantissaOne = expScale;\n\n    struct Exp {\n        uint mantissa;\n    }\n\n    struct Double {\n        uint mantissa;\n    }\n\n    /**\n     * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n     */\n    function truncate(Exp memory exp) pure internal returns (uint) {\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n        return exp.mantissa / expScale;\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\n        Exp memory product = mul_(a, scalar);\n        return truncate(product);\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\n        Exp memory product = mul_(a, scalar);\n        return add_(truncate(product), addend);\n    }\n\n    /**\n     * @dev Checks if first Exp is less than second Exp.\n     */\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa < right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp <= right Exp.\n     */\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa <= right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp > right Exp.\n     */\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa > right.mantissa;\n    }\n\n    /**\n     * @dev returns true if Exp is exactly zero\n     */\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\n        return value.mantissa == 0;\n    }\n\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\n        require(n < 2**224, errorMessage);\n        return uint224(n);\n    }\n\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(uint a, uint b) pure internal returns (uint) {\n        return add_(a, b, \"addition overflow\");\n    }\n\n    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        uint c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(uint a, uint b) pure internal returns (uint) {\n        return sub_(a, b, \"subtraction underflow\");\n    }\n\n    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\n    }\n\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\n        return Exp({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\n        return mul_(a, b.mantissa) / expScale;\n    }\n\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\n    }\n\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\n        return mul_(a, b.mantissa) / doubleScale;\n    }\n\n    function mul_(uint a, uint b) pure internal returns (uint) {\n        return mul_(a, b, \"multiplication overflow\");\n    }\n\n    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        uint c = a * b;\n        require(c / a == b, errorMessage);\n        return c;\n    }\n\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\n    }\n\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\n        return Exp({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\n        return div_(mul_(a, expScale), b.mantissa);\n    }\n\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\n    }\n\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint a, Double memory b) pure internal returns (uint) {\n        return div_(mul_(a, doubleScale), b.mantissa);\n    }\n\n    function div_(uint a, uint b) pure internal returns (uint) {\n        return div_(a, b, \"divide by zero\");\n    }\n\n    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\n    }\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/OfferMakerStrats/Persistent.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tBSD-2-Clause\n\n// Persistent.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nimport \"./MangroveOffer.sol\";\n\n/// MangroveOffer is the basic building block to implement a reactive offer that interfaces with the Mangrove\nabstract contract Persistent is MangroveOffer {\n  function __posthookSuccess__(MgvLib.SingleOrder calldata order)\n    internal\n    virtual\n    override\n  {\n    uint new_gives = MP.offer_unpack_gives(order.offer) - order.wants;\n    uint new_wants = MP.offer_unpack_wants(order.offer) - order.gives;\n    try\n      this.updateOffer(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        new_wants,\n        new_gives,\n        MP.offerDetail_unpack_gasreq(order.offerDetail),\n        MP.offer_unpack_gasprice(order.offer),\n        MP.offer_unpack_next(order.offer),\n        order.offerId\n      )\n    {} catch Error(string memory message) {\n      emit PosthookFail(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        message\n      );\n    } catch {\n      emit PosthookFail(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        \"Unexpected reason\"\n      );\n    }\n  }\n\n  function __autoRefill__(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint gasreq,\n    uint gasprice,\n    uint offerId\n  ) internal virtual override returns (uint) {\n    uint toAdd = getMissingProvision(\n      outbound_tkn,\n      inbound_tkn,\n      gasreq,\n      gasprice,\n      offerId\n    );\n    if (toAdd > 0) {\n      try MGV.fund{value: toAdd}() {\n        return 0;\n      } catch {\n        return toAdd;\n      }\n    }\n    return 0;\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/OfferMakerStrats/Deployable/Basic.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tBSD-2-Clause\n\n// Basic.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\nimport \"../Persistent.sol\";\n\n//import \"hardhat/console.sol\";\n\ncontract Basic is Persistent {\n  constructor(address payable _MGV) MangroveOffer(_MGV) {}\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/OfferMakerStrats/Defensive.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tBSD-2-Clause\n\n// Defensive.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nimport \"./MangroveOffer.sol\";\nimport \"../interfaces/IOracle.sol\";\n\n// import \"hardhat/console.sol\";\n\nabstract contract Defensive is MangroveOffer {\n  uint16 slippage_num;\n  uint16 constant slippage_den = 10**4;\n  IOracle public oracle;\n\n  // emitted when no price data is available for given token\n  event MissingPrice(address token);\n\n  constructor(address _oracle) {\n    require(!(_oracle == address(0)), \"Invalid oracle address\");\n    oracle = IOracle(_oracle);\n  }\n\n  function setSlippage(uint _slippage) external onlyAdmin {\n    require(uint16(_slippage) == _slippage, \"Slippage overflow\");\n    require(uint16(_slippage) <= slippage_den, \"Slippage should be <= 1\");\n    slippage_num = uint16(_slippage);\n  }\n\n  function __lastLook__(MgvLib.SingleOrder calldata order)\n    internal\n    virtual\n    override\n    returns (bool)\n  {\n    uint offer_gives_REF = mul_(\n      order.wants,\n      oracle.getPrice(order.outbound_tkn) // returns price in oracle base units (i.e ETH or USD)\n    );\n    uint offer_wants_REF = mul_(\n      order.gives,\n      oracle.getPrice(order.inbound_tkn) // returns price is oracle base units (i.e ETH or USD)\n    );\n    // abort trade if price data is not available\n    if (offer_gives_REF == 0) {\n      emit MissingPrice(order.outbound_tkn);\n      return false;\n    }\n    if (offer_wants_REF == 0) {\n      emit MissingPrice(order.inbound_tkn);\n      return false;\n    }\n    // if offer_gives_REF * (1-slippage) > offer_wants_REF one is getting arb'ed\n    // i.e slippage_den * OGR - slippage_num * OGR > OWR * slippage_den\n    return (sub_(\n      mul_(offer_gives_REF, slippage_den),\n      mul_(offer_gives_REF, slippage_num)\n    ) <= mul_(offer_wants_REF, slippage_den));\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/interfaces/IOracle.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier: Unlicense\n\n// IOracle.sol\n\n// This is free and unencumbered software released into the public domain.\n\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.\n\n// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For more information, please refer to <https://unlicense.org/>\n\n\n\ninterface IOracle {\n  function decimals() external view returns (uint8);\n\n  function getPrice(address token) external view returns (uint96);\n\n  function setPrice(address token, uint price) external;\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/OfferMakerStrats/Deployable/Defensive/PriceFed.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tBSD-2-Clause\n\n// PriceFed.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\nimport \"../../Defensive.sol\";\nimport \"../../AaveLender.sol\";\n\n//import \"hardhat/console.sol\";\n\ncontract PriceFed is Defensive, AaveLender {\n  constructor(\n    address _oracle,\n    address _addressesProvider,\n    address payable _MGV\n  ) Defensive(_oracle) AaveLender(_addressesProvider, 0) MangroveOffer(_MGV) {}\n\n  event Slippage(uint indexed offerId, uint old_wants, uint new_wants);\n\n  // reposts only if offer was reneged due to a price slippage\n  function __posthookReneged__(MgvLib.SingleOrder calldata order)\n    internal\n    override\n  {\n    (uint old_wants, uint old_gives, , ) = unpackOfferFromOrder(order);\n    uint price_quote = oracle.getPrice(order.inbound_tkn);\n    uint price_base = oracle.getPrice(order.outbound_tkn);\n\n    uint new_offer_wants = div_(mul_(old_gives, price_base), price_quote);\n    emit Slippage(order.offerId, old_wants, new_offer_wants);\n    // since offer is persistent it will auto refill if contract does not have enough provision on the Mangrove\n    try\n      this.updateOffer(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        new_offer_wants,\n        old_gives,\n        OFR_GASREQ,\n        0,\n        0,\n        order.offerId\n      )\n    {} catch Error(string memory message) {\n      emit PosthookFail(\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId,\n        message\n      );\n    }\n  }\n\n  // Closing diamond inheritance for solidity compiler\n  // get/put and lender strat's functions\n  function __get__(IERC20 base, uint amount)\n    internal\n    override(MangroveOffer, AaveLender)\n    returns (uint)\n  {\n    AaveLender.__get__(base, amount);\n  }\n\n  function __put__(IERC20 quote, uint amount)\n    internal\n    override(MangroveOffer, AaveLender)\n  {\n    AaveLender.__put__(quote, amount);\n  }\n\n  // lastlook is defensive strat's function\n  function __lastLook__(MgvLib.SingleOrder calldata order)\n    internal\n    virtual\n    override(MangroveOffer, Defensive)\n    returns (bool)\n  {\n    return Defensive.__lastLook__(order);\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/OfferMakerStrats/AaveLender.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tBSD-2-Clause\n\n//AaveLender.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\nimport \"./MangroveOffer.sol\";\nimport \"../interfaces/Aave/ILendingPool.sol\";\nimport \"../interfaces/Aave/ILendingPoolAddressesProvider.sol\";\nimport \"../interfaces/Aave/IPriceOracleGetter.sol\";\n\nimport \"hardhat/console.sol\";\n\nabstract contract AaveLender is MangroveOffer {\n  event ErrorOnRedeem(address ctoken, uint amount);\n  event ErrorOnMint(address ctoken, uint amount);\n\n  // address of the lendingPool\n  ILendingPool public immutable lendingPool;\n  IPriceOracleGetter public immutable priceOracle;\n  uint16 referralCode;\n\n  constructor(address _addressesProvider, uint _referralCode) {\n    require(\n      uint16(_referralCode) == _referralCode,\n      \"Referral code should be uint16\"\n    );\n    referralCode = uint16(referralCode); // for aave reference, put 0 for tests\n    address _lendingPool = ILendingPoolAddressesProvider(_addressesProvider)\n      .getLendingPool();\n    address _priceOracle = ILendingPoolAddressesProvider(_addressesProvider)\n      .getPriceOracle();\n    require(_lendingPool != address(0), \"Invalid lendingPool address\");\n    require(_priceOracle != address(0), \"Invalid priceOracle address\");\n    lendingPool = ILendingPool(_lendingPool);\n    priceOracle = IPriceOracleGetter(_priceOracle);\n  }\n\n  /**************************************************************************/\n  ///@notice Required functions to let `this` contract interact with Aave\n  /**************************************************************************/\n\n  ///@notice approval of ctoken contract by the underlying is necessary for minting and repaying borrow\n  ///@notice user must use this function to do so.\n  function approveLender(IERC20 token, uint amount) external onlyAdmin {\n    token.approve(address(lendingPool), amount);\n  }\n\n  function mint(IERC20 underlying, uint amount) external onlyAdmin {\n    aaveMint(underlying, amount);\n  }\n\n  function redeem(IERC20 underlying, uint amount) external onlyAdmin {\n    aaveRedeem(underlying, amount);\n  }\n\n  ///@notice exits markets\n  function exitMarket(IERC20 underlying) external onlyAdmin {\n    lendingPool.setUserUseReserveAsCollateral(address(underlying), false);\n  }\n\n  function enterMarkets(IERC20[] calldata underlyings) external onlyAdmin {\n    for (uint i = 0; i < underlyings.length; i++) {\n      lendingPool.setUserUseReserveAsCollateral(address(underlyings[i]), true);\n    }\n  }\n\n  // structs to avoir stack too deep in maxGettableUnderlying\n  struct Underlying {\n    uint ltv;\n    uint liquidationThreshold;\n    uint decimals;\n    uint price;\n  }\n\n  struct Account {\n    uint collateral;\n    uint debt;\n    uint borrowPower;\n    uint redeemPower;\n    uint ltv;\n    uint liquidationThreshold;\n    uint health;\n    uint balanceOfUnderlying;\n  }\n\n  /// @notice Computes maximal maximal redeem capacity (R) and max borrow capacity (B|R) after R has been redeemed\n  /// returns (R, B|R)\n\n  function maxGettableUnderlying(IERC20 asset)\n    public\n    view\n    returns (uint, uint)\n  {\n    Underlying memory underlying; // asset parameters\n    Account memory account; // accound parameters\n    (\n      account.collateral,\n      account.debt,\n      account.borrowPower, // avgLtv * sumCollateralEth - sumDebtEth\n      account.liquidationThreshold,\n      account.ltv,\n      account.health // avgLiquidityThreshold * sumCollateralEth / sumDebtEth  -- should be less than 10**18\n    ) = lendingPool.getUserAccountData(address(this));\n    DataTypes.ReserveData memory reserveData = lendingPool.getReserveData(\n      address(asset)\n    );\n    (\n      underlying.ltv, // collateral factor for lending\n      underlying.liquidationThreshold, // collateral factor for borrowing\n      ,\n      /*liquidationBonus*/\n      underlying.decimals,\n      /*reserveFactor*/\n\n    ) = DataTypes.getParams(reserveData.configuration);\n    account.balanceOfUnderlying = IERC20(reserveData.aTokenAddress).balanceOf(\n      address(this)\n    );\n\n    underlying.price = priceOracle.getAssetPrice(address(asset)); // divided by 10**underlying.decimals\n\n    // account.redeemPower = account.liquidationThreshold * account.collateral - account.debt\n    account.redeemPower = sub_(\n      div_(mul_(account.liquidationThreshold, account.collateral), 10**4),\n      account.debt\n    );\n    // max redeem capacity = account.redeemPower/ underlying.liquidationThreshold * underlying.price\n    // unless account doesn't have enough collateral in asset token (hence the min())\n\n    uint maxRedeemableUnderlying = div_( // in 10**underlying.decimals\n      account.redeemPower * 10**(underlying.decimals) * 10**4,\n      mul_(underlying.liquidationThreshold, underlying.price)\n    );\n\n    maxRedeemableUnderlying = min(\n      maxRedeemableUnderlying,\n      account.balanceOfUnderlying\n    );\n    // computing max borrow capacity on the premisses that maxRedeemableUnderlying has been redeemed.\n    // max borrow capacity = (account.borrowPower - (ltv*redeemed)) / underlying.ltv * underlying.price\n\n    uint borrowPowerImpactOfRedeemInUnderlying = div_(\n      mul_(maxRedeemableUnderlying, underlying.ltv),\n      10**4\n    );\n    uint borrowPowerInUnderlying = div_(\n      mul_(account.borrowPower, 10**underlying.decimals),\n      underlying.price\n    );\n\n    if (borrowPowerImpactOfRedeemInUnderlying > borrowPowerInUnderlying) {\n      // no more borrowPower left after max redeem operation\n      return (maxRedeemableUnderlying, 0);\n    }\n\n    uint maxBorrowAfterRedeemInUnderlying = sub_( // max borrow power in underlying after max redeem has been withdrawn\n      borrowPowerInUnderlying,\n      borrowPowerImpactOfRedeemInUnderlying\n    );\n    return (maxRedeemableUnderlying, maxBorrowAfterRedeemInUnderlying);\n  }\n\n  ///@notice method to get `outbound_tkn` during makerExecute\n  ///@param outbound_tkn address of the ERC20 managing `outbound_tkn` token\n  ///@param amount of token that the trade is still requiring\n  function __get__(IERC20 outbound_tkn, uint amount)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    (\n      uint redeemable, /*maxBorrowAfterRedeem*/\n\n    ) = maxGettableUnderlying(outbound_tkn);\n\n    uint redeemAmount = min(redeemable, amount);\n\n    if (aaveRedeem(outbound_tkn, redeemAmount) == 0) {\n      // redeemAmount was transfered to `this`\n      return (amount - redeemAmount);\n    }\n    return amount;\n  }\n\n  function aaveRedeem(IERC20 asset, uint amountToRedeem)\n    internal\n    returns (uint)\n  {\n    try\n      lendingPool.withdraw(address(asset), amountToRedeem, address(this))\n    returns (uint withdrawn) {\n      //aave redeem was a success\n      if (amountToRedeem == withdrawn) {\n        return 0;\n      } else {\n        emit ErrorOnRedeem(address(asset), amountToRedeem);\n        return (amountToRedeem - withdrawn);\n      }\n    } catch {\n      //compound redeem failed\n      emit ErrorOnRedeem(address(asset), amountToRedeem);\n      return amountToRedeem;\n    }\n  }\n\n  function __put__(IERC20 inbound_tkn, uint amount) internal virtual override {\n    //optim\n    if (amount == 0) {\n      return;\n    }\n    aaveMint(inbound_tkn, amount);\n  }\n\n  // adapted from https://medium.com/compound-finance/supplying-assets-to-the-compound-protocol-ec2cf5df5aa#afff\n  // utility to supply erc20 to compound\n  // NB `ctoken` contract MUST be approved to perform `transferFrom token` by `this` contract.\n  /// @notice user need to approve ctoken in order to mint\n  function aaveMint(IERC20 inbound_tkn, uint amount) internal {\n    // contract must haveallowance()to spend funds on behalf ofmsg.sender for at-leastamount for the asset being deposited. This can be done via the standard ERC20 approve() method.\n    try\n      lendingPool.deposit(\n        address(inbound_tkn),\n        amount,\n        address(this),\n        referralCode\n      )\n    {\n      return;\n    } catch {\n      emit ErrorOnMint(address(inbound_tkn), amount);\n    }\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/interfaces/Aave/ILendingPool.sol": {
      "content": "pragma solidity >=0.6.12;\npragma abicoder v2;\n\n// SPDX-License-Identifier: agpl-3.0\n// Copyright (C) 2020 Aave\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// [GNU Affero General Public License](https://www.gnu.org/licenses/agpl-3.0.en.html)\n\n\n\nimport {ILendingPoolAddressesProvider} from './ILendingPoolAddressesProvider.sol';\nimport {DataTypes} from './DataTypes.sol';\n\ninterface ILendingPool {\n  /**\n   * @dev Emitted on deposit()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the deposit\n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n   * @param amount The amount deposited\n   * @param referral The referral code used\n   **/\n  event Deposit(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlyng asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to Address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   **/\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed\n   * @param referral The referral code used\n   **/\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint256 borrowRateMode,\n    uint256 borrowRate,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   **/\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  event Swap(address indexed reserve, address indexed user, uint256 rateMode);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   **/\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   **/\n  event FlashLoan(\n    address indexed target,\n    address indexed initiator,\n    address indexed asset,\n    uint256 amount,\n    uint256 premium,\n    uint16 referralCode\n  );\n\n  /**\n   * @dev Emitted when the pause is triggered.\n   */\n  event Paused();\n\n  /**\n   * @dev Emitted when the pause is lifted.\n   */\n  event Unpaused();\n\n  /**\n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n   * LendingPoolCollateral manager using a DELEGATECALL\n   * This allows to have the events in the generated ABI for LendingPool.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n   * gets added to the LendingPool ABI\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The new liquidity rate\n   * @param stableBorrowRate The new stable borrow rate\n   * @param variableBorrowRate The new variable borrow rate\n   * @param liquidityIndex The new liquidity index\n   * @param variableBorrowIndex The new variable borrow index\n   **/\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   **/\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 rateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n   * @param asset The address of the underlying asset borrowed\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  function swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n  /**\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n   *        borrowed at a stable rate and depositors are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   **/\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n   * @param asset The address of the underlying asset deposited\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n   **/\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n   * For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts amounts being flash-borrowed\n   * @param modes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata modes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralETH the total collateral in ETH of the user\n   * @return totalDebtETH the total debt in ETH of the user\n   * @return availableBorrowsETH the borrowing power left of the user\n   * @return currentLiquidationThreshold the liquidation threshold of the user\n   * @return ltv the loan to value of the user\n   * @return healthFactor the current health factor of the user\n   **/\n  function getUserAccountData(address user)\n    external\n    view\n    returns (\n      uint256 totalCollateralETH,\n      uint256 totalDebtETH,\n      uint256 availableBorrowsETH,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  function initReserve(\n    address reserve,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress)\n    external;\n\n  function setConfiguration(address reserve, uint256 configuration) external;\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getConfiguration(address asset)\n    external\n    view\n    returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @dev Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   **/\n  function getUserConfiguration(address user)\n    external\n    view\n    returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @dev Returns the normalized income normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromAfter,\n    uint256 balanceToBefore\n  ) external;\n\n  function getReservesList() external view returns (address[] memory);\n\n  function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\n\n  function setPause(bool val) external;\n\n  function paused() external view returns (bool);\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/interfaces/Aave/ILendingPoolAddressesProvider.sol": {
      "content": "pragma solidity >=0.6.12;\n\n// SPDX-License-Identifier: agpl-3.0\n// Copyright (C) 2020 Aave\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// [GNU Affero General Public License](https://www.gnu.org/licenses/agpl-3.0.en.html)\n\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n  event MarketIdSet(string newMarketId);\n  event LendingPoolUpdated(address indexed newAddress);\n  event ConfigurationAdminUpdated(address indexed newAddress);\n  event EmergencyAdminUpdated(address indexed newAddress);\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n  event PriceOracleUpdated(address indexed newAddress);\n  event LendingRateOracleUpdated(address indexed newAddress);\n  event ProxyCreated(bytes32 id, address indexed newAddress);\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n  function getMarketId() external view returns (string memory);\n\n  function setMarketId(string calldata marketId) external;\n\n  function setAddress(bytes32 id, address newAddress) external;\n\n  function setAddressAsProxy(bytes32 id, address impl) external;\n\n  function getAddress(bytes32 id) external view returns (address);\n\n  function getLendingPool() external view returns (address);\n\n  function setLendingPoolImpl(address pool) external;\n\n  function getLendingPoolConfigurator() external view returns (address);\n\n  function setLendingPoolConfiguratorImpl(address configurator) external;\n\n  function getLendingPoolCollateralManager() external view returns (address);\n\n  function setLendingPoolCollateralManager(address manager) external;\n\n  function getPoolAdmin() external view returns (address);\n\n  function setPoolAdmin(address admin) external;\n\n  function getEmergencyAdmin() external view returns (address);\n\n  function setEmergencyAdmin(address admin) external;\n\n  function getPriceOracle() external view returns (address);\n\n  function setPriceOracle(address priceOracle) external;\n\n  function getLendingRateOracle() external view returns (address);\n\n  function setLendingRateOracle(address lendingRateOracle) external;\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/interfaces/Aave/IPriceOracleGetter.sol": {
      "content": "pragma solidity >=0.6.12;\n\n// SPDX-License-Identifier: agpl-3.0\n// Copyright (C) 2020 Aave\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// [GNU Affero General Public License](https://www.gnu.org/licenses/agpl-3.0.en.html)\n\n\n/**\n * @title IPriceOracleGetter interface\n * @notice Interface for the Aave price oracle.\n **/\n\ninterface IPriceOracleGetter {\n  /**\n   * @dev returns the asset price in ETH\n   * @param asset the address of the asset\n   * @return the ETH price of the asset\n   **/\n  function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/interfaces/Aave/DataTypes.sol": {
      "content": "pragma solidity >=0.6.12;\n\n// SPDX-License-Identifier: agpl-3.0\n// Copyright (C) 2020 Aave\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// [GNU Affero General Public License](https://www.gnu.org/licenses/agpl-3.0.en.html)\n//for more details\n\n\nlibrary DataTypes {\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    //tokens addresses\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint8 id;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: Reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60-63: reserved\n    //bit 64-79: reserve factor\n    uint data;\n  }\n\n  struct UserConfigurationMap {\n    uint data;\n  }\n\n  enum InterestRateMode {\n    NONE,\n    STABLE,\n    VARIABLE\n  }\n\n  uint256 constant LTV_MASK =                   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\n  uint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\n  uint256 constant LIQUIDATION_BONUS_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\n  uint256 constant DECIMALS_MASK =              0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\n  uint256 constant ACTIVE_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 constant FROZEN_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 constant BORROWING_MASK =             0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 constant STABLE_BORROWING_MASK =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\n  uint256 constant RESERVE_FACTOR_MASK =        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\n\n  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\n  uint constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\n  uint constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\n  uint constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\n  uint constant IS_ACTIVE_START_BIT_POSITION = 56;\n  uint constant IS_FROZEN_START_BIT_POSITION = 57;\n  uint constant BORROWING_ENABLED_START_BIT_POSITION = 58;\n  uint constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\n  uint constant RESERVE_FACTOR_START_BIT_POSITION = 64;\n\n  function getParams(ReserveConfigurationMap memory configMap)\n    internal\n    view\n    returns (\n      uint,\n      uint,\n      uint,\n      uint,\n      uint\n    )\n  {\n    uint dataLocal = configMap.data;\n    return (\n      dataLocal & ~LTV_MASK,\n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >>\n        LIQUIDATION_THRESHOLD_START_BIT_POSITION,\n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >>\n        LIQUIDATION_BONUS_START_BIT_POSITION,\n      (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\n      (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\n    );\n  }\n\n  function isUsingAsCollateral(\n    DataTypes.UserConfigurationMap memory configMap,\n    uint reserveIndex\n  ) internal pure returns (bool) {\n    require(reserveIndex < 128, \"Invalid index\");\n    return (configMap.data >> (reserveIndex * 2 + 1)) & 1 != 0;\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/OfferMakerStrats/Deployable/CashManagement/SimpleAaveRetail.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tBSD-2-Clause\n\n// AdvancedCompoundRetail.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nimport \"../../AaveLender.sol\";\n\ncontract SimpleAaveRetail is AaveLender {\n  constructor(address _addressesProvider, address payable _MGV)\n    AaveLender(_addressesProvider, 0)\n    MangroveOffer(_MGV)\n  {}\n\n  // Tries to take base directly from `this` balance. Fetches the remainder on Aave.\n  function __get__(IERC20 outbound_tkn, uint amount)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    uint missing = MangroveOffer.__get__(outbound_tkn, amount);\n    if (missing > 0) {\n      return super.__get__(outbound_tkn, missing);\n    }\n    return 0;\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/OfferMakerStrats/AaveTrader.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tBSD-2-Clause\n\n// AaveTrader.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\nimport \"./AaveLender.sol\";\nimport \"hardhat/console.sol\";\n\nabstract contract AaveTrader is AaveLender {\n  uint public immutable interestRateMode;\n\n  constructor(uint _interestRateMode) {\n    interestRateMode = _interestRateMode;\n  }\n\n  event ErrorOnBorrow(address cToken, uint amount, string errorCode);\n  event ErrorOnRepay(address cToken, uint amount);\n\n  ///@notice method to get `outbound_tkn` during makerExecute\n  ///@param outbound_tkn address of the ERC20 managing `outbound_tkn` token\n  ///@param amount of token that the trade is still requiring\n  function __get__(IERC20 outbound_tkn, uint amount)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    // 1. Computing total borrow and redeem capacities of underlying asset\n    (uint redeemable, uint liquidity_after_redeem) = maxGettableUnderlying(\n      outbound_tkn\n    );\n\n    // 2. trying to redeem liquidity from Compound\n    uint toRedeem = min(redeemable, amount);\n\n    uint notRedeemed = aaveRedeem(outbound_tkn, toRedeem);\n    if (notRedeemed > 0 && toRedeem > 0) {\n      // => notRedeemed == toRedeem\n      // this should not happen unless compound is out of cash, thus no need to try to borrow\n      // log already emitted by `compoundRedeem`\n      return amount;\n    }\n    amount = sub_(amount, toRedeem);\n    uint toBorrow = min(liquidity_after_redeem, amount);\n    if (toBorrow == 0) {\n      return amount;\n    }\n    // 3. trying to borrow missing liquidity\n    try\n      lendingPool.borrow(\n        address(outbound_tkn),\n        toBorrow,\n        interestRateMode,\n        referralCode,\n        address(this)\n      )\n    {\n      return sub_(amount, toBorrow);\n    } catch Error(string memory errorCode) {\n      emit ErrorOnBorrow(address(outbound_tkn), toBorrow, errorCode);\n      return amount; // unable to borrow requested amount\n    } catch {\n      emit ErrorOnBorrow(address(outbound_tkn), toBorrow, \"Unexpected reason\");\n      return amount;\n    }\n  }\n\n  /// @notice user need to have approved `inbound_tkn` overlying in order to repay borrow\n  function __put__(IERC20 inbound_tkn, uint amount) internal virtual override {\n    //optim\n    if (amount == 0) {\n      return;\n    }\n    // trying to repay debt if user is in borrow position for inbound_tkn token\n    DataTypes.ReserveData memory reserveData = lendingPool.getReserveData(\n      address(inbound_tkn)\n    );\n\n    uint debtOfUnderlying;\n    if (interestRateMode == 1) {\n      debtOfUnderlying = IERC20(reserveData.stableDebtTokenAddress).balanceOf(\n        address(this)\n      );\n    } else {\n      debtOfUnderlying = IERC20(reserveData.variableDebtTokenAddress).balanceOf(\n          address(this)\n        );\n    }\n\n    uint toRepay = min(debtOfUnderlying, amount);\n\n    uint toMint;\n    try\n      lendingPool.repay(\n        address(inbound_tkn),\n        toRepay,\n        interestRateMode,\n        address(this)\n      )\n    {\n      toMint = sub_(amount, toRepay);\n    } catch {\n      emit ErrorOnRepay(address(inbound_tkn), toRepay);\n      toMint = amount;\n    }\n    aaveMint(inbound_tkn, toMint);\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/OfferMakerStrats/Deployable/CashManagement/AdvancedAaveRetail.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tBSD-2-Clause\n\n// AdvancedAaveRetail.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nimport \"../../AaveTrader.sol\";\n\ncontract AdvancedAaveRetail is AaveTrader(2) {\n  constructor(address addressesProvider, address payable MGV)\n    AaveLender(addressesProvider, 0)\n    MangroveOffer(MGV)\n  {}\n\n  // Tries to take base directly from `this` balance. Fetches the remainder on Aave.\n  function __get__(IERC20 outbound_tkn, uint amount)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    uint missing = MangroveOffer.__get__(outbound_tkn, amount);\n    if (missing > 0) {\n      return super.__get__(outbound_tkn, missing);\n    }\n    return 0;\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/lib/SimpleOracle.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tBSD-2-Clause\n\n// SimpleOrale.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\nimport \"../interfaces/IOracle.sol\";\nimport \"./AccessControlled.sol\";\nimport {IERC20} from \"../../MgvLib.sol\";\n\ncontract SimpleOracle is IOracle, AccessControlled {\n  address reader; // if unset, anyone can read price\n  IERC20 public immutable base_token;\n  mapping(address => uint96) internal priceData;\n\n  constructor(address _base) {\n    try IERC20(_base).decimals() returns (uint8 d) {\n      require(d != 0, \"Invalid decimals number for Oracle base\");\n      base_token = IERC20(_base);\n    } catch {\n      revert(\"Invalid Oracle base address\");\n    }\n  }\n\n  function decimals() external view override returns (uint8) {\n    return base_token.decimals();\n  }\n\n  function setReader(address _reader) external onlyAdmin {\n    reader = _reader;\n  }\n\n  function setPrice(address token, uint price) external override onlyAdmin {\n    require(uint96(price) == price, \"price overflow\");\n    priceData[token] = uint96(price);\n  }\n\n  function getPrice(address token)\n    external\n    view\n    override\n    onlyCaller(reader)\n    returns (uint96 price)\n  {\n    price = priceData[token];\n    require(price != 0, \"missing price data\");\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/OfferMakerStrats/CompoundLender.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tBSD-2-Clause\n\n// CompoundLender.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nimport \"./MangroveOffer.sol\";\nimport \"../interfaces/compound/ICompound.sol\";\n\nimport \"hardhat/console.sol\";\n\nabstract contract CompoundLender is MangroveOffer {\n  event ErrorOnRedeem(address ctoken, uint amount, uint errorCode);\n  event ErrorOnMint(address ctoken, uint amount, uint errorCode);\n  event ComptrollerError(address comp, uint errorCode);\n\n  // mapping : ERC20 -> cERC20\n  mapping(IERC20 => IcERC20) overlyings;\n\n  // address of the comptroller\n  IComptroller public immutable comptroller;\n\n  // address of the price oracle used by the comptroller\n  ICompoundPriceOracle public immutable oracle;\n\n  IERC20 immutable weth;\n\n  constructor(address _unitroller, address wethAddress) {\n    comptroller = IComptroller(_unitroller); // unitroller is a proxy for comptroller calls\n    require(_unitroller != address(0), \"Invalid comptroller address\");\n    ICompoundPriceOracle _oracle = IComptroller(_unitroller).oracle(); // pricefeed used by the comptroller\n    require(address(_oracle) != address(0), \"Failed to get price oracle\");\n    oracle = _oracle;\n    weth = IERC20(wethAddress);\n  }\n\n  /**************************************************************************/\n  ///@notice Required functions to let `this` contract interact with compound\n  /**************************************************************************/\n\n  ///@notice approval of ctoken contract by the underlying is necessary for minting and repaying borrow\n  ///@notice user must use this function to do so.\n  function approveLender(address ctoken, uint amount) external onlyAdmin {\n    IERC20 token = underlying(IcERC20(ctoken));\n    token.approve(ctoken, amount);\n  }\n\n  function mint(address ctoken, uint amount) external onlyAdmin {\n    compoundMint(IcERC20(ctoken), amount);\n  }\n\n  function redeem(address ctoken, uint amount) external onlyAdmin {\n    require(compoundRedeem(IcERC20(ctoken), amount) == 0);\n  }\n\n  function isCeth(IcERC20 ctoken) internal view returns (bool) {\n    return (keccak256(abi.encodePacked(ctoken.symbol())) ==\n      keccak256(abi.encodePacked(\"cETH\")));\n  }\n\n  //dealing with cEth special case\n  function underlying(IcERC20 ctoken) internal returns (IERC20) {\n    require(ctoken.isCToken(), \"Invalid ctoken address\");\n    if (isCeth(ctoken)) {\n      // cETH has no underlying() function...\n      return weth;\n    } else {\n      return IERC20(ctoken.underlying());\n    }\n  }\n\n  ///@notice enters markets in order to be able to use assets as collateral\n  function enterMarkets(address[] calldata ctokens) external onlyAdmin {\n    uint[] memory results = comptroller.enterMarkets(ctokens);\n    for (uint i = 0; i < ctokens.length; i++) {\n      require(results[i] == 0, \"Failed to enter market\");\n      IcERC20 ctoken = IcERC20(ctokens[i]);\n      IERC20 token = underlying(ctoken);\n      // adding ctoken.underlying --> ctoken mapping\n      overlyings[token] = ctoken;\n    }\n  }\n\n  function isPooled(address token) public view returns (bool) {\n    IcERC20 ctoken = overlyings[IERC20(token)];\n    return comptroller.checkMembership(address(this), ctoken);\n  }\n\n  ///@notice exits markets\n  function exitMarket(address ctoken) external onlyAdmin {\n    require(comptroller.exitMarket(ctoken) == 0, \"failed to exit marker\");\n  }\n\n  ///@notice claims COMP token for `this` contract. One may afterward transfer them using `MangroveOffer.transferToken`\n  function claimComp() external onlyAdmin {\n    comptroller.claimComp(address(this));\n  }\n\n  /// @notice struct to circumvent stack too deep error in `maxGettableUnderlying` function\n  struct Heap {\n    uint ctokenBalance;\n    uint cDecimals;\n    uint decimals;\n    uint exchangeRateMantissa;\n    uint liquidity;\n    uint collateralFactorMantissa;\n    uint maxRedeemable;\n    uint balanceOfUnderlying;\n    uint priceMantissa;\n    uint underlyingLiquidity;\n    MathError mErr;\n    uint errCode;\n  }\n\n  function heapError(Heap memory heap) private pure returns (bool) {\n    return (heap.errCode != 0 || heap.mErr != MathError.NO_ERROR);\n  }\n\n  /// @notice Computes maximal maximal redeem capacity (R) and max borrow capacity (B|R) after R has been redeemed\n  /// returns (R, B|R)\n  function maxGettableUnderlying(address _ctoken)\n    public\n    view\n    returns (uint, uint)\n  {\n    IcERC20 ctoken = IcERC20(_ctoken);\n    Heap memory heap;\n    // NB balance below is underestimated unless accrue interest was triggered earlier in the transaction\n    (heap.errCode, heap.ctokenBalance, , heap.exchangeRateMantissa) = ctoken\n      .getAccountSnapshot(address(this)); // underapprox\n    heap.priceMantissa = oracle.getUnderlyingPrice(ctoken); //18 decimals\n\n    // balanceOfUnderlying(A) : cA.balance * exchange_rate(cA,A)\n\n    (heap.mErr, heap.balanceOfUnderlying) = mulScalarTruncate(\n      Exp({mantissa: heap.exchangeRateMantissa}),\n      heap.ctokenBalance // ctokens have 8 decimals precision\n    );\n\n    if (heapError(heap)) {\n      return (0, 0);\n    }\n\n    // max amount of outbound_Tkn token than can be borrowed\n    (\n      heap.errCode,\n      heap.liquidity, // is USD:18 decimals\n      /*shortFall*/\n\n    ) = comptroller.getAccountLiquidity(address(this)); // underapprox\n\n    // to get liquidity expressed in outbound_Tkn token instead of USD\n    (heap.mErr, heap.underlyingLiquidity) = divScalarByExpTruncate(\n      heap.liquidity,\n      Exp({mantissa: heap.priceMantissa})\n    );\n    if (heapError(heap)) {\n      return (0, 0);\n    }\n    (, heap.collateralFactorMantissa, ) = comptroller.markets(address(ctoken));\n\n    // if collateral factor is 0 then any token can be redeemed from the pool w/o impacting borrow power\n    // also true if market is not entered\n    if (\n      heap.collateralFactorMantissa == 0 ||\n      !comptroller.checkMembership(address(this), ctoken)\n    ) {\n      return (heap.balanceOfUnderlying, heap.underlyingLiquidity);\n    }\n\n    // maxRedeem:[underlying] = liquidity:[USD / 18 decimals ] / (price(outbound_tkn):[USD.underlying^-1 / 18 decimals] * collateralFactor(outbound_tkn): [0-1] 18 decimals)\n    (heap.mErr, heap.maxRedeemable) = divScalarByExpTruncate(\n      heap.liquidity,\n      mul_(\n        Exp({mantissa: heap.collateralFactorMantissa}),\n        Exp({mantissa: heap.priceMantissa})\n      )\n    );\n    if (heapError(heap)) {\n      return (0, 0);\n    }\n    heap.maxRedeemable = min(heap.maxRedeemable, heap.balanceOfUnderlying);\n    // B|R = B - R*CF\n    return (\n      heap.maxRedeemable,\n      sub_(\n        heap.underlyingLiquidity, //borrow power\n        mul_ScalarTruncate(\n          Exp({mantissa: heap.collateralFactorMantissa}),\n          heap.maxRedeemable\n        )\n      )\n    );\n  }\n\n  ///@notice method to get `outbound_tkn` during makerExecute\n  ///@param outbound_tkn address of the ERC20 managing `outbound_tkn` token\n  ///@param amount of token that the trade is still requiring\n  function __get__(IERC20 outbound_tkn, uint amount)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    if (!isPooled(address(outbound_tkn))) {\n      // if flag says not to fetch liquidity on compound\n      return amount;\n    }\n    // if outbound_tkn == weth, overlying will return cEth\n    IcERC20 outbound_cTkn = IcERC20(overlyings[outbound_tkn]); // this is 0x0 if outbound_tkn is not compound sourced.\n    if (address(outbound_cTkn) == address(0)) {\n      return amount;\n    }\n    outbound_cTkn.accrueInterest();\n    (uint redeemable, ) = maxGettableUnderlying(address(outbound_cTkn));\n\n    uint redeemAmount = min(redeemable, amount);\n\n    if (compoundRedeem(outbound_cTkn, redeemAmount) == 0) {\n      // redeemAmount was transfered to `this`\n      return (amount - redeemAmount);\n    }\n    return amount;\n  }\n\n  function compoundRedeem(IcERC20 coutbound_tkn, uint amountToRedeem)\n    internal\n    returns (uint)\n  {\n    uint errorCode = coutbound_tkn.redeemUnderlying(amountToRedeem); // accrues interests\n    if (errorCode == 0) {\n      //compound redeem was a success\n      // if ETH was redeemed, one needs to convert them into wETH\n      if (isCeth(coutbound_tkn)) {\n        weth.deposit{value: amountToRedeem}();\n      }\n      return 0;\n    } else {\n      //compound redeem failed\n      emit ErrorOnRedeem(address(coutbound_tkn), amountToRedeem, errorCode);\n      return amountToRedeem;\n    }\n  }\n\n  function __put__(IERC20 inbound_tkn, uint amount) internal virtual override {\n    //optim\n    if (amount == 0 || !isPooled(address(inbound_tkn))) {\n      return;\n    }\n    IcERC20 ctoken = IcERC20(overlyings[inbound_tkn]);\n    if (address(ctoken) != address(0)) {\n      compoundMint(ctoken, amount);\n    }\n  }\n\n  // adapted from https://medium.com/compound-finance/supplying-assets-to-the-compound-protocol-ec2cf5df5aa#afff\n  // utility to supply erc20 to compound\n  // NB `ctoken` contract MUST be approved to perform `transferFrom token` by `this` contract.\n  /// @notice user need to approve ctoken in order to mint\n  function compoundMint(IcERC20 ctoken, uint amount) internal {\n    if (isCeth(ctoken)) {\n      // turning `amount` of wETH into ETH\n      weth.withdraw(amount);\n      // minting amount of ETH into cETH\n      ctoken.mint{value: amount}();\n    } else {\n      // Approve transfer on the ERC20 contract (not needed if cERC20 is already approved for `this`)\n      // IERC20(ctoken.underlying()).approve(ctoken, amount);\n      uint errCode = ctoken.mint(amount); // accrues interest\n      // Mint ctokens\n      if (errCode != 0) {\n        emit ErrorOnMint(address(ctoken), amount, errCode);\n      }\n    }\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/interfaces/compound/ICompound.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier: Unlicense\n\n// ICompound.sol\n\n// This is free and unencumbered software released into the public domain.\n\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.\n\n// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For more information, please refer to <https://unlicense.org/>\n\n\n\n\nimport \"../../../MgvLib.sol\";\n\ninterface ICompoundPriceOracle {\n  function getUnderlyingPrice(IcERC20 cToken) external view returns (uint);\n}\n\ninterface IComptroller {\n  // adding usefull public getters\n  function oracle() external returns (ICompoundPriceOracle priceFeed);\n\n  function markets(address cToken)\n    external\n    view\n    returns (\n      bool isListed,\n      uint collateralFactorMantissa,\n      bool isComped\n    );\n\n  /*** Assets You Are In ***/\n\n  function enterMarkets(address[] calldata cTokens)\n    external\n    returns (uint[] memory);\n\n  function exitMarket(address cToken) external returns (uint);\n\n  function getAccountLiquidity(address user)\n    external\n    view\n    returns (\n      uint errorCode,\n      uint liquidity,\n      uint shortfall\n    );\n\n  function claimComp(address holder) external;\n\n  function checkMembership(address account, IcERC20 cToken)\n    external\n    view\n    returns (bool);\n}\n\ninterface IcERC20 is IERC20 {\n  // from https://github.com/compound-finance/compound-protocol/blob/master/contracts/CTokenInterfaces.sol\n  function redeem(uint redeemTokens) external returns (uint);\n\n  function borrow(uint borrowAmount) external returns (uint);\n\n  // for non cETH only\n  function repayBorrow(uint repayAmount) external returns (uint);\n\n  // for cETH only\n  function repayBorrow() external payable;\n\n  // for non cETH only\n  function repayBorrowBehalf(address borrower, uint repayAmount)\n    external\n    returns (uint);\n\n  // for cETH only\n  function repayBorrowBehalf(address borrower) external payable;\n\n  function balanceOfUnderlying(address owner) external returns (uint);\n\n  function getAccountSnapshot(address account)\n    external\n    view\n    returns (\n      uint,\n      uint,\n      uint,\n      uint\n    );\n\n  function borrowRatePerBlock() external view returns (uint);\n\n  function supplyRatePerBlock() external view returns (uint);\n\n  function totalBorrowsCurrent() external returns (uint);\n\n  function borrowBalanceCurrent(address account) external returns (uint);\n\n  function borrowBalanceStored(address account) external view returns (uint);\n\n  function exchangeRateCurrent() external returns (uint);\n\n  function exchangeRateStored() external view returns (uint);\n\n  function getCash() external view returns (uint);\n\n  function accrueInterest() external returns (uint);\n\n  function seize(\n    address liquidator,\n    address borrower,\n    uint seizeTokens\n  ) external returns (uint);\n\n  function redeemUnderlying(uint redeemAmount) external returns (uint);\n\n  function mint(uint mintAmount) external returns (uint);\n\n  // only in cETH\n  function mint() external payable;\n\n  // non cETH only\n  function underlying() external view returns (address); // access to public variable containing the address of the underlying ERC20\n\n  function isCToken() external view returns (bool); // public constant froim CTokenInterfaces.sol\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/OfferMakerStrats/Deployable/CashManagement/SimpleCompoundRetail.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tBSD-2-Clause\n\n// SimpleCompoundRetail.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nimport \"../../CompoundLender.sol\";\n\ncontract SimpleCompoundRetail is CompoundLender {\n  constructor(\n    address _unitroller,\n    address payable _MGV,\n    address wethAddress\n  ) CompoundLender(_unitroller, wethAddress) MangroveOffer(_MGV) {}\n\n  // Tries to take base directly from `this` balance. Fetches the remainder on Compound.\n  function __get__(IERC20 outbound_tkn, uint amount)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    uint missing = MangroveOffer.__get__(outbound_tkn, amount);\n    if (missing > 0) {\n      return super.__get__(outbound_tkn, missing);\n    }\n    return 0;\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/OfferMakerStrats/CompoundTrader.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tBSD-2-Clause\n\n// CompoundTrader.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nimport \"./CompoundLender.sol\";\nimport \"hardhat/console.sol\";\n\nabstract contract CompoundTrader is CompoundLender {\n  event ErrorOnBorrow(address cToken, uint amount, uint errorCode);\n  event ErrorOnRepay(address cToken, uint amount, uint errorCode);\n\n  ///@notice method to get `outbound_tkn` during makerExecute\n  ///@param outbound_tkn address of the ERC20 managing `outbound_tkn` token\n  ///@param amount of token that the trade is still requiring\n  function __get__(IERC20 outbound_tkn, uint amount)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    if (!isPooled(address(outbound_tkn))) {\n      return amount;\n    }\n    IcERC20 outbound_cTkn = IcERC20(overlyings[outbound_tkn]); // this is 0x0 if outbound_tkn is not compound sourced for borrow.\n\n    if (address(outbound_cTkn) == address(0)) {\n      return amount;\n    }\n\n    // 1. Computing total borrow and redeem capacities of underlying asset\n    (uint redeemable, uint liquidity_after_redeem) = maxGettableUnderlying(\n      address(outbound_cTkn)\n    );\n\n    // 2. trying to redeem liquidity from Compound\n    uint toRedeem = min(redeemable, amount);\n\n    uint notRedeemed = compoundRedeem(outbound_cTkn, toRedeem);\n    if (notRedeemed > 0 && toRedeem > 0) {\n      // => notRedeemed == toRedeem\n      // this should not happen unless compound is out of cash, thus no need to try to borrow\n      // log already emitted by `compoundRedeem`\n      return amount;\n    }\n    amount = sub_(amount, toRedeem);\n    uint toBorrow = min(liquidity_after_redeem, amount);\n    if (toBorrow == 0) {\n      return amount;\n    }\n    // 3. trying to borrow missing liquidity\n    uint errorCode = outbound_cTkn.borrow(toBorrow);\n    if (errorCode != 0) {\n      emit ErrorOnBorrow(address(outbound_cTkn), toBorrow, errorCode);\n      return amount; // unable to borrow requested amount\n    }\n    // if ETH were borrowed, one needs to turn them into wETH\n    if (isCeth(outbound_cTkn)) {\n      weth.deposit{value: toBorrow}();\n    }\n    return sub_(amount, toBorrow);\n  }\n\n  /// @notice contract need to have approved `inbound_tkn` overlying in order to repay borrow\n  function __put__(IERC20 inbound_tkn, uint amount) internal virtual override {\n    //optim\n    if (amount == 0 || !isPooled(address(inbound_tkn))) {\n      return;\n    }\n    // NB: overlyings[wETH] = cETH\n    IcERC20 inbound_cTkn = IcERC20(overlyings[inbound_tkn]);\n    if (address(inbound_cTkn) == address(0)) {\n      return;\n    }\n    // trying to repay debt if user is in borrow position for inbound_tkn token\n    uint toRepay = min(\n      inbound_cTkn.borrowBalanceCurrent(address(this)),\n      amount\n    ); //accrues interests\n\n    uint errCode;\n    if (isCeth(inbound_cTkn)) {\n      // turning WETHs to ETHs\n      weth.withdraw(toRepay);\n      // OK since repayBorrow throws if failing in the case of Eth\n      inbound_cTkn.repayBorrow{value: toRepay}();\n    } else {\n      errCode = inbound_cTkn.repayBorrow(toRepay);\n    }\n    uint toMint;\n    if (errCode != 0) {\n      emit ErrorOnRepay(address(inbound_cTkn), toRepay, errCode);\n      toMint = amount;\n    } else {\n      toMint = amount - toRepay;\n    }\n    compoundMint(inbound_cTkn, toMint);\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/OfferMakerStrats/Deployable/MarketMaking/SwingingMarketMaker.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tBSD-2-Clause\n\n// SwingingMarketMaker.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nimport \"../../CompoundTrader.sol\";\n\ncontract SwingingMarketMaker is CompoundTrader {\n  event MissingPriceConverter(address token0, address token1);\n  event NotEnoughProvision(uint amount);\n\n  // price[B][A] : price of A in B = p(B|A) = volume of B obtained/volume of A given\n  mapping(address => mapping(address => uint)) private price; // price[tk0][tk1] is in tk0 precision\n  mapping(address => mapping(address => uint)) private offers;\n\n  constructor(\n    address _unitroller,\n    address payable _MGV,\n    address wethAddress\n  ) CompoundLender(_unitroller, wethAddress) MangroveOffer(_MGV) {}\n\n  // sets P(tk0|tk1)\n  // one wants P(tk0|tk1).P(tk1|tk0) >= 1\n  function setPrice(\n    address tk0,\n    address tk1,\n    uint p\n  ) external onlyAdmin {\n    price[tk0][tk1] = p; // has tk0.decimals() decimals\n  }\n\n  function startStrat(\n    address tk0,\n    address tk1,\n    uint gives // amount of tk0 (with tk0.decimals() decimals)\n  ) external payable onlyAdmin {\n    MGV.fund{value: msg.value}();\n    require(repostOffer(tk0, tk1, gives), \"Could not start strategy\");\n    IERC20(tk0).approve(address(MGV), uint(-1)); // approving MGV for tk0 transfer\n    IERC20(tk1).approve(address(MGV), uint(-1)); // approving MGV for tk1 transfer\n  }\n\n  // at this stage contract has `received` amount in token0\n  function repostOffer(\n    address outbound_tkn,\n    address inbound_tkn,\n    uint gives // in outbound_tkn\n  ) internal returns (bool) {\n    // computing how much inbound_tkn one should ask for `gives` amount of outbound tokens\n    // NB p_10 has inbound_tkn.decimals() number of decimals\n    uint p_10 = price[inbound_tkn][outbound_tkn];\n    if (p_10 == 0) {\n      // ! p_10 has the decimals of inbound_tkn\n      emit MissingPriceConverter(inbound_tkn, outbound_tkn);\n      return false;\n    }\n    uint wants = div_(\n      mul_(p_10, gives), // p(base|quote).(gives:quote) : base\n      10**(IERC20(outbound_tkn).decimals())\n    ); // in base units\n    uint offerId = offers[outbound_tkn][inbound_tkn];\n    if (offerId == 0) {\n      try\n        this.newOffer(outbound_tkn, inbound_tkn, wants, gives, OFR_GASREQ, 0, 0)\n      returns (uint id) {\n        offers[outbound_tkn][inbound_tkn] = id;\n        return true;\n      } catch Error(string memory message) {\n        emit PosthookFail(outbound_tkn, inbound_tkn, offerId, message);\n        return false;\n      }\n    } else {\n      try\n        this.updateOffer(\n          outbound_tkn,\n          inbound_tkn,\n          wants,\n          gives,\n          // offerId is already on the book so a good pivot\n          OFR_GASREQ, // default value\n          0, // default value\n          offerId,\n          offerId\n        )\n      {\n        return true;\n      } catch Error(string memory message) {\n        emit PosthookFail(outbound_tkn, inbound_tkn, offerId, message);\n        return false;\n      }\n    }\n  }\n\n  function __posthookSuccess__(MgvLib.SingleOrder calldata order)\n    internal\n    override\n  {\n    address token0 = order.outbound_tkn;\n    address token1 = order.inbound_tkn;\n    uint offer_received = MP.offer_unpack_wants(order.offer); // amount with token1.decimals() decimals\n    repostOffer({\n      outbound_tkn: token1,\n      inbound_tkn: token0,\n      gives: offer_received\n    });\n  }\n\n  function __get__(IERC20 base, uint amount)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    // checks whether `this` contract has enough `base` token\n    uint missingGet = MangroveOffer.__get__(base, amount);\n    // if not tries to fetch missing liquidity on compound using `CompoundTrader`'s strat\n    return super.__get__(base, missingGet);\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Strategies/OfferMakerStrats/Deployable/CashManagement/AdvancedCompoundRetail.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tBSD-2-Clause\n\n// AdvancedCompoundRetail.sol\n\n// Copyright (c) 2021 Giry SAS. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nimport \"../../CompoundTrader.sol\";\n\ncontract AdvancedCompoundRetail is CompoundTrader {\n  constructor(\n    address _unitroller,\n    address payable _MGV,\n    address wethAddress\n  ) CompoundLender(_unitroller, wethAddress) MangroveOffer(_MGV) {}\n\n  // Tries to take base directly from `this` balance. Fetches the remainder on Compound.\n  function __get__(IERC20 outbound_tkn, uint amount)\n    internal\n    virtual\n    override\n    returns (uint)\n  {\n    uint missing = MangroveOffer.__get__(outbound_tkn, amount);\n    if (missing > 0) {\n      return super.__get__(outbound_tkn, missing);\n    }\n    return 0;\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/periphery/MgvOracle.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n// MgvOracle.sol\n\n// Copyright (C) 2021 Giry SAS.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n\nimport \"../Mangrove.sol\";\nimport \"../MgvLib.sol\";\n\n/* The purpose of the Oracle contract is to act as a gas price and density\n * oracle for the Mangrove. It bridges to an external oracle, and allows\n * a given sender to update the gas price and density which the oracle\n * reports to Mangrove. */\ncontract MgvOracle is IMgvMonitor {\n  address governance;\n  address mutator;\n\n  uint lastReceivedGasPrice;\n  uint lastReceivedDensity;\n\n  constructor(address _governance, address _initialMutator) {\n    governance = _governance;\n    mutator = _initialMutator;\n\n    //NOTE: Hardwiring density for now\n    lastReceivedDensity = type(uint).max;\n  }\n\n  /* ## `authOnly` check */\n  // NOTE: Should use standard auth method, instead of this copy from MgvGovernable\n\n  function authOnly() internal view {\n    require(\n      msg.sender == governance ||\n        msg.sender == address(this) ||\n        governance == address(0),\n      \"MgvOracle/unauthorized\"\n    );\n  }\n\n  function notifySuccess(MgvLib.SingleOrder calldata sor, address taker)\n    external\n    override\n  {\n    // Do nothing\n  }\n\n  function notifyFail(MgvLib.SingleOrder calldata sor, address taker)\n    external\n    override\n  {\n    // Do nothing\n  }\n\n  function setMutator(address _mutator) external {\n    authOnly();\n\n    mutator = _mutator;\n  }\n\n  function setGasPrice(uint gasPrice) external {\n    // governance or mutator are allowed to update the gasprice\n    require(\n      msg.sender == governance || msg.sender == mutator,\n      \"MgvOracle/unauthorized\"\n    );\n\n    lastReceivedGasPrice = gasPrice;\n  }\n\n  function setDensity(uint density) private {\n    // governance or mutator are allowed to update the density\n    require(\n      msg.sender == governance || msg.sender == mutator,\n      \"MgvOracle/unauthorized\"\n    );\n\n    //NOTE: Not implemented, so not made external yet\n  }\n\n  function read(address outbound_tkn, address inbound_tkn)\n    external\n    view\n    override\n    returns (uint gasprice, uint density)\n  {\n    return (lastReceivedGasPrice, lastReceivedDensity);\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/InvertedTakerOperations.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\n\nimport \"../AbstractMangrove.sol\";\nimport {IMaker as IM, MgvLib} from \"../MgvLib.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\nimport \"./Agents/TestMaker.sol\";\n\n/* The following constructs an ERC20 with a transferFrom callback method,\n   and a TestTaker which throws away any funds received upon getting\n   a callback.\n*/\ncontract InvertedTakerOperations_Test is ITaker, HasMgvEvents {\n  TestToken baseT;\n  TestToken quoteT;\n  address base;\n  address quote;\n  AbstractMangrove mgv;\n  TestMaker mkr;\n  bytes4 takerTrade_bytes;\n  uint baseBalance;\n  uint quoteBalance;\n\n  receive() external payable {}\n\n  function a_beforeAll() public {\n    baseT = TokenSetup.setup(\"A\", \"$A\");\n    quoteT = TokenSetup.setup(\"B\", \"$B\");\n    base = address(baseT);\n    quote = address(quoteT);\n    mgv = MgvSetup.setup(baseT, quoteT, true);\n\n    mkr = MakerSetup.setup(mgv, base, quote);\n\n    address(mkr).transfer(10 ether);\n    mkr.provisionMgv(1 ether);\n    mkr.approveMgv(baseT, 10 ether);\n\n    baseT.mint(address(mkr), 5 ether);\n    quoteT.mint(address(this), 5 ether);\n    quoteT.approve(address(mgv), 5 ether);\n    baseBalance = baseT.balanceOf(address(this));\n    quoteBalance = quoteT.balanceOf(address(this));\n\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(base, \"$A\");\n    Display.register(quote, \"$B\");\n    Display.register(address(mgv), \"mgv\");\n    Display.register(address(mkr), \"maker\");\n    Display.register(mgv.vault(), \"vault\");\n  }\n\n  uint toPay;\n\n  function checkPay(\n    address,\n    address,\n    uint totalGives\n  ) external {\n    TestEvents.eq(\n      toPay,\n      totalGives,\n      \"totalGives should be the sum of taker flashborrows\"\n    );\n  }\n\n  bool skipCheck;\n\n  function takerTrade(\n    address _base,\n    address _quote,\n    uint totalGot,\n    uint totalGives\n  ) public override {\n    require(msg.sender == address(mgv));\n    if (!skipCheck) {\n      TestEvents.eq(\n        baseBalance + totalGot,\n        baseT.balanceOf(address(this)),\n        \"totalGot should be sum of maker flashloans\"\n      );\n    }\n    (bool success, ) = address(this).call(\n      abi.encodeWithSelector(takerTrade_bytes, _base, _quote, totalGives)\n    );\n    require(success, \"TradeFail\");\n  }\n\n  function taker_gets_sum_of_borrows_in_execute_test() public {\n    mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    takerTrade_bytes = this.checkPay.selector;\n    toPay = 0.2 ether;\n    (, uint gave) = mgv.marketOrder(base, quote, 0.2 ether, 0.2 ether, true);\n    TestEvents.eq(\n      quoteBalance - gave,\n      quoteT.balanceOf(address(this)),\n      \"totalGave should be sum of taker flashborrows\"\n    );\n  }\n\n  function revertTrade(\n    address,\n    address,\n    uint\n  ) external pure {\n    require(false);\n  }\n\n  function taker_reverts_during_trade_test() public {\n    uint ofr = mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    uint _ofr = mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    takerTrade_bytes = this.revertTrade.selector;\n    skipCheck = true;\n    try mgv.marketOrder(base, quote, 0.2 ether, 0.2 ether, true) {\n      TestEvents.fail(\"Market order should have reverted\");\n    } catch Error(string memory reason) {\n      TestEvents.eq(\"TradeFail\", reason, \"Unexpected throw\");\n      TestEvents.check(\n        TestUtils.hasOffer(mgv, address(base), address(quote), ofr),\n        \"Offer 1 should be present\"\n      );\n      TestEvents.check(\n        TestUtils.hasOffer(mgv, address(base), address(quote), _ofr),\n        \"Offer 2 should be present\"\n      );\n    }\n  }\n\n  function refuseFeeTrade(\n    address _base,\n    address,\n    uint\n  ) external {\n    IERC20(_base).approve(address(mgv), 0);\n  }\n\n  function refusePayTrade(\n    address,\n    address _quote,\n    uint\n  ) external {\n    IERC20(_quote).approve(address(mgv), 0);\n  }\n\n  function taker_refuses_to_deliver_during_trade_test() public {\n    mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    takerTrade_bytes = this.refusePayTrade.selector;\n    try mgv.marketOrder(base, quote, 0.2 ether, 0.2 ether, true) {\n      TestEvents.fail(\"Market order should have reverted\");\n    } catch Error(string memory reason) {\n      TestEvents.eq(\n        reason,\n        \"mgv/takerFailToPayTotal\",\n        \"Unexpected throw message\"\n      );\n    }\n  }\n\n  function vault_receives_quote_tokens_if_maker_is_blacklisted_for_quote_test()\n    public\n  {\n    takerTrade_bytes = this.noop.selector;\n    quoteT.blacklists(address(mkr));\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 50_000, 0);\n    address vault = address(1);\n    mgv.setVault(vault);\n    uint vaultBal = quoteT.balanceOf(vault);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 50_000];\n\n    (uint successes, , ) = mgv.snipes(base, quote, targets, true);\n    TestEvents.check(successes == 1, \"Trade should succeed\");\n    TestEvents.eq(\n      quoteT.balanceOf(vault) - vaultBal,\n      1 ether,\n      \"Vault balance should have increased\"\n    );\n  }\n\n  function noop(\n    address,\n    address,\n    uint\n  ) external {}\n\n  function reenter(\n    address _base,\n    address _quote,\n    uint\n  ) external {\n    takerTrade_bytes = this.noop.selector;\n    skipCheck = true;\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [uint(2), 0.1 ether, 0.1 ether, 100_000];\n    (uint successes, uint totalGot, uint totalGave) = mgv.snipes(\n      _base,\n      _quote,\n      targets,\n      true\n    );\n    TestEvents.check(successes == 1, \"Snipe on reentrancy should succeed\");\n    TestEvents.eq(totalGot, 0.1 ether, \"Incorrect totalGot\");\n    TestEvents.eq(totalGave, 0.1 ether, \"Incorrect totalGave\");\n  }\n\n  function taker_snipe_mgv_during_trade_test() public {\n    mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    takerTrade_bytes = this.reenter.selector;\n    (uint got, uint gave) = mgv.marketOrder(\n      base,\n      quote,\n      0.1 ether,\n      0.1 ether,\n      true\n    );\n    TestEvents.eq(\n      quoteBalance - gave - 0.1 ether,\n      quoteT.balanceOf(address(this)),\n      \"Incorrect transfer (gave) during reentrancy\"\n    );\n    TestEvents.eq(\n      baseBalance + got + 0.1 ether,\n      baseT.balanceOf(address(this)),\n      \"Incorrect transfer (got) during reentrancy\"\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OfferSuccess(base, quote, 1, address(this), 0.1 ether, 0.1 ether);\n    emit OfferSuccess(base, quote, 2, address(this), 0.1 ether, 0.1 ether);\n  }\n\n  function taker_pays_back_correct_amount_1_test() public {\n    uint ofr = mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    uint bal = quoteT.balanceOf(address(this));\n    takerTrade_bytes = this.noop.selector;\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 0.05 ether, 0.05 ether, 100_000];\n    mgv.snipes(base, quote, targets, true);\n    TestEvents.eq(\n      quoteT.balanceOf(address(this)),\n      bal - 0.05 ether,\n      \"wrong taker balance\"\n    );\n  }\n\n  function taker_pays_back_correct_amount_2_test() public {\n    uint ofr = mkr.newOffer(0.1 ether, 0.1 ether, 100_000, 0);\n    uint bal = quoteT.balanceOf(address(this));\n    takerTrade_bytes = this.noop.selector;\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 0.02 ether, 0.02 ether, 100_000];\n    mgv.snipes(base, quote, targets, true);\n    TestEvents.eq(\n      quoteT.balanceOf(address(this)),\n      bal - 0.02 ether,\n      \"wrong taker balance\"\n    );\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Gatekeeping.sol": {
      "content": "pragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\n\nimport \"../AbstractMangrove.sol\";\nimport \"../MgvLib.sol\";\nimport {MgvPack as MP} from \"../MgvPack.sol\";\nimport \"hardhat/console.sol\";\nimport \"@giry/hardhat-test-solidity/test.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\nimport \"./Agents/TestMaker.sol\";\nimport \"./Agents/TestMoriartyMaker.sol\";\nimport \"./Agents/MakerDeployer.sol\";\nimport \"./Agents/TestTaker.sol\";\n\ncontract NotAdmin {\n  AbstractMangrove mgv;\n\n  constructor(AbstractMangrove _mgv) {\n    mgv = _mgv;\n  }\n\n  function setGasprice(uint value) public {\n    mgv.setGasprice(value);\n  }\n\n  function setFee(\n    address base,\n    address quote,\n    uint fee\n  ) public {\n    mgv.setFee(base, quote, fee);\n  }\n\n  function setGovernance(address newGovernance) public {\n    mgv.setGovernance(newGovernance);\n  }\n\n  function kill() public {\n    mgv.kill();\n  }\n\n  function activate(\n    address base,\n    address quote,\n    uint fee,\n    uint density,\n    uint overhead_gasbase,\n    uint offer_gasbase\n  ) public {\n    mgv.activate(base, quote, fee, density, overhead_gasbase, offer_gasbase);\n  }\n\n  function setGasbase(\n    address base,\n    address quote,\n    uint overhead_gasbase,\n    uint offer_gasbase\n  ) public {\n    mgv.setGasbase(base, quote, overhead_gasbase, offer_gasbase);\n  }\n\n  function setGasmax(uint value) public {\n    mgv.setGasmax(value);\n  }\n\n  function setDensity(\n    address base,\n    address quote,\n    uint value\n  ) public {\n    mgv.setDensity(base, quote, value);\n  }\n\n  function setVault(address value) public {\n    mgv.setVault(value);\n  }\n\n  function setMonitor(address value) public {\n    mgv.setMonitor(value);\n  }\n}\n\ncontract Deployer {\n  AbstractMangrove mgv;\n\n  function deploy() public returns (AbstractMangrove) {\n    mgv = MgvSetup.deploy(msg.sender);\n    return mgv;\n  }\n\n  function setGovernance(address governance) public {\n    mgv.setGovernance(governance);\n  }\n}\n\n// In these tests, the testing contract is the market maker.\ncontract Gatekeeping_Test is IMaker, HasMgvEvents {\n  receive() external payable {}\n\n  AbstractMangrove mgv;\n  TestTaker tkr;\n  TestMaker mkr;\n  TestMaker dual_mkr;\n  address base;\n  address quote;\n\n  function gov_is_not_sender_test() public {\n    Deployer deployer = new Deployer();\n    AbstractMangrove _mgv = deployer.deploy();\n\n    TestEvents.eq(\n      _mgv.governance(),\n      address(this),\n      \"governance should return this\"\n    );\n  }\n\n  function a_beforeAll() public {\n    TestToken baseT = TokenSetup.setup(\"A\", \"$A\");\n    TestToken quoteT = TokenSetup.setup(\"B\", \"$B\");\n    base = address(baseT);\n    quote = address(quoteT);\n    mgv = MgvSetup.setup(baseT, quoteT);\n    tkr = TakerSetup.setup(mgv, base, quote);\n    mkr = MakerSetup.setup(mgv, base, quote);\n    dual_mkr = MakerSetup.setup(mgv, quote, base);\n\n    address(tkr).transfer(10 ether);\n    address(mkr).transfer(10 ether);\n    address(dual_mkr).transfer(10 ether);\n\n    bool noRevert;\n    (noRevert, ) = address(mgv).call{value: 10 ether}(\"\");\n\n    mkr.provisionMgv(5 ether);\n    dual_mkr.provisionMgv(5 ether);\n\n    baseT.mint(address(this), 2 ether);\n    quoteT.mint(address(tkr), 1 ether);\n    quoteT.mint(address(mkr), 1 ether);\n    baseT.mint(address(dual_mkr), 1 ether);\n\n    baseT.approve(address(mgv), 1 ether);\n    quoteT.approve(address(mgv), 1 ether);\n    tkr.approveMgv(quoteT, 1 ether);\n\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"Gatekeeping_Test/maker\");\n    Display.register(base, \"$A\");\n    Display.register(quote, \"$B\");\n    Display.register(address(mgv), \"mgv\");\n    Display.register(address(tkr), \"taker[$A,$B]\");\n    Display.register(address(dual_mkr), \"maker[$B,$A]\");\n    Display.register(address(mkr), \"maker[$A,$B]\");\n  }\n\n  /* # Test Config */\n\n  function gov_can_transfer_rights_test() public {\n    NotAdmin notAdmin = new NotAdmin(mgv);\n    mgv.setGovernance(address(notAdmin));\n\n    try mgv.setFee(base, quote, 0) {\n      TestEvents.fail(\"testing contracts should no longer be admin\");\n    } catch {}\n\n    try notAdmin.setFee(base, quote, 1) {} catch {\n      TestEvents.fail(\"notAdmin should have been given admin rights\");\n    }\n    // Logging tests\n    TestEvents.expectFrom(address(mgv));\n    emit SetGovernance(address(notAdmin));\n    emit SetFee(base, quote, 1);\n  }\n\n  function only_gov_can_set_fee_test() public {\n    NotAdmin notAdmin = new NotAdmin(mgv);\n    try notAdmin.setFee(base, quote, 0) {\n      TestEvents.fail(\"nonadmin cannot set fee\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/unauthorized\");\n    }\n  }\n\n  function only_gov_can_set_density_test() public {\n    NotAdmin notAdmin = new NotAdmin(mgv);\n    try notAdmin.setDensity(base, quote, 0) {\n      TestEvents.fail(\"nonadmin cannot set density\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/unauthorized\");\n    }\n  }\n\n  function set_zero_density_test() public {\n    try mgv.setDensity(base, quote, 0) {} catch Error(string memory) {\n      TestEvents.fail(\"setting density to 0 should work\");\n    }\n    // Logging tests\n    TestEvents.expectFrom(address(mgv));\n    emit SetDensity(base, quote, 0);\n  }\n\n  function only_gov_can_kill_test() public {\n    NotAdmin notAdmin = new NotAdmin(mgv);\n    try notAdmin.kill() {\n      TestEvents.fail(\"nonadmin cannot kill\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/unauthorized\");\n    }\n  }\n\n  function killing_updates_config_test() public {\n    (bytes32 global, ) = mgv.config(address(0), address(0));\n    TestEvents.check(\n      MP.global_unpack_dead(global) == 0,\n      \"mgv should not be dead \"\n    );\n    mgv.kill();\n    (global, ) = mgv.config(address(0), address(0));\n    TestEvents.check(MP.global_unpack_dead(global) > 0, \"mgv should be dead \");\n    // Logging tests\n    TestEvents.expectFrom(address(mgv));\n    emit Kill();\n  }\n\n  function kill_is_idempotent_test() public {\n    (bytes32 global, ) = mgv.config(address(0), address(0));\n    TestEvents.check(\n      MP.global_unpack_dead(global) == 0,\n      \"mgv should not be dead \"\n    );\n    mgv.kill();\n    (global, ) = mgv.config(address(0), address(0));\n    TestEvents.check(MP.global_unpack_dead(global) > 0, \"mgv should be dead\");\n    mgv.kill();\n    (global, ) = mgv.config(address(0), address(0));\n    TestEvents.check(\n      MP.global_unpack_dead(global) > 0,\n      \"mgv should still be dead\"\n    );\n    // Logging tests\n    TestEvents.expectFrom(address(mgv));\n    emit Kill();\n    emit Kill();\n  }\n\n  function only_gov_can_set_vault_test() public {\n    NotAdmin notAdmin = new NotAdmin(mgv);\n    try notAdmin.setVault(address(this)) {\n      TestEvents.fail(\"nonadmin cannot set vault\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/unauthorized\");\n    }\n  }\n\n  function only_gov_can_set_monitor_test() public {\n    NotAdmin notAdmin = new NotAdmin(mgv);\n    try notAdmin.setMonitor(address(this)) {\n      TestEvents.fail(\"nonadmin cannot set monitor\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/unauthorized\");\n    }\n  }\n\n  function only_gov_can_set_active_test() public {\n    NotAdmin notAdmin = new NotAdmin(mgv);\n    try notAdmin.activate(quote, base, 0, 100, 30_000, 0) {\n      TestEvents.fail(\"nonadmin cannot set active\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/unauthorized\");\n    }\n  }\n\n  function only_gov_can_set_gasprice_test() public {\n    NotAdmin notAdmin = new NotAdmin(mgv);\n    try notAdmin.setGasprice(0) {\n      TestEvents.fail(\"nonadmin cannot set gasprice\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/unauthorized\");\n    }\n  }\n\n  function only_gov_can_set_gasmax_test() public {\n    NotAdmin notAdmin = new NotAdmin(mgv);\n    try notAdmin.setGasmax(0) {\n      TestEvents.fail(\"nonadmin cannot set gasmax\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/unauthorized\");\n    }\n  }\n\n  function only_gov_can_set_gasbase_test() public {\n    NotAdmin notAdmin = new NotAdmin(mgv);\n    try notAdmin.setGasbase(base, quote, 0, 0) {\n      TestEvents.fail(\"nonadmin cannot set gasbase\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/unauthorized\");\n    }\n  }\n\n  function empty_mgv_ok_test() public {\n    try tkr.marketOrder(0, 0) {} catch {\n      TestEvents.fail(\"market order on empty mgv should not fail\");\n    }\n    // Logging tests\n  }\n\n  function set_fee_ceiling_test() public {\n    try mgv.setFee(base, quote, 501) {} catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/config/fee/<=500\");\n    }\n  }\n\n  function set_density_ceiling_test() public {\n    try mgv.setDensity(base, quote, uint(type(uint32).max) + 1) {\n      TestEvents.fail(\"density above ceiling should fail\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/config/density/32bits\");\n    }\n  }\n\n  function set_gasprice_ceiling_test() public {\n    try mgv.setGasprice(uint(type(uint16).max) + 1) {\n      TestEvents.fail(\"gasprice above ceiling should fail\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/config/gasprice/16bits\");\n    }\n  }\n\n  function set_zero_gasbase_test() public {\n    try mgv.setGasbase(base, quote, 0, 0) {} catch Error(string memory) {\n      TestEvents.fail(\"setting gasbases to 0 should work\");\n    }\n  }\n\n  function set_gasbase_ceiling_test() public {\n    try mgv.setGasbase(base, quote, uint(type(uint24).max) + 1, 0) {\n      TestEvents.fail(\"overhead_gasbase above ceiling should fail\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/config/overhead_gasbase/24bits\");\n    }\n\n    try mgv.setGasbase(base, quote, 0, uint(type(uint24).max) + 1) {\n      TestEvents.fail(\"offer_gasbase above ceiling should fail\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/config/offer_gasbase/24bits\");\n    }\n  }\n\n  function set_gasmax_ceiling_test() public {\n    try mgv.setGasmax(uint(type(uint24).max) + 1) {\n      TestEvents.fail(\"gasmax above ceiling should fail\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/config/gasmax/24bits\");\n    }\n  }\n\n  function makerWants_wider_than_96_bits_fails_newOffer_test() public {\n    try mkr.newOffer(2**96, 1 ether, 10_000, 0) {\n      TestEvents.fail(\"Too wide offer should not be inserted\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/writeOffer/wants/96bits\", \"wrong revert reason\");\n    }\n  }\n\n  function retractOffer_wrong_owner_fails_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 10_000, 0);\n    try mgv.retractOffer(base, quote, ofr, false) {\n      TestEvents.fail(\"Too wide offer should not be inserted\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/retractOffer/unauthorized\", \"wrong revert reason\");\n    }\n  }\n\n  function makerGives_wider_than_96_bits_fails_newOffer_test() public {\n    try mkr.newOffer(1, 2**96, 10_000, 0) {\n      TestEvents.fail(\"Too wide offer should not be inserted\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/writeOffer/gives/96bits\", \"wrong revert reason\");\n    }\n  }\n\n  function makerGasreq_wider_than_24_bits_fails_newOffer_test() public {\n    try mkr.newOffer(1, 1, 2**24, 0) {\n      TestEvents.fail(\"Too wide offer should not be inserted\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/writeOffer/gasreq/tooHigh\", \"wrong revert reason\");\n    }\n  }\n\n  function makerGasreq_bigger_than_gasmax_fails_newOffer_test() public {\n    (bytes32 cfg, ) = mgv.config(base, quote);\n    try mkr.newOffer(1, 1, MP.global_unpack_gasmax(cfg) + 1, 0) {\n      TestEvents.fail(\"Offer should not be inserted\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/writeOffer/gasreq/tooHigh\", \"wrong revert reason\");\n    }\n  }\n\n  function makerGasreq_at_gasmax_succeeds_newOffer_test() public {\n    (bytes32 cfg, ) = mgv.config(base, quote);\n    try\n      mkr.newOffer(1 ether, 1 ether, MP.global_unpack_gasmax(cfg), 0)\n    returns (uint ofr) {\n      TestEvents.check(\n        mgv.isLive(mgv.offers(base, quote, ofr)),\n        \"Offer should have been inserted\"\n      );\n      // Logging tests\n      TestEvents.expectFrom(address(mgv));\n      emit OfferWrite(\n        address(base),\n        address(quote),\n        address(mkr),\n        1 ether, //base\n        1 ether, //quote\n        MP.global_unpack_gasprice(cfg), //gasprice\n        MP.global_unpack_gasmax(cfg), //gasreq\n        ofr, //ofrId\n        0 // prev\n      );\n      emit Debit(\n        address(mkr),\n        TestUtils.getProvision(\n          mgv,\n          address(base),\n          address(quote),\n          MP.global_unpack_gasmax(cfg),\n          0\n        )\n      );\n    } catch {\n      TestEvents.fail(\"Offer at gasmax should pass\");\n    }\n  }\n\n  function makerGasreq_lower_than_density_fails_newOffer_test() public {\n    (, bytes32 cfg) = mgv.config(base, quote);\n    uint amount = (1 + MP.local_unpack_offer_gasbase(cfg)) *\n      MP.local_unpack_density(cfg);\n    try mkr.newOffer(amount - 1, amount - 1, 1, 0) {\n      TestEvents.fail(\"Offer should not be inserted\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/writeOffer/density/tooLow\", \"wrong revert reason\");\n    }\n  }\n\n  function makerGasreq_at_density_suceeds_test() public {\n    (bytes32 glob, bytes32 cfg) = mgv.config(base, quote);\n    uint amount = (1 + MP.local_unpack_offer_gasbase(cfg)) *\n      MP.local_unpack_density(cfg);\n    try mkr.newOffer(amount, amount, 1, 0) returns (uint ofr) {\n      TestEvents.check(\n        mgv.isLive(mgv.offers(base, quote, ofr)),\n        \"Offer should have been inserted\"\n      );\n      // Logging tests\n      TestEvents.expectFrom(address(mgv));\n      emit OfferWrite(\n        address(base),\n        address(quote),\n        address(mkr),\n        amount, //base\n        amount, //quote\n        MP.global_unpack_gasprice(glob), //gasprice\n        1, //gasreq\n        ofr, //ofrId\n        0 // prev\n      );\n      emit Debit(\n        address(mkr),\n        TestUtils.getProvision(mgv, address(base), address(quote), 1, 0)\n      );\n    } catch {\n      TestEvents.fail(\"Offer at density should pass\");\n    }\n  }\n\n  function makerGasprice_wider_than_16_bits_fails_newOffer_test() public {\n    try mkr.newOffer(1, 1, 1, 2**16, 0) {\n      TestEvents.fail(\"Too wide offer should not be inserted\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/writeOffer/gasprice/16bits\", \"wrong revert reason\");\n    }\n  }\n\n  function takerWants_wider_than_160_bits_fails_marketOrder_test() public {\n    try tkr.marketOrder(2**160, 0) {\n      TestEvents.fail(\"takerWants > 160bits, order should fail\");\n    } catch Error(string memory r) {\n      TestEvents.eq(r, \"mgv/mOrder/takerWants/160bits\", \"wrong revert reason\");\n    }\n  }\n\n  function takerWants_above_96bits_fails_snipes_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [\n      ofr,\n      uint(type(uint96).max) + 1,\n      type(uint96).max,\n      type(uint).max\n    ];\n    try mgv.snipes(base, quote, targets, true) {\n      TestEvents.fail(\"Snipes with takerWants > 96bits should fail\");\n    } catch Error(string memory reason) {\n      TestUtils.revertEq(reason, \"mgv/snipes/takerWants/96bits\");\n    }\n  }\n\n  function takerGives_above_96bits_fails_snipes_test() public {\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [\n      ofr,\n      type(uint96).max,\n      uint(type(uint96).max) + 1,\n      type(uint).max\n    ];\n    try mgv.snipes(base, quote, targets, true) {\n      TestEvents.fail(\"Snipes with takerGives > 96bits should fail\");\n    } catch Error(string memory reason) {\n      TestUtils.revertEq(reason, \"mgv/snipes/takerGives/96bits\");\n    }\n  }\n\n  function initial_allowance_is_zero_test() public {\n    TestEvents.eq(\n      mgv.allowances(base, quote, address(tkr), address(this)),\n      0,\n      \"initial allowance should be 0\"\n    );\n  }\n\n  function cannot_snipesFor_for_without_allowance_test() public {\n    TestToken(base).mint(address(mkr), 1 ether);\n    mkr.approveMgv(TestToken(base), 1 ether);\n    uint ofr = mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [ofr, 1 ether, 1 ether, 300_000];\n    try mgv.snipesFor(base, quote, targets, true, address(tkr)) {\n      TestEvents.fail(\"snipeFor should fail without allowance\");\n    } catch Error(string memory reason) {\n      TestUtils.revertEq(reason, \"mgv/lowAllowance\");\n    }\n  }\n\n  function cannot_marketOrderFor_for_without_allowance_test() public {\n    TestToken(base).mint(address(mkr), 1 ether);\n    mkr.approveMgv(TestToken(base), 1 ether);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    try mgv.marketOrderFor(base, quote, 1 ether, 1 ether, true, address(tkr)) {\n      TestEvents.fail(\"marketOrderfor should fail without allowance\");\n    } catch Error(string memory reason) {\n      TestUtils.revertEq(reason, \"mgv/lowAllowance\");\n    }\n  }\n\n  function can_marketOrderFor_for_with_allowance_test() public {\n    TestToken(base).mint(address(mkr), 1 ether);\n    mkr.approveMgv(TestToken(base), 1 ether);\n    mkr.newOffer(1 ether, 1 ether, 100_000, 0);\n    tkr.approveSpender(address(this), 1.2 ether);\n    (uint takerGot, ) = mgv.marketOrderFor(\n      base,\n      quote,\n      1 ether,\n      1 ether,\n      true,\n      address(tkr)\n    );\n    TestEvents.eq(\n      mgv.allowances(base, quote, address(tkr), address(this)),\n      0.2 ether,\n      \"allowance should have correctly reduced\"\n    );\n  }\n\n  /* # Internal IMaker setup */\n\n  bytes trade_cb;\n  bytes posthook_cb;\n\n  // maker's trade fn for the mgv\n  function makerExecute(ML.SingleOrder calldata)\n    external\n    override\n    returns (bytes32 ret)\n  {\n    ret; // silence unused function parameter\n    bool success;\n    if (trade_cb.length > 0) {\n      (success, ) = address(this).call(trade_cb);\n      require(success, \"makerExecute callback must work\");\n    }\n    return \"\";\n  }\n\n  function makerPosthook(\n    ML.SingleOrder calldata order,\n    ML.OrderResult calldata result\n  ) external override {\n    bool success;\n    order; // silence compiler warning\n    if (posthook_cb.length > 0) {\n      (success, ) = address(this).call(posthook_cb);\n      bool tradeResult = (result.mgvData == \"mgv/tradeSuccess\");\n      require(success == tradeResult, \"makerPosthook callback must work\");\n    }\n  }\n\n  /* # Reentrancy */\n\n  /* New Offer failure */\n\n  function newOfferKO() external {\n    try mgv.newOffer(base, quote, 1 ether, 1 ether, 30_000, 0, 0) {\n      TestEvents.fail(\"newOffer on same pair should fail\");\n    } catch Error(string memory reason) {\n      TestUtils.revertEq(reason, \"mgv/reentrancyLocked\");\n    }\n  }\n\n  function newOffer_on_reentrancy_fails_test() public {\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 100_000, 0, 0);\n    trade_cb = abi.encodeWithSelector(this.newOfferKO.selector);\n    require(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n  }\n\n  /* New Offer success */\n\n  // ! may be called with inverted _base and _quote\n  function newOfferOK(address _base, address _quote) external {\n    mgv.newOffer(_base, _quote, 1 ether, 1 ether, 30_000, 0, 0);\n  }\n\n  function newOffer_on_reentrancy_succeeds_test() public {\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 200_000, 0, 0);\n    trade_cb = abi.encodeWithSelector(this.newOfferOK.selector, quote, base);\n    require(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n    require(mgv.best(quote, base) == 1, \"newOffer on swapped pair must work\");\n  }\n\n  function newOffer_on_posthook_succeeds_test() public {\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 200_000, 0, 0);\n    posthook_cb = abi.encodeWithSelector(this.newOfferOK.selector, base, quote);\n    require(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n    require(mgv.best(base, quote) == 2, \"newOffer on posthook must work\");\n  }\n\n  /* Update offer failure */\n\n  function updateOfferKO(uint ofr) external {\n    try mgv.updateOffer(base, quote, 1 ether, 2 ether, 35_000, 0, 0, ofr) {\n      TestEvents.fail(\"update offer on same pair should fail\");\n    } catch Error(string memory reason) {\n      TestUtils.revertEq(reason, \"mgv/reentrancyLocked\");\n    }\n  }\n\n  function updateOffer_on_reentrancy_fails_test() public {\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 100_000, 0, 0);\n    trade_cb = abi.encodeWithSelector(this.updateOfferKO.selector, ofr);\n    require(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n  }\n\n  /* Update offer success */\n\n  // ! may be called with inverted _base and _quote\n  function updateOfferOK(\n    address _base,\n    address _quote,\n    uint ofr\n  ) external {\n    mgv.updateOffer(_base, _quote, 1 ether, 2 ether, 35_000, 0, 0, ofr);\n  }\n\n  function updateOffer_on_reentrancy_succeeds_test() public {\n    uint other_ofr = mgv.newOffer(quote, base, 1 ether, 1 ether, 100_000, 0, 0);\n\n    trade_cb = abi.encodeWithSelector(\n      this.updateOfferOK.selector,\n      quote,\n      base,\n      other_ofr\n    );\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 400_000, 0, 0);\n    require(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n    (, ML.OfferDetail memory od) = mgv.offerInfo(quote, base, other_ofr);\n    require(od.gasreq == 35_000, \"updateOffer on swapped pair must work\");\n  }\n\n  function updateOffer_on_posthook_succeeds_test() public {\n    uint other_ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 100_000, 0, 0);\n    posthook_cb = abi.encodeWithSelector(\n      this.updateOfferOK.selector,\n      base,\n      quote,\n      other_ofr\n    );\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 300_000, 0, 0);\n    require(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n    (, ML.OfferDetail memory od) = mgv.offerInfo(base, quote, other_ofr);\n    require(od.gasreq == 35_000, \"updateOffer on posthook must work\");\n  }\n\n  /* Cancel Offer failure */\n\n  function retractOfferKO(uint id) external {\n    try mgv.retractOffer(base, quote, id, false) {\n      TestEvents.fail(\"retractOffer on same pair should fail\");\n    } catch Error(string memory reason) {\n      TestUtils.revertEq(reason, \"mgv/reentrancyLocked\");\n    }\n  }\n\n  function retractOffer_on_reentrancy_fails_test() public {\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 100_000, 0, 0);\n    trade_cb = abi.encodeWithSelector(this.retractOfferKO.selector, ofr);\n    require(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n  }\n\n  /* Cancel Offer success */\n\n  function retractOfferOK(\n    address _base,\n    address _quote,\n    uint id\n  ) external {\n    mgv.retractOffer(_base, _quote, id, false);\n  }\n\n  function retractOffer_on_reentrancy_succeeds_test() public {\n    uint other_ofr = mgv.newOffer(quote, base, 1 ether, 1 ether, 90_000, 0, 0);\n    trade_cb = abi.encodeWithSelector(\n      this.retractOfferOK.selector,\n      quote,\n      base,\n      other_ofr\n    );\n\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 90_000, 0, 0);\n    require(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n    require(\n      mgv.best(quote, base) == 0,\n      \"retractOffer on swapped pair must work\"\n    );\n  }\n\n  function retractOffer_on_posthook_succeeds_test() public {\n    uint other_ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 190_000, 0, 0);\n    posthook_cb = abi.encodeWithSelector(\n      this.retractOfferOK.selector,\n      base,\n      quote,\n      other_ofr\n    );\n\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 90_000, 0, 0);\n    require(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n    require(mgv.best(base, quote) == 0, \"retractOffer on posthook must work\");\n  }\n\n  /* Market Order failure */\n\n  function marketOrderKO() external {\n    try mgv.marketOrder(base, quote, 0.2 ether, 0.2 ether, true) {\n      TestEvents.fail(\"marketOrder on same pair should fail\");\n    } catch Error(string memory reason) {\n      TestUtils.revertEq(reason, \"mgv/reentrancyLocked\");\n    }\n  }\n\n  function marketOrder_on_reentrancy_fails_test() public {\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 100_000, 0, 0);\n    trade_cb = abi.encodeWithSelector(this.marketOrderKO.selector);\n    require(tkr.take(ofr, 0.1 ether), \"take must succeed or test is void\");\n  }\n\n  /* Market Order Success */\n\n  function marketOrderOK(address _base, address _quote) external {\n    try\n      mgv.marketOrder(_base, _quote, 0.5 ether, 0.5 ether, true)\n    {} catch Error(string memory r) {\n      console.log(\"ERR\", r);\n    }\n  }\n\n  function marketOrder_on_reentrancy_succeeds_test() public {\n    console.log(\n      \"dual mkr offer\",\n      dual_mkr.newOffer(0.5 ether, 0.5 ether, 30_000, 0)\n    );\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 392_000, 0, 0);\n    console.log(\"normal offer\", ofr);\n    trade_cb = abi.encodeWithSelector(this.marketOrderOK.selector, quote, base);\n    require(tkr.take(ofr, 0.1 ether), \"take must succeed or test is void\");\n    require(\n      mgv.best(quote, base) == 0,\n      \"2nd market order must have emptied mgv\"\n    );\n  }\n\n  function marketOrder_on_posthook_succeeds_test() public {\n    uint ofr = mgv.newOffer(base, quote, 0.5 ether, 0.5 ether, 500_000, 0, 0);\n    mgv.newOffer(base, quote, 0.5 ether, 0.5 ether, 200_000, 0, 0);\n    posthook_cb = abi.encodeWithSelector(\n      this.marketOrderOK.selector,\n      base,\n      quote\n    );\n    require(tkr.take(ofr, 0.6 ether), \"take must succeed or test is void\");\n    require(\n      mgv.best(base, quote) == 0,\n      \"2nd market order must have emptied mgv\"\n    );\n  }\n\n  /* Snipe failure */\n\n  function snipesKO(uint id) external {\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [id, 1 ether, type(uint96).max, type(uint48).max];\n    try mgv.snipes(base, quote, targets, true) {\n      TestEvents.fail(\"snipe on same pair should fail\");\n    } catch Error(string memory reason) {\n      TestUtils.revertEq(reason, \"mgv/reentrancyLocked\");\n    }\n  }\n\n  function snipe_on_reentrancy_fails_test() public {\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 60_000, 0, 0);\n    trade_cb = abi.encodeWithSelector(this.snipesKO.selector, ofr);\n    require(tkr.take(ofr, 0.1 ether), \"take must succeed or test is void\");\n  }\n\n  /* Snipe success */\n\n  function snipesOK(\n    address _base,\n    address _quote,\n    uint id\n  ) external {\n    uint[4][] memory targets = new uint[4][](1);\n    targets[0] = [id, 1 ether, type(uint96).max, type(uint48).max];\n    mgv.snipes(_base, _quote, targets, true);\n  }\n\n  function snipes_on_reentrancy_succeeds_test() public {\n    uint other_ofr = dual_mkr.newOffer(1 ether, 1 ether, 30_000, 0);\n    trade_cb = abi.encodeWithSelector(\n      this.snipesOK.selector,\n      quote,\n      base,\n      other_ofr\n    );\n\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 190_000, 0, 0);\n    require(tkr.take(ofr, 0.1 ether), \"take must succeed or test is void\");\n    require(mgv.best(quote, base) == 0, \"snipe in swapped pair must work\");\n  }\n\n  function snipes_on_posthook_succeeds_test() public {\n    uint other_ofr = mkr.newOffer(1 ether, 1 ether, 30_000, 0);\n    posthook_cb = abi.encodeWithSelector(\n      this.snipesOK.selector,\n      base,\n      quote,\n      other_ofr\n    );\n\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 190_000, 0, 0);\n    require(tkr.take(ofr, 1 ether), \"take must succeed or test is void\");\n    require(mgv.best(base, quote) == 0, \"snipe in posthook must work\");\n  }\n\n  function newOffer_on_closed_fails_test() public {\n    mgv.kill();\n    try mgv.newOffer(base, quote, 1 ether, 1 ether, 0, 0, 0) {\n      TestEvents.fail(\"newOffer should fail on closed market\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/dead\");\n    }\n  }\n\n  /* # Mangrove closed/inactive */\n\n  function take_on_closed_fails_test() public {\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 0, 0, 0);\n\n    mgv.kill();\n    try tkr.take(ofr, 1 ether) {\n      TestEvents.fail(\"take offer should fail on closed market\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/dead\");\n    }\n  }\n\n  function newOffer_on_inactive_fails_test() public {\n    mgv.deactivate(base, quote);\n    try mgv.newOffer(base, quote, 1 ether, 1 ether, 0, 0, 0) {\n      TestEvents.fail(\"newOffer should fail on closed market\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/inactive\");\n    }\n  }\n\n  function receive_on_closed_fails_test() public {\n    mgv.kill();\n\n    (bool success, bytes memory retdata) = address(mgv).call{value: 10 ether}(\n      \"\"\n    );\n    if (success) {\n      TestEvents.fail(\"receive() should fail on closed market\");\n    } else {\n      string memory r = TestUtils.getReason(retdata);\n      TestUtils.revertEq(r, \"mgv/dead\");\n    }\n  }\n\n  function marketOrder_on_closed_fails_test() public {\n    mgv.kill();\n    try tkr.marketOrder(1 ether, 1 ether) {\n      TestEvents.fail(\"marketOrder should fail on closed market\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/dead\");\n    }\n  }\n\n  function snipe_on_closed_fails_test() public {\n    mgv.kill();\n    try tkr.take(0, 1 ether) {\n      TestEvents.fail(\"snipe should fail on closed market\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/dead\");\n    }\n  }\n\n  function withdraw_on_closed_ok_test() public {\n    mgv.kill();\n    mgv.withdraw(0.1 ether);\n  }\n\n  function retractOffer_on_closed_ok_test() public {\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 0, 0, 0);\n    mgv.kill();\n    mgv.retractOffer(base, quote, ofr, false);\n  }\n\n  function updateOffer_on_closed_fails_test() public {\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 0, 0, 0);\n    mgv.kill();\n    try mgv.updateOffer(base, quote, 1 ether, 1 ether, 0, 0, 0, ofr) {\n      TestEvents.fail(\"update offer should fail on closed market\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/dead\");\n    }\n  }\n\n  function activation_emits_events_in_order_test() public {\n    mgv.activate(quote, base, 7, 0, 1, 3);\n    TestEvents.expectFrom(address(mgv));\n    emit SetActive(quote, base, true);\n    emit SetFee(quote, base, 7);\n    emit SetDensity(quote, base, 0);\n    emit SetGasbase(quote, base, 1, 3);\n  }\n\n  function updateOffer_on_inactive_fails_test() public {\n    uint ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, 0, 0, 0);\n    mgv.deactivate(base, quote);\n    try mgv.updateOffer(base, quote, 1 ether, 1 ether, 0, 0, 0, ofr) {\n      TestEvents.fail(\"update offer should fail on inactive market\");\n    } catch Error(string memory r) {\n      TestUtils.revertEq(r, \"mgv/inactive\");\n      TestEvents.expectFrom(address(mgv));\n      emit SetActive(base, quote, false);\n    }\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Gas.sol": {
      "content": "pragma solidity ^0.7.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\n\nimport \"../AbstractMangrove.sol\";\nimport \"../MgvLib.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\nimport \"./Agents/TestMaker.sol\";\nimport \"./Agents/TestMoriartyMaker.sol\";\nimport \"./Agents/MakerDeployer.sol\";\nimport \"./Agents/TestTaker.sol\";\n\n// In these tests, the testing contract is the market maker.\ncontract Gas_Test is IMaker {\n  receive() external payable {}\n\n  AbstractMangrove _mgv;\n  TestTaker _tkr;\n  address _base;\n  address _quote;\n\n  function a_beforeAll() public {\n    TestToken baseT = TokenSetup.setup(\"A\", \"$A\");\n    TestToken quoteT = TokenSetup.setup(\"B\", \"$B\");\n    _base = address(baseT);\n    _quote = address(quoteT);\n    _mgv = MgvSetup.setup(baseT, quoteT);\n\n    bool noRevert;\n    (noRevert, ) = address(_mgv).call{value: 10 ether}(\"\");\n\n    baseT.mint(address(this), 2 ether);\n    baseT.approve(address(_mgv), 2 ether);\n    quoteT.approve(address(_mgv), 1 ether);\n\n    Display.register(msg.sender, \"Test Runner\");\n    Display.register(address(this), \"Gatekeeping_Test/maker\");\n    Display.register(_base, \"$A\");\n    Display.register(_quote, \"$B\");\n    Display.register(address(_mgv), \"mgv\");\n\n    _mgv.newOffer(_base, _quote, 1 ether, 1 ether, 100_000, 0, 0);\n    console.log(\"mgv\", address(_mgv));\n\n    _tkr = TakerSetup.setup(_mgv, _base, _quote);\n    quoteT.mint(address(_tkr), 2 ether);\n    _tkr.approveMgv(quoteT, 2 ether);\n    Display.register(address(_tkr), \"Taker\");\n\n    /* set lock to 1 to avoid spurious 15k gas cost */\n    uint ofr = _mgv.newOffer(\n      _base,\n      _quote,\n      0.1 ether,\n      0.1 ether,\n      100_000,\n      0,\n      0\n    );\n    _tkr.take(ofr, 0.1 ether);\n  }\n\n  function getStored()\n    internal\n    view\n    returns (\n      AbstractMangrove,\n      TestTaker,\n      address,\n      address\n    )\n  {\n    return (_mgv, _tkr, _base, _quote);\n  }\n\n  function makerExecute(ML.SingleOrder calldata)\n    external\n    pure\n    override\n    returns (bytes32)\n  {\n    return \"\"; // silence unused function parameter\n  }\n\n  function makerPosthook(\n    ML.SingleOrder calldata order,\n    ML.OrderResult calldata result\n  ) external override {}\n\n  function update_min_move_0_offer_test() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    //uint g = gasleft();\n    //uint h;\n    mgv.updateOffer(base, quote, 1 ether, 1 ether, 100_000, 0, 1, 1);\n    //h = gasleft();\n    //console.log(\"Gas used\", g - h);\n  }\n\n  function update_full_offer_test() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    //uint g = gasleft();\n    //uint h;\n    mgv.updateOffer(base, quote, 0.5 ether, 1 ether, 100_001, 0, 1, 1);\n    //h = gasleft();\n    //console.log(\"Gas used\", g - h);\n  }\n\n  function update_min_move_3_offer_before() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n  }\n\n  function update_min_move_3_offer_test() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    //uint g = gasleft();\n    //uint h;\n    mgv.updateOffer(base, quote, 1.0 ether, 0.1 ether, 100_00, 0, 1, 1);\n    //h = gasleft();\n    //console.log(\"Gas used\", g - h);\n  }\n\n  function update_min_move_6_offer_before() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n  }\n\n  function update_min_move_6_offer_test() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    //uint g = gasleft();\n    //uint h;\n    mgv.updateOffer(base, quote, 1.0 ether, 0.1 ether, 100_00, 0, 1, 1);\n    //h = gasleft();\n    //console.log(\"Gas used\", g - h);\n  }\n\n  function new_offer_test() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    //uint g = gasleft();\n    //uint h;\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 1);\n    //h = gasleft();\n    //console.log(\"Gas used\", g - h);\n  }\n\n  function take_offer_test() public {\n    (\n      AbstractMangrove mgv,\n      TestTaker tkr,\n      address base,\n      address quote\n    ) = getStored();\n    //uint g = gasleft();\n    //uint h;\n    tkr.snipe(mgv, base, quote, 1, 1 ether, 1 ether, 100_000);\n    //h = gasleft();\n    //console.log(\"Gas used\", g - h);\n  }\n\n  function partial_take_offer_test() public {\n    (\n      AbstractMangrove mgv,\n      TestTaker tkr,\n      address base,\n      address quote\n    ) = getStored();\n    //uint g = gasleft();\n    //uint h;\n    tkr.snipe(mgv, base, quote, 1, 0.5 ether, 0.5 ether, 100_000);\n    //h = gasleft();\n    //console.log(\"Gas used\", g - h);\n  }\n\n  function market_order_1_test() public {\n    (\n      AbstractMangrove mgv,\n      TestTaker tkr,\n      address base,\n      address quote\n    ) = getStored();\n    //uint g = gasleft();\n    //uint h;\n    tkr.marketOrder(mgv, base, quote, 1 ether, 1 ether);\n    //h = gasleft();\n    //console.log(\"Gas used\", g - h);\n  }\n\n  function market_order_8_before() public {\n    (AbstractMangrove mgv, , address base, address quote) = getStored();\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n    mgv.newOffer(base, quote, 0.1 ether, 0.1 ether, 100_000, 0, 0);\n  }\n\n  function market_order_8_test() public {\n    (\n      AbstractMangrove mgv,\n      TestTaker tkr,\n      address base,\n      address quote\n    ) = getStored();\n    //uint g = gasleft();\n    //uint h;\n    tkr.marketOrder(mgv, base, quote, 2 ether, 2 ether);\n    //h = gasleft();\n    //console.log(\"Gas used\", g - h);\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/MakerPosthook.sol": {
      "content": "pragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\nimport \"../AbstractMangrove.sol\";\nimport \"../MgvLib.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"./Toolbox/TestUtils.sol\";\n\nimport \"./Agents/TestToken.sol\";\n\ncontract MakerPosthook_Test is IMaker, HasMgvEvents {\n  AbstractMangrove mgv;\n  TestTaker tkr;\n  TestToken baseT;\n  TestToken quoteT;\n  address base;\n  address quote;\n  uint gasreq = 200_000;\n  uint ofr;\n  bytes4 posthook_bytes;\n  uint _gasprice = 50; // will cover for a gasprice of 50 gwei/gas uint\n  uint weiBalMaker;\n  bool abort = false;\n  bool willFail = false;\n  bool makerRevert = false;\n  bool called;\n\n  event Execute(\n    address mgv,\n    address base,\n    address quote,\n    uint offerId,\n    uint takerWants,\n    uint takerGives\n  );\n\n  receive() external payable {}\n\n  function tradeRevert(bytes32 data) internal pure {\n    bytes memory revData = new bytes(32);\n    assembly {\n      mstore(add(revData, 32), data)\n      revert(add(revData, 32), 32)\n    }\n  }\n\n  function makerExecute(MgvLib.SingleOrder calldata trade)\n    external\n    override\n    returns (bytes32)\n  {\n    require(msg.sender == address(mgv));\n    if (makerRevert) {\n      tradeRevert(\"NOK\");\n    }\n    if (abort) {\n      return \"NOK\";\n    }\n    emit Execute(\n      msg.sender,\n      trade.outbound_tkn,\n      trade.inbound_tkn,\n      trade.offerId,\n      trade.wants,\n      trade.gives\n    );\n    //MakerTrade.returnWithData(\"OK\");\n    return \"\";\n  }\n\n  function renew_offer_at_posthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata\n  ) external {\n    require(msg.sender == address(this));\n    called = true;\n    mgv.updateOffer(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      1 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      order.offerId,\n      order.offerId\n    );\n  }\n\n  function update_gas_offer_at_posthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata\n  ) external {\n    require(msg.sender == address(this));\n    called = true;\n    mgv.updateOffer(\n      order.outbound_tkn,\n      order.inbound_tkn,\n      1 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      order.offerId,\n      order.offerId\n    );\n  }\n\n  function failer_posthook(\n    MgvLib.SingleOrder calldata,\n    MgvLib.OrderResult calldata\n  ) external {\n    require(msg.sender == address(this));\n    called = true;\n    TestEvents.fail(\"Posthook should not be called\");\n  }\n\n  function retractOffer_posthook(\n    MgvLib.SingleOrder calldata,\n    MgvLib.OrderResult calldata\n  ) external {\n    require(msg.sender == address(this));\n    called = true;\n    uint bal = mgv.balanceOf(address(this));\n    mgv.retractOffer(base, quote, ofr, true);\n    if (abort) {\n      TestEvents.eq(\n        bal,\n        mgv.balanceOf(address(this)),\n        \"Cancel offer of a failed offer should not give provision to maker\"\n      );\n    }\n  }\n\n  function makerPosthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata result\n  ) external override {\n    require(msg.sender == address(mgv));\n    bool success = (result.mgvData == \"mgv/tradeSuccess\");\n    TestEvents.eq(\n      success,\n      !(abort || makerRevert || willFail),\n      \"incorrect success flag\"\n    );\n    if (makerRevert) {\n      TestEvents.eq(\n        result.mgvData,\n        \"mgv/makerRevert\",\n        \"mgvData should be makerRevert\"\n      );\n    } else if (abort) {\n      TestEvents.eq(\n        result.mgvData,\n        \"mgv/makerAbort\",\n        \"mgvData should be makerAbort\"\n      );\n    } else {\n      TestEvents.eq(\n        result.mgvData,\n        bytes32(\"mgv/tradeSuccess\"),\n        \"mgvData should be tradeSuccess\"\n      );\n    }\n    TestEvents.check(\n      !TestUtils.hasOffer(\n        mgv,\n        order.outbound_tkn,\n        order.inbound_tkn,\n        order.offerId\n      ),\n      \"Offer was not removed after take\"\n    );\n    bool noRevert;\n    (noRevert, ) = address(this).call(\n      abi.encodeWithSelector(posthook_bytes, order, result)\n    );\n  }\n\n  function a_beforeAll() public {\n    Display.register(address(this), \"Test runner\");\n\n    baseT = TokenSetup.setup(\"A\", \"$A\");\n    quoteT = TokenSetup.setup(\"B\", \"$B\");\n    base = address(baseT);\n    quote = address(quoteT);\n    Display.register(base, \"base\");\n    Display.register(quote, \"quote\");\n\n    mgv = MgvSetup.setup(baseT, quoteT);\n    Display.register(address(mgv), \"Mgv\");\n\n    tkr = TakerSetup.setup(mgv, base, quote);\n    Display.register(address(tkr), \"Taker\");\n\n    baseT.approve(address(mgv), 10 ether);\n\n    address(tkr).transfer(10 ether);\n    quoteT.mint(address(tkr), 1 ether);\n    baseT.mint(address(this), 5 ether);\n\n    tkr.approveMgv(baseT, 1 ether); // takerFee\n    tkr.approveMgv(quoteT, 1 ether);\n\n    mgv.fund{value: 10 ether}(address(this)); // for new offer and further updates\n    weiBalMaker = mgv.balanceOf(address(this));\n  }\n\n  function renew_offer_after_partial_fill_test() public {\n    uint mkr_provision = TestUtils.getProvision(\n      mgv,\n      base,\n      quote,\n      gasreq,\n      _gasprice\n    );\n    posthook_bytes = this.renew_offer_at_posthook.selector;\n\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    TestEvents.eq(\n      mgv.balanceOf(address(this)),\n      weiBalMaker - mkr_provision, // maker has provision for his gasprice\n      \"Incorrect maker balance before take\"\n    );\n\n    bool success = tkr.take(ofr, 0.5 ether);\n    TestEvents.check(success, \"Snipe should succeed\");\n    TestEvents.check(called, \"PostHook not called\");\n\n    TestEvents.eq(\n      mgv.balanceOf(address(this)),\n      weiBalMaker - mkr_provision, // maker reposts\n      \"Incorrect maker balance after take\"\n    );\n    TestEvents.eq(\n      TestUtils.getOfferInfo(mgv, base, quote, TestUtils.Info.makerGives, ofr),\n      1 ether,\n      \"Offer was not correctly updated\"\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OfferWrite(\n      base,\n      quote,\n      address(this),\n      1 ether,\n      1 ether,\n      _gasprice,\n      gasreq,\n      ofr,\n      0\n    );\n  }\n\n  function renew_offer_after_complete_fill_test() public {\n    uint mkr_provision = TestUtils.getProvision(\n      mgv,\n      base,\n      quote,\n      gasreq,\n      _gasprice\n    );\n    posthook_bytes = this.renew_offer_at_posthook.selector;\n\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n\n    TestEvents.eq(\n      mgv.balanceOf(address(this)),\n      weiBalMaker - mkr_provision, // maker has provision for his gasprice\n      \"Incorrect maker balance before take\"\n    );\n\n    bool success = tkr.take(ofr, 2 ether);\n    TestEvents.check(called, \"PostHook not called\");\n    TestEvents.check(success, \"Snipe should succeed\");\n\n    TestEvents.eq(\n      mgv.balanceOf(address(this)),\n      weiBalMaker - mkr_provision, // maker reposts\n      \"Incorrect maker balance after take\"\n    );\n    TestEvents.eq(\n      TestUtils.getOfferInfo(mgv, base, quote, TestUtils.Info.makerGives, ofr),\n      1 ether,\n      \"Offer was not correctly updated\"\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OfferWrite(\n      base,\n      quote,\n      address(this),\n      1 ether,\n      1 ether,\n      _gasprice,\n      gasreq,\n      ofr,\n      0\n    );\n  }\n\n  function renew_offer_after_failed_execution_test() public {\n    posthook_bytes = this.renew_offer_at_posthook.selector;\n\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    abort = true;\n\n    bool success = tkr.take(ofr, 2 ether);\n    TestEvents.check(!success, \"Snipe should fail\");\n    TestEvents.check(called, \"PostHook not called\");\n\n    TestEvents.eq(\n      TestUtils.getOfferInfo(mgv, base, quote, TestUtils.Info.makerGives, ofr),\n      1 ether,\n      \"Offer was not correctly updated\"\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OfferWrite(\n      base,\n      quote,\n      address(this),\n      1 ether,\n      1 ether,\n      _gasprice,\n      gasreq,\n      ofr,\n      0\n    );\n  }\n\n  function treat_fail_at_posthook(\n    MgvLib.SingleOrder calldata,\n    MgvLib.OrderResult calldata res\n  ) external {\n    bool success = (res.mgvData == \"mgv/tradeSuccess\");\n    TestEvents.check(!success, \"Offer should be marked as failed\");\n    TestEvents.check(res.makerData == \"NOK\", \"Incorrect maker data\");\n  }\n\n  function failed_offer_is_not_executed_test() public {\n    posthook_bytes = this.treat_fail_at_posthook.selector;\n    uint balMaker = baseT.balanceOf(address(this));\n    uint balTaker = quoteT.balanceOf(address(tkr));\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    abort = true;\n\n    bool success = tkr.take(ofr, 1 ether);\n    TestEvents.check(!success, \"Snipe should fail\");\n    TestEvents.eq(\n      baseT.balanceOf(address(this)),\n      balMaker,\n      \"Maker should not have been debited of her base tokens\"\n    );\n    TestEvents.eq(\n      quoteT.balanceOf(address(tkr)),\n      balTaker,\n      \"Taker should not have been debited of her quote tokens\"\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OfferFail(\n      base,\n      quote,\n      ofr,\n      address(tkr),\n      1 ether,\n      1 ether,\n      \"mgv/makerAbort\"\n    );\n  }\n\n  function update_offer_with_more_gasprice_test() public {\n    uint mkr_provision = TestUtils.getProvision(\n      mgv,\n      base,\n      quote,\n      gasreq,\n      _gasprice\n    );\n    uint standard_provision = TestUtils.getProvision(mgv, base, quote, gasreq);\n    posthook_bytes = this.update_gas_offer_at_posthook.selector;\n    // provision for mgv.global.gasprice\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, 0, 0);\n\n    TestEvents.eq(\n      mgv.balanceOf(address(this)),\n      weiBalMaker - standard_provision, // maker has provision for his gasprice\n      \"Incorrect maker balance before take\"\n    );\n\n    bool success = tkr.take(ofr, 2 ether);\n    TestEvents.check(success, \"Snipe should succeed\");\n    TestEvents.check(called, \"PostHook not called\");\n\n    TestEvents.eq(\n      mgv.balanceOf(address(this)),\n      weiBalMaker - mkr_provision, // maker reposts\n      \"Incorrect maker balance after take\"\n    );\n    TestEvents.eq(\n      TestUtils.getOfferInfo(mgv, base, quote, TestUtils.Info.makerGives, ofr),\n      1 ether,\n      \"Offer was not correctly updated\"\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OfferWrite(\n      base,\n      quote,\n      address(this),\n      1 ether,\n      1 ether,\n      _gasprice,\n      gasreq,\n      ofr,\n      0\n    );\n  }\n\n  function posthook_of_skipped_offer_wrong_gas_should_not_be_called_test()\n    public\n  {\n    posthook_bytes = this.failer_posthook.selector;\n\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n\n    bool success = tkr.snipe(\n      mgv,\n      base,\n      quote,\n      ofr,\n      1 ether,\n      1 ether,\n      gasreq - 1\n    );\n    TestEvents.check(!called, \"PostHook was called\");\n    TestEvents.check(!success, \"Snipe should fail\");\n  }\n\n  function posthook_of_skipped_offer_wrong_price_should_not_be_called_test()\n    public\n  {\n    posthook_bytes = this.failer_posthook.selector;\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    bool success = tkr.snipe(mgv, base, quote, ofr, 1.1 ether, 1 ether, gasreq);\n    TestEvents.check(!success, \"Snipe should fail\");\n    TestEvents.check(!called, \"PostHook was called\");\n  }\n\n  function retract_offer_in_posthook_test() public {\n    uint mkr_provision = TestUtils.getProvision(\n      mgv,\n      base,\n      quote,\n      gasreq,\n      _gasprice\n    );\n    posthook_bytes = this.retractOffer_posthook.selector;\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    TestEvents.eq(\n      mgv.balanceOf(address(this)),\n      weiBalMaker - mkr_provision, // maker has provision for his gasprice\n      \"Incorrect maker balance before take\"\n    );\n    bool success = tkr.take(ofr, 2 ether);\n    TestEvents.check(success, \"Snipe should succeed\");\n    TestEvents.check(called, \"PostHook not called\");\n\n    TestEvents.eq(\n      mgv.balanceOf(address(this)),\n      weiBalMaker, // provision returned to taker\n      \"Incorrect maker balance after take\"\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OfferSuccess(base, quote, ofr, address(tkr), 1 ether, 1 ether);\n    emit Credit(address(this), mkr_provision);\n    emit OfferRetract(base, quote, ofr);\n  }\n\n  function balance_after_fail_and_retract_test() public {\n    uint mkr_provision = TestUtils.getProvision(\n      mgv,\n      base,\n      quote,\n      gasreq,\n      _gasprice\n    );\n    uint tkr_weis = address(tkr).balance;\n    posthook_bytes = this.retractOffer_posthook.selector;\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    TestEvents.eq(\n      mgv.balanceOf(address(this)),\n      weiBalMaker - mkr_provision, // maker has provision for his gasprice\n      \"Incorrect maker balance before take\"\n    );\n    abort = true;\n    bool success = tkr.take(ofr, 2 ether);\n    TestEvents.check(!success, \"Snipe should fail\");\n    uint penalty = weiBalMaker - mgv.balanceOf(address(this));\n    TestEvents.eq(\n      penalty,\n      address(tkr).balance - tkr_weis,\n      \"Incorrect overall balance after penalty for taker\"\n    );\n    TestEvents.expectFrom(address(mgv));\n    emit OfferFail(\n      base,\n      quote,\n      ofr,\n      address(tkr),\n      1 ether,\n      1 ether,\n      \"mgv/makerAbort\"\n    );\n    emit OfferRetract(base, quote, ofr);\n    emit Credit(address(this), mkr_provision - penalty);\n  }\n\n  function update_offer_after_deprovision_in_posthook_succeeds_test() public {\n    posthook_bytes = this.retractOffer_posthook.selector;\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    bool success = tkr.take(ofr, 2 ether);\n    TestEvents.check(called, \"PostHook not called\");\n\n    TestEvents.check(success, \"Snipe should succeed\");\n    mgv.updateOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0, ofr);\n    TestEvents.expectFrom(address(mgv));\n    emit OfferSuccess(base, quote, ofr, address(tkr), 1 ether, 1 ether);\n    emit OfferRetract(base, quote, ofr);\n  }\n\n  function check_best_in_posthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata\n  ) external {\n    called = true;\n    (, bytes32 cfg) = mgv.config(order.outbound_tkn, order.inbound_tkn);\n    TestEvents.eq(\n      MP.local_unpack_best(cfg),\n      ofr,\n      \"Incorrect best offer id in posthook\"\n    );\n  }\n\n  function best_in_posthook_is_correct_test() public {\n    mgv.newOffer(base, quote, 2 ether, 1 ether, gasreq, _gasprice, 0);\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    uint best = mgv.newOffer(\n      base,\n      quote,\n      0.5 ether,\n      1 ether,\n      gasreq,\n      _gasprice,\n      0\n    );\n    posthook_bytes = this.check_best_in_posthook.selector;\n    bool success = tkr.take(best, 1 ether);\n    TestEvents.check(called, \"PostHook not called\");\n    TestEvents.check(success, \"Snipe should succeed\");\n  }\n\n  function check_offer_in_posthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata\n  ) external {\n    called = true;\n    (, , uint __wants, uint __gives, uint __gasprice) = MgvPack.offer_unpack(\n      order.offer\n    );\n    (address __maker, uint __gasreq, , ) = MgvPack.offerDetail_unpack(\n      order.offerDetail\n    );\n    TestEvents.eq(__wants, 1 ether, \"Incorrect wants for offer in posthook\");\n    TestEvents.eq(__gives, 2 ether, \"Incorrect gives for offer in posthook\");\n    TestEvents.eq(__gasprice, 500, \"Incorrect gasprice for offer in posthook\");\n    TestEvents.eq(__maker, address(this), \"Incorrect maker address\");\n    TestEvents.eq(__gasreq, gasreq, \"Incorrect gasreq\");\n  }\n\n  function check_offer_in_posthook_test() public {\n    ofr = mgv.newOffer(base, quote, 1 ether, 2 ether, gasreq, 500, 0);\n    posthook_bytes = this.check_offer_in_posthook.selector;\n    bool success = tkr.take(ofr, 2 ether);\n    TestEvents.check(called, \"PostHook not called\");\n    TestEvents.check(success, \"Snipe should succeed\");\n  }\n\n  function check_lastId_in_posthook(\n    MgvLib.SingleOrder calldata order,\n    MgvLib.OrderResult calldata\n  ) external {\n    called = true;\n    (, bytes32 cfg) = mgv.config(order.outbound_tkn, order.inbound_tkn);\n    TestEvents.eq(\n      MP.local_unpack_last(cfg),\n      ofr,\n      \"Incorrect last offer id in posthook\"\n    );\n  }\n\n  function lastId_in_posthook_is_correct_test() public {\n    mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    ofr = mgv.newOffer(base, quote, 0.5 ether, 1 ether, gasreq, _gasprice, 0);\n    posthook_bytes = this.check_lastId_in_posthook.selector;\n    bool success = tkr.take(ofr, 1 ether);\n    TestEvents.check(called, \"PostHook not called\");\n    TestEvents.check(success, \"Snipe should succeed\");\n  }\n\n  function retract_offer_after_fail_in_posthook_test() public {\n    uint mkr_provision = TestUtils.getProvision(\n      mgv,\n      base,\n      quote,\n      gasreq,\n      _gasprice\n    );\n    posthook_bytes = this.retractOffer_posthook.selector;\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    TestEvents.eq(\n      mgv.balanceOf(address(this)),\n      weiBalMaker - mkr_provision, // maker has provision for his gasprice\n      \"Incorrect maker balance before take\"\n    );\n    abort = true; // maker should fail\n    bool success = tkr.take(ofr, 2 ether);\n    TestEvents.check(called, \"PostHook not called\");\n\n    TestEvents.check(!success, \"Snipe should fail\");\n\n    TestEvents.less(\n      mgv.balanceOf(address(this)),\n      weiBalMaker,\n      \"Maker balance after take should be less than original balance\"\n    );\n    uint refund = mgv.balanceOf(address(this)) + mkr_provision - weiBalMaker;\n    TestEvents.expectFrom(address(mgv));\n    emit OfferFail(\n      base,\n      quote,\n      ofr,\n      address(tkr),\n      1 ether,\n      1 ether,\n      \"mgv/makerAbort\"\n    );\n    emit OfferRetract(base, quote, ofr);\n    emit Credit(address(this), refund);\n  }\n\n  function makerRevert_is_logged_test() public {\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    makerRevert = true; // maker should fail\n    bool success = tkr.take(ofr, 2 ether);\n    TestEvents.expectFrom(address(mgv));\n    emit OfferFail(\n      base,\n      quote,\n      ofr,\n      address(tkr),\n      1 ether,\n      1 ether,\n      \"mgv/makerRevert\"\n    );\n  }\n\n  function reverting_posthook(\n    MgvLib.SingleOrder calldata,\n    MgvLib.OrderResult calldata\n  ) external pure {\n    assert(false);\n  }\n\n  function reverting_posthook_does_not_revert_offer_test() public {\n    TestUtils.getProvision(mgv, base, quote, gasreq, _gasprice);\n    uint balMaker = baseT.balanceOf(address(this));\n    uint balTaker = quoteT.balanceOf(address(tkr));\n    posthook_bytes = this.reverting_posthook.selector;\n\n    ofr = mgv.newOffer(base, quote, 1 ether, 1 ether, gasreq, _gasprice, 0);\n    bool success = tkr.take(ofr, 1 ether);\n    TestEvents.check(success, \"snipe should succeed\");\n    TestEvents.eq(\n      balMaker - 1 ether,\n      baseT.balanceOf(address(this)),\n      \"Incorrect maker balance\"\n    );\n    TestEvents.eq(\n      balTaker - 1 ether,\n      quoteT.balanceOf(address(tkr)),\n      \"Incorrect taker balance\"\n    );\n  }\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/ERC20.sol": {
      "content": "pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier: MIT\n\n\n\nimport \"./SafeMath.sol\";\nimport {IERC20} from \"../MgvLib.sol\";\n\n// From OpenZeppelin\n//The MIT License (MIT)\n\n//Copyright (c) 2016-2020 zOS Global Limited\n\n//Permission is hereby granted, free of charge, to any person obtaining\n//a copy of this software and associated documentation files (the\n//\"Software\"), to deal in the Software without restriction, including\n//without limitation the rights to use, copy, modify, merge, publish,\n//distribute, sublicense, and/or sell copies of the Software, and to\n//permit persons to whom the Software is furnished to do so, subject to\n//the following conditions:\n\n//The above copyright notice and this permission notice shall be included\n//in all copies or substantial portions of the Software.\n\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n//MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n//IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n//CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n//TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n//SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address payable) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes memory) {\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n    return msg.data;\n  }\n}\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n  using SafeMath for uint;\n\n  mapping(address => uint) private _balances;\n\n  mapping(address => mapping(address => uint)) private _allowances;\n\n  uint private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n\n  /**\n   * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n   * a default value of 18.\n   *\n   * To select a different value for {decimals}, use {_setupDecimals}.\n   *\n   * All three of these values are immutable: they can only be set once during\n   * construction.\n   */\n  constructor(string memory __name, string memory __symbol) {\n    _name = __name;\n    _symbol = __symbol;\n    _decimals = 18;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public view override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n   * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n   *\n   * Tokens usually opt for a value of 18, imitating the relationship between\n   * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n   * called.\n   *\n   * NOTE: This information is only used for _display_ purposes: it in\n   * no way affects any of the arithmetic of the contract, including\n   * {IERC20-balanceOf} and {IERC20-transfer}.\n   */\n  function decimals() public view override returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n   */\n  function totalSupply() public view override returns (uint) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n   */\n  function balanceOf(address account) public view override returns (uint) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address recipient, uint amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n   */\n  function allowance(address owner, address spender)\n    public\n    view\n    virtual\n    override\n    returns (uint)\n  {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {ERC20}.\n   *\n   * Requirements:\n   *\n   * - `sender` and `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   * - the caller must have allowance for ``sender``'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint amount\n  ) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      _msgSender(),\n      _allowances[sender][_msgSender()].sub(\n        amount,\n        \"ERC20: transfer amount exceeds allowance\"\n      )\n    );\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint addedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender].add(addedValue)\n    );\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(address spender, uint subtractedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender].sub(\n        subtractedValue,\n        \"ERC20: decreased allowance below zero\"\n      )\n    );\n    return true;\n  }\n\n  /**\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\n   *\n   * This is internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `sender` cannot be the zero address.\n   * - `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   */\n  function _transfer(\n    address sender,\n    address recipient,\n    uint amount\n  ) internal virtual {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    _balances[sender] = _balances[sender].sub(\n      amount,\n      \"ERC20: transfer amount exceeds balance\"\n    );\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   */\n  function _mint(address account, uint amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  function _burn(address account, uint amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    _balances[account] = _balances[account].sub(\n      amount,\n      \"ERC20: burn amount exceeds balance\"\n    );\n    _totalSupply = _totalSupply.sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n   *\n   * This internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(\n    address owner,\n    address spender,\n    uint amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Sets {decimals} to a value other than the default one of 18.\n   *\n   * WARNING: This function should only be called from the constructor. Most\n   * applications that interact with token contracts will not expect\n   * {decimals} to ever change, and may work incorrectly if it does.\n   */\n  function _setupDecimals(uint8 decimals_) internal {\n    _decimals = decimals_;\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * will be to transferred to `to`.\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint amount\n  ) internal virtual {}\n\n  function deposit() external payable override {}\n\n  function withdraw(uint) external override {}\n}\n"
    },
    "cache/solpp-generated-contracts/Tests/Agents/MoneyMarket.sol": {
      "content": "pragma solidity ^0.7.4;\npragma abicoder v2;\n\n// SPDX-License-Identifier:\tAGPL-3.0\n\n\n\nimport \"./TestToken.sol\";\nimport {SafeMath as S} from \"../SafeMath.sol\";\n\ncontract MoneyMarket {\n  // all prices are 1:1\n  // interest rate is 0\n  // the market has infinite liquidity\n\n  // money market must be admin of all tokens to work\n  // use token.addAdmin(address(moneyMarket)) to give it admin power\n\n  uint constant RATIO = 13_000; // basis points\n  TestToken[] tokens;\n  mapping(TestToken => mapping(address => uint)) borrows;\n  mapping(TestToken => mapping(address => uint)) lends;\n\n  constructor(TestToken[] memory _tokens) {\n    tokens = _tokens;\n  }\n\n  function min(uint a, uint b) internal pure returns (uint) {\n    return a < b ? a : b;\n  }\n\n  function borrow(TestToken token, uint amount) external returns (bool) {\n    uint lent = getLends();\n    uint borrowed = getBorrows();\n    if (S.div(S.mul(S.add(borrowed, amount), RATIO), 10_000) <= lent) {\n      borrows[token][msg.sender] += amount;\n      token.mint(address(this), amount); // magic minting\n      token.transfer(msg.sender, amount);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function lend(TestToken token, uint amount) external {\n    token.transferFrom(msg.sender, address(this), amount);\n    lends[token][msg.sender] += amount;\n  }\n\n  function repay(TestToken token, uint _amount) external {\n    uint amount = min(borrows[token][msg.sender], _amount);\n    token.transferFrom(msg.sender, address(this), amount);\n    borrows[token][msg.sender] -= amount;\n  }\n\n  function redeem(TestToken token, uint _amount) external {\n    uint amount = min(lends[token][msg.sender], _amount);\n    token.transfer(msg.sender, amount);\n    lends[token][msg.sender] -= amount;\n  }\n\n  function getBorrows() public view returns (uint total) {\n    for (uint i = 0; i < tokens.length; i++) {\n      total += borrows[tokens[i]][msg.sender];\n    }\n  }\n\n  function getLends() public view returns (uint total) {\n    for (uint i = 0; i < tokens.length; i++) {\n      total += lends[tokens[i]][msg.sender];\n    }\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 20000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}