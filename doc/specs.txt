# --------------------------------------------------------------------
pred isfree(uint value) :=
  500 <= value

pred isdensity(uint value) :=
  0 <= value < 2^32

pred isoverhead(value) :=
  0 <= value < 2^24

pred isoffer(value) :=
  0 <= value < 2^24

# --------------------------------------------------------------------
pred islivedex(global) :=
  FIXME

pred isactive(local) :=
  FIXME

# --------------------------------------------------------------------
type id_t          = uint24
type gasprice_t    = uint16
type overhead_gb_t = uint24
type offer_gb_t    = uint24
type wants_t       = uint96
type gives_t       = uint96
type gasreq_t      = uint24

type global = {
  monitor   : address;
  useOracle : bool;
  notify    : bool;
  gasprice  : gasprice_t;
  gasmax    : uint24;
  dead      : bool;
}

type local = {
  active   : bool;
  fee      : uint16;
  density  : uint32;
  overhead : overhead_gb_t;
  offer    : offer_gb_t;
  lock     : bool;
  best     : id_t;
  last     : id_t;
} = {
  active   = False;
  fee      = 0;
  density  = 0;
  overhead = 0;
  offer    = 0;
  lock     = False;
  best     = 0;
  last     = 0;
}

type offer = {
  prev     : id_t;
  next     : id_t;
  gives    : gives_t;
  wants    : wants_t;
  gasprice : gasprice_t;
} = {
  prev     = 0;
  next     = 0;
  gives    = 0;
  wants    = 0;
  gasprice = 0;
}

type offerDetail = {
  maker    : address;
  gasreq   : gasreq_t;
  overhead : overhead_gb_t;
  offer    : offer_gb_t;
} = {
  maker    = 0;
  gasreq   = 0;
  overhead = 0;
  offer    = 0;
}

type state = {
  governance   : address;
  vault        : address;
  global       : global;
  locals       : base:address * quot:address => local;
  offers       : base:address * quot:address * id:uint => offer;
  offerDetails : base:address * quot:address * id:uint => offerDetail;
  nonces       : address => uint;
  balanceOf    : address => uint;
}

# --------------------------------------------------------------------
global state : state

# --------------------------------------------------------------------
pred is_offer_valid(offer:offer) :=
  offer.id > 0

op offer_cmp_key(v:offer * offerDetail) :=
    (v.1.wants, v.1.gives, v.2.gasreq),

op offer_cmp(lo:offer * offerDetail, ro:offer * offerDetail) :=
  compare (offer_cmp_key(lo), offer_cmp_key(ro))

invariant all_ids_correct :=
  forall (base:address) (quot:address) (id:uint),
       is_offer_valid(state.offers[base,quot,id])
    => state.offers[base,quot,id].id <= state.locals[base,quot].last

invariant offers_chained :=
  forall (base:address) (quot:address), exists! (ids:uint list),
       head 0 ids = state.locals[base,quot].best
    /\ last 0 ids = state.locals[base,quot].last
    /\ uniq ids
    /\ 0 \notin ids
    /\ (forall i, 0 <= i < len(ids) => (
            state.offers[base,quot,ids[i]].prev = (i > 0 ? ids[i-1] : 0)
         /\ state.offers[base,quot,ids[i]].next = (i < len(ids)-1 ? ids[i+1] : 0)
         /\ state.offers[base,quot,ids[i]].gives > 0))
    /\ (forall id, id \notin ids => state.offers[base,quot,id].gives == 0)

invariant offers_ordered :=
  forall (base:address) (quot:address) (id:uint), id <> 0 =>
    let nextid := state.offers[base,quot,id].next in
      nextid <> 0 => offer_cmp(
         (state.offers[base,quot,id    ], state.offerDetails[base,quot,id    ]),
         (state.offers[base,quot,nextid], state.offerDetails[base,quot,nextid]),
       )

logic ids(base, quot) :=
  # the existential witness of the existential in the invariant `offers_chained`
  choose (offers_chained[base,quot])

invariant balance_ge0 :=
  forall (a:address), state.balanceOf[a] >= 0

# --------------------------------------------------------------------
op get_full_state(...) :=
  FIXME # offer information without next/prev pointers
  # Allows to compare offers regardless of their resp. positions

op is_null_offer(...) :=
  FIXME # offer is NULL (i.e. does not exist)

# --------------------------------------------------------------------
 - offerInfo
 - best
 - locked
 - isLive
 - unlockedMarketOnly

 - liveDexOnly()
     ensures:
       - not state@old.global.dead

 - activeMarketOnly(global global, local local)
     ensures:
       - islivedex(global)
       - isactive(local)

 - newOffer(
     address quote   ,
     uint    wants   ,
     uint    gives   ,
     uint    gasreq  ,
     uint    gasprice,
     uint    pivotId ,
   )
     ensures:
       - gives > 0
       - gasreq <= state@old.gasmax       # Global invariant?
       - 0 <= gives < 2^24                # Global invariant?
       - 0 <= wants < 2^24                # Global invariant?
       - XXX # FIXME: density check
       - not state@old[base,quote].lock
       - state@old.vault = state.vault
       - state@old.governance = state.governance
       - state@old.nonces = state.nonces
       - 0 < result
       - is_null_offer(state@old, base, quot, result)
       - exists i, ids(base, quot) = insert i result ids@old(base, quot)
       - forall (id:uint), id <> result =>
             get_full_offer(state@old, base, quot, id)
           = get_full_offer(state    , base, quot, id)
       - get_full_offer(state, base, quot, result) = {
           gives    = gives;
           wants    = wants;
           gasprice = max(gasprice, state@old.gasprice);
           maker    = ctxt.sender;
           gasreq   = gasreq;
           overhead = state@old.global.overhead;
           offer    = state@old.global.offer;
         }
       - forall (a:address),
           a <> ctxt.sender => state@old.balanceOf[a] == state.balanceOf[a]
       - state.balanceOf[ctxt.sender] = # negative balance?
               state@old.balanceOf[ctxt.sender]
             - provision(get_full_offer(state    , base, quit, oid))

 - updateOffer(
     address base    ,
     address quote   ,
     uint    wants   ,
     uint    gives   ,
     uint    gasreq  ,
     uint    gasprice,
     uint    pivotId ,
     uint    oid     ,
   )
     ensures:
       # What about updating a null offer
       - gives > 0
       - gasreq <= state@old.gasmax       # Global invariant?
       - 0 <= gives < 2^24                # Global invariant?
       - 0 <= wants < 2^24                # Global invariant?
       - XXX # FIXME: density check
       - not state@old[base,quote].lock
       - ctxt.sender == state@old.offerDetails[base,quot,oid].maker
       - state@old.vault = state.vault
       - state@old.governance = state.governance
       - state@old.nonces = state.nonces
       - ids@old(base, quot) = ids(base, quot)
       - forall (id:uint), id <> oid =>
             get_full_offer(state@old, base, quot, id)
           = get_full_offer(state    , base, quot, id)
       - get_full_offer(state, base, quot, oid) = {
           gives    = gives;
           wants    = wants;
           gasprice = max(gasprice, state@old.gasprice);
           maker    = ctxt.sender;
           gasreq   = gasreq;
           overhead = get_full_offer(state@old, base, quot, oid).overhead;
           offer    = get_full_offer(state@old, base, quot, oid).offer;
         }
       - forall (a:address),
           a <> ctxt.sender => state@old.balanceOf[a] == state.balanceOf[a]
       - state.balanceOf[ctxt.sender] = # negative balance?
               state@old.balanceOf[ctxt.sender]
             + provision(get_full_offer(state@old, base, quot, oid))
             - provision(get_full_offer(state    , base, quit, oid))
       - result = oid # What for?

 - retractOffer(
     address base  ,
     address quote ,
     int     oid   ,
     bool    delete,
   )
     ensures:
       - not state@old[base,quote].lock
       - ctxt.sender == state@old.offerDetails[base,quot,oid].maker
       - eq_books_except(state@old, state, base, quot)
       - state@old.vault = state.vault
       - state@old.governance = state.governance
       - state@old.nonces = state.nonces
       - remove id ids@old(base, quot) = ids(base, quot)
       - forall (id:uint), id <> oid =>
             get_full_offer(state@old, base, quot, id)
           = get_full_offer(state    , base, quot, id)
       - not delete =>
             get_full_offer(state    , base, quot, oid)
           = get_full_offer(state@old, base, quot, oid)[gives <- 0]
       - not delete =>
           state@old.balanceOf = state.balanceOf
       - delete =>
           is_null_offer(state, base, quot, oid)
       - delete =>
           forall (a:address),
                a <> state@old.offerDetails[base,quot,oid].maker
             => state@old.balanceOf[a] == state.balanceOf[a]
       - delete =>
           let a := state@old.offerDetails[base,quot,oid].maker =>
           state.balenceOf[a] =
               state@old.balenceOf[a]
             + provision(get_full_offer(state@old, base, quot, oid))

 - fund
 - withdraw
 - marketOrder
 - marketOrderFor

 - snipe
 - snipeFor
 - snipes
 - snipesFor

 - writeOffer

 - findPosition
 - better

 - generalMarketOrder(
     address base   ,
     address quote  ,
     uint takerWants,
     uint takerGives,
     address taker  ,
   )
     ensures:
       - islivedex(state@old.global)
       - isactive(state@old.locals[base,quote])

 - internalMarkerOrder
 - generalSnipe
 - internalSnipes
 - execute
 - postExecute
 - makerPosthook
 - dirtyDeleteOffer

 - applyFee
 - applyPenalty
 - sendPenalty

 - getConfig
 - config

 - activate(
     address base    ,
     address quote   ,
     uint    fee     ,
     uint    density ,
     uint    overhead,
     uint    offer   ,
   )
     ensures:
       - isauthed(ctxt, state@old)
       - isfee(free)
       - isdensity(density)
       - isoverhead(overhead)
       - isoffer(offer)
       - state = state@old[
           locals[base,quote].active   <- true    ,
           locals[base,quote].density  <- density ,
           locals[base,quote].overhead <- overhead,
           locals[base,quote].offer    <- offer   ,
         ]

 - deactivate(
     address base ,
     address quote,
   )
     ensures:
       - isauthed(ctxt, state@old)
       - state = state@old[
           locals[base,quote].active <- false;
         ]

 - setFee(
     address base ,
     address quote,
     uint    value,
   )
     ensures:
       - isauthed(ctxt, state@old)
       - isfee(value)
       - state = state@old[
           locals[base,quote].free <- value
         ]

 - setDensity(
     address base ,
     address quote,
     uint    value,
   )
     ensures:
       - isauthed(ctxt, state@old)
       - isdensity(value)
       - state = state@old[
           locals[base,quote].density <- value
         ]

 - setGasBase(
     address base    ,
     address quote   ,
     uint    overhead,
     uint    offer   ,
   )
     ensures:
       - isauthed(ctxt, state@old)
       - isoverhead(overhead)
       - isoffer(offer)
       - state = state@old[
           locals[base,quote].offer    <- offer,
           locals[base,quote].overhead <- overhead,
         ]

 - kill
     ensures:
       - isauthed(ctxt, state@old)
       - state = state@old[global.dead <- 1]

 - setGasprice(uint value)
     ensures:
       - isauthed(ctxt, state@old)
       - 0 <= value < 2^16
       - state = state@old[global.gasprice <- value]

 - setGasmax(uint value)
     ensures:
       - isauthed(ctxt, state@old)
       - 0 <= value < 2^24
       - state = state@old[global.gasmax <- value]

 - setGovernance(address value)
     ensures:
       - isauthed(ctxt, state@old)
       - state = state@old[governance <- value]

 - setVault
 - setMonitor
 - authOnly
 - setUseOracle
 - setNotify
 - debitWei
 - creditWei
 - permit
 - approve
 - stitchOffers
 - deductSenderAllowance
 - flashloan
 - invertedFlashLoan
 - makerExecute
 - innerDecode
 - innerRevert
 - transferToken
